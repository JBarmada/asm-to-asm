//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;
typedef int64_t int128_t;
typedef uint64_t uint128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int32_t _isctype(uint32_t c, int32_t mask);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
void avaliatokens(char ** aux, int32_t * frac, int32_t i);
float32_t calcula(int32_t * frac, int32_t * r);
void copyr(void);
int64_t deregister_tm_clones(void);
void divtokens(char * exp, int32_t * frac);
int64_t dopr(char * buffer, uint64_t maxlen, char * format, int32_t * args);
void fmtfp(char * buffer, int64_t * currlen, uint64_t maxlen, float128_t fvalue, int32_t min, uint32_t max, int32_t flags);
void fmtint(char * buffer, int64_t * currlen, uint64_t maxlen, int64_t value, int32_t base, int32_t min, int32_t max, uint32_t flags);
int64_t frac_init(int64_t a1);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
void function_1090(void);
int64_t * function_10a0(int64_t * s, int32_t c, int32_t n);
int32_t function_10b0(int32_t c, struct _IO_FILE * stream);
int64_t * function_10c0(int64_t delta);
void function_10d0(int32_t status);
int64_t function_325d(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3268(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3273(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_327e(void);
int64_t function_3285(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
void help(void);
int32_t libmin_atoi(char * s);
char * libmin_calloc(uint64_t num, uint64_t nsize);
void libmin_fail(uint32_t code);
int64_t libmin_free(int64_t a1);
int64_t libmin_free_part_0(int64_t a1);
int32_t libmin_getline(char ** line, int64_t * bufflen, int32_t * fp);
int32_t libmin_getopt(uint32_t argc, char ** argv, char * optstring);
int64_t libmin_malloc(uint64_t a1);
char * libmin_memcpy(char * dest, int32_t * src, int64_t n);
char * libmin_memset(char * dest, uint32_t c, uint64_t n);
int32_t libmin_meof(int32_t * mfile);
int32_t libmin_mgetc(int32_t * mfile);
char * libmin_mgets(char * s, int64_t size, int32_t * mfile);
int32_t libmin_printf(char * fmt, ...);
char * libmin_realloc(char * block, uint64_t size);
int32_t libmin_snprintf(char * s, int64_t size, char * fmt, ...);
int32_t libmin_strcmp(char * l, char * r);
char * libmin_strcpy(char * dest, char * src);
int64_t libmin_strcspn(char * s, char * c);
int64_t libmin_strlen(char * str);
char * libmin_strncpy(char * dst, char * src, int64_t n);
int64_t libmin_strspn(char * s, char * c);
char * libmin_strtok(char * s, char * sep);
void libmin_success(void);
void libtarg_fail(int32_t code);
void libtarg_putc(char c);
char * libtarg_sbrk(int64_t inc);
void libtarg_success(void);
void misto(int32_t mist, int32_t * frac, int32_t i);
int64_t my_modf_isra_0(int64_t a1);
void print(char * exp, int32_t * r, float32_t dec, int32_t * frac);
int64_t register_tm_clones(void);
int64_t simplifica(int64_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
int64_t g2 = -0x19c400001821; // 0x4578
int64_t g3 = -0x1b1400001971; // 0x46c8
int64_t g4 = -0x1c6400001ac1; // 0x4818
int64_t g5 = 0x20002000200020; // 0x7062
int32_t g7 = 1; // 0x7270
int32_t g8 = 1; // 0x7274
struct _IO_FILE * g9 = NULL; // 0x7278
char g10 = 0; // 0x7280
int32_t g11 = 0; // 0x7288
int32_t g12 = 0; // 0x728c
int32_t g13 = 0; // 0x728d
int64_t g14 = 0; // 0x7290
int64_t g15 = 0; // 0x7298
char * g16; // 0x72a0
int32_t * head = NULL; // 0x72b0
int32_t * minput = (int32_t *)0x7040; // 0x7020
int32_t * tail = NULL; // 0x72a8
int32_t g17;
int32_t verb = 0; // 0x7284
int64_t * g6 = &g5; // 0x7268

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x6fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g17;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int64_t * function_10a0(int64_t * s, int32_t c, int32_t n) {
    // 0x10a0
    return memset(s, c, n);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(int32_t c, struct _IO_FILE * stream) {
    // 0x10b0
    return fputc(c, stream);
}

// Address range: 0x10c0 - 0x10cb
int64_t * function_10c0(int64_t delta) {
    // 0x10c0
    return sbrk(delta);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(int32_t status) {
    // 0x10d0
    exit(status);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/frac-calc/frac-calc.c
// Address range: 0x10e0 - 0x1280
// Line range:    169 - 221
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1101
    g7 = 0;
    while (true) {
      lab_0x111e:
        // 0x111e
        switch (libmin_getopt(argc, argv, "vhV")) {
            case -1: {
                // 0x11ac
                if (verb != 0) {
                    // 0x1267
                    libmin_printf("Verbose level set at: %d\n", (int64_t)verb);
                }
                libmin_printf("-------------------\n");
                libmin_printf("FRACTION CALCULATOR\nPlease entry the desired operation:\n(It is necessary to add a space between the fractions, like a/b + c/d)\n-> ");
                int64_t v2; // bp-200, 0x10e0
                libmin_mgets((char *)&v2, 60, minput);
                int64_t v3; // bp-296, 0x10e0
                divtokens((char *)&v2, (int32_t *)&v3);
                int64_t v4; // bp-248, 0x10e0
                float32_t v5 = calcula((int32_t *)&v3, (int32_t *)&v4); // 0x1219
                print((char *)&v2, (int32_t *)&v4, v5, (int32_t *)&v3);
                libmin_printf("\nDo you want to do another operation?\nenter 1 for yes\n");
                int64_t v6; // bp-136, 0x10e0
                libmin_mgets((char *)&v6, 60, minput);
                while (libmin_atoi((char *)&v6) == 1) {
                    // 0x11e0
                    libmin_printf("-------------------\n");
                    libmin_printf("FRACTION CALCULATOR\nPlease entry the desired operation:\n(It is necessary to add a space between the fractions, like a/b + c/d)\n-> ");
                    libmin_mgets((char *)&v2, 60, minput);
                    divtokens((char *)&v2, (int32_t *)&v3);
                    v5 = calcula((int32_t *)&v3, (int32_t *)&v4);
                    print((char *)&v2, (int32_t *)&v4, v5, (int32_t *)&v3);
                    libmin_printf("\nDo you want to do another operation?\nenter 1 for yes\n");
                    libmin_mgets((char *)&v6, 60, minput);
                }
                // 0x125b
                libmin_success();
                // UNREACHABLE
            }
            case 104: {
                // 0x1188
                help();
                // UNREACHABLE
            }
            case 118: {
                // 0x11a0
                verb++;
                goto lab_0x111e;
            }
            case 86: {
                // 0x1190
                copyr();
                // UNREACHABLE
            }
            default: {
                goto lab_0x113f;
            }
        }
    }
  lab_0x113f:
    // 0x113f
    libmin_printf("Type\n\t$man %s\nor\n\t$%s -h\nfor help.\n\n", argv, argv);
    if (v1 == __readfsqword(40)) {
        // 0x116f
        return 1;
    }
    // 0x127a
    __stack_chk_fail();
    return &g17;
}

// Address range: 0x1280 - 0x12a6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1280
    int64_t v1; // 0x1280
    __libc_start_main(0x10e0, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x12b0 - 0x12d9
int64_t deregister_tm_clones(void) {
    // 0x12b0
    return (int64_t)&g9;
}

// Address range: 0x12e0 - 0x1319
int64_t register_tm_clones(void) {
    // 0x12e0
    return 0;
}

// Address range: 0x1320 - 0x1359
int64_t __do_global_dtors_aux(void) {
    // 0x1320
    if (g10 != 0) {
        // 0x1358
        int64_t result; // 0x1320
        return result;
    }
    // 0x132d
    if (*(int64_t *)0x6ff8 != 0) {
        // 0x133b
        __cxa_finalize((int64_t *)*(int64_t *)0x7008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1347
    g10 = 1;
    return result2;
}

// Address range: 0x1360 - 0x1369
int64_t frame_dummy(void) {
    // 0x1360
    return register_tm_clones();
}

// From module:   /home/jad/asm-to-asm/bringup-bench/frac-calc/frac-calc.c
// Address range: 0x1370 - 0x1420
// Line range:    235 - 248
void help(void) {
    // 0x1370
    libmin_printf("%s - %s\n", "frac", "Fraction Calculator");
    libmin_printf("\nUsage: %s [-h|-v]\n", "frac");
    libmin_printf("\nOptions:\n");
    libmin_printf("\t-h,  --help\n\t\tShow this help.\n");
    libmin_printf("\t-V,  --version\n\t\tShow version and copyright information.\n");
    libmin_printf("\t-v,  --verbose\n\t\tSet verbose level (cumulative).\n");
    libmin_printf("\nExit status:\n\t0 if ok.\n\t1 some error occurred.\n");
    libmin_printf("\nTodo:\n\tLong options not implemented yet.\n");
    libmin_printf("\nAuthor:\n\tWritten by %s <%s>\n\n", "Iago Gade Gusmao Carrazzoni", "iagocarrazzoni@gmail.com");
    libmin_fail(1);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/frac-calc/frac-calc.c
// Address range: 0x1420 - 0x149c
// Line range:    262 - 268
void copyr(void) {
    // 0x1420
    libmin_printf("%s - Version %s\n", "frac", "20180915.214818");
    libmin_printf("\nCopyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author takes no responsability to any damage this software may inflige in your data.\n\n", 2018, "Iago Gade Gusmao Carrazzoni", "iagocarrazzoni@gmail.com");
    if (verb <= 3) {
        // 0x1470
        libmin_fail(1);
        // UNREACHABLE
    }
    // 0x1480
    libmin_printf("copyr(): Verbose: %d\n", (int64_t)verb);
    libmin_fail(1);
}

// Address range: 0x14a0 - 0x14d9
int64_t frac_init(int64_t a1) {
    // 0x14a0
    libmin_printf("-------------------\n");
    libmin_printf("FRACTION CALCULATOR\nPlease entry the desired operation:\n(It is necessary to add a space between the fractions, like a/b + c/d)\n-> ");
    return (int64_t)libmin_mgets((char *)a1, 60, minput);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/frac-calc/frac-calc.c
// Address range: 0x14e0 - 0x15a9
// Line range:    398 - 421
void misto(int32_t mist, int32_t * frac, int32_t i) {
    int64_t v1 = (int64_t)frac;
    int64_t v2 = v1;
    int32_t v3 = v1;
    if (i == 3) {
        // 0x1500
        *(int32_t *)(v1 + 36) = v3;
        int64_t v4 = v2;
        *(int32_t *)(v4 + 32) = *(int32_t *)(v4 + 4);
        int64_t v5 = v2;
        *(int32_t *)(v5 + 28) = *(int32_t *)(v5 + 8);
        int64_t v6 = v2;
        *(int32_t *)(v6 + 24) = *(int32_t *)(v6 + 12);
        return;
    }
    switch (mist) {
        case 1: {
            int32_t v7 = *(int32_t *)(v1 + 8); // 0x1580
            int32_t * v8 = (int32_t *)(v1 + 12); // 0x1585
            int32_t v9 = *v8; // 0x1585
            int32_t * v10 = (int32_t *)(v1 + 4); // 0x158b
            int32_t v11 = *v10 + v7 * v3; // 0x158b
            *v10 = v7;
            *(int32_t *)v2 = v11;
            *(int32_t *)(v2 + 8) = v9;
            int32_t v12 = *(int32_t *)(v2 + 16); // 0x1596
            *(int32_t *)(v1 + 36) = v11;
            *v8 = v12;
            *(int32_t *)(v1 + 32) = v7;
            *(int32_t *)(v1 + 28) = v9;
            *(int32_t *)(v1 + 24) = v12;
            return;
        }
        case 2: {
            int32_t v13 = *(int32_t *)(v1 + 16); // 0x1520
            int32_t * v14 = (int32_t *)(v1 + 12); // 0x1529
            int32_t v15 = *(int32_t *)(v1 + 8) * v13 + *v14; // 0x1529
            *v14 = v13;
            *(int32_t *)(v2 + 8) = v15;
            *(int32_t *)(v1 + 28) = v15;
            *(int32_t *)(v1 + 36) = *(int32_t *)&v2;
            *(int32_t *)(v1 + 24) = v13;
            *(int32_t *)(v1 + 32) = *(int32_t *)(v1 + 4);
            return;
        }
    }
    if (i != 5) {
        // 0x14ff
        return;
    }
    int32_t * v16 = (int32_t *)(v1 + 8); // 0x1548
    int32_t v17 = *v16; // 0x1548
    int32_t * v18 = (int32_t *)(v1 + 4); // 0x1550
    int32_t v19 = v17 * v3 + *v18; // 0x1550
    *v18 = v17;
    *(int32_t *)v2 = v19;
    int32_t v20 = *(int32_t *)(v2 + 20); // 0x1558
    int32_t * v21 = (int32_t *)(v1 + 12); // 0x155b
    *(int32_t *)(v1 + 36) = v19;
    *v21 = v20;
    int32_t v22 = *(int32_t *)(v1 + 16) + *v21 * v20; // 0x1567
    *(int32_t *)(v1 + 32) = v17;
    *v16 = v22;
    *(int32_t *)(v1 + 28) = v22;
    *(int32_t *)(v1 + 24) = v20;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/frac-calc/frac-calc.c
// Address range: 0x15b0 - 0x1800
// Line range:    348 - 358
void avaliatokens(char ** aux, int32_t * frac, int32_t i) {
    int64_t v1 = (int64_t)aux;
    int64_t * v2 = (int64_t *)(v1 + 16); // 0x15cf
    if (libmin_strcmp((char *)*v2, "+") != 0) {
        // 0x174f
        if (libmin_strcmp((char *)*v2, "-") != 0) {
            // 0x176a
            if (libmin_strcmp((char *)*v2, "*") != 0) {
                // 0x1785
                libmin_strcmp((char *)*v2, "/");
            }
        }
    }
    int64_t v3 = v1 + 8; // 0x15e4
    int64_t * v4 = (int64_t *)v3; // 0x15e4
    int32_t v5; // 0x15b0
    if (libmin_strcmp((char *)*v4, "+") != 0) {
        // 0x17aa
        if (libmin_strcmp((char *)*v4, "-") == 0) {
            goto lab_0x15fc;
        } else {
            // 0x17c5
            if (libmin_strcmp((char *)*v4, "*") == 0) {
                goto lab_0x15fc;
            } else {
                // 0x17e0
                v5 = 2;
                if (i == 4 == libmin_strcmp((char *)*v4, "/") == 0) {
                    goto lab_0x161b;
                } else {
                    goto lab_0x1607;
                }
            }
        }
    } else {
        goto lab_0x15fc;
    }
  lab_0x15fc:
    // 0x15fc
    v5 = 2;
    if (i == 4) {
        goto lab_0x161b;
    } else {
        goto lab_0x1607;
    }
  lab_0x161b:;
    int64_t v6 = (int64_t)frac;
    int32_t * v7 = (int32_t *)(v6 + 40);
    int64_t v8 = 0;
    int64_t v9 = 0;
    int64_t v10 = 0x100000000 * v8 >> 29; // 0x164a
    int64_t * v11 = (int64_t *)(v10 + v1);
    int64_t * v12 = v11; // 0x1660
    int64_t v13 = v8; // 0x1660
    if (libmin_strcmp((char *)*v11, "+") == 0) {
        // 0x1662
        *v7 = 1;
        v12 = (int64_t *)(v10 + v3);
        v13 = v8 + 1 & 0xffffffff;
    }
    int64_t v14 = v13;
    int64_t * v15 = v12; // 0x1687
    int64_t v16 = v14; // 0x1687
    int64_t v17; // 0x1692
    if (libmin_strcmp((char *)*v12, "-") == 0) {
        // 0x1689
        *v7 = 2;
        v17 = v14 + 1;
        v15 = (int64_t *)((0x100000000 * v17 >> 29) + v1);
        v16 = v17 & 0xffffffff;
    }
    int64_t v18 = v16;
    int64_t * v19 = v15; // 0x16ac
    int64_t v20 = v18; // 0x16ac
    int64_t v21; // 0x16b7
    if (libmin_strcmp((char *)*v15, "*") == 0) {
        // 0x16ae
        *v7 = 3;
        v21 = v18 + 1;
        v19 = (int64_t *)((0x100000000 * v21 >> 29) + v1);
        v20 = v21 & 0xffffffff;
    }
    int64_t v22 = v20;
    int64_t * v23 = v19; // 0x16cf
    int64_t v24 = v22; // 0x16cf
    int64_t v25; // 0x16da
    if (libmin_strcmp((char *)*v19, "/") == 0) {
        // 0x16d1
        *v7 = 4;
        v25 = v22 + 1;
        v23 = (int64_t *)((0x100000000 * v25 >> 29) + v1);
        v24 = v25 & 0xffffffff;
    }
    char * v26 = libmin_strtok((char *)*v23, "/"); // 0x16eb
    int64_t v27 = v9; // 0x16f6
    int64_t v28; // 0x15b0
    int64_t v29; // 0x15b0
    char * v30; // 0x1715
    if (v26 != NULL) {
        // 0x16f8
        v29 = 0x100000000 * v9 + 0x100000000 >> 32;
        *(int32_t *)(v6 - 4 + 4 * v29) = libmin_atoi(v26);
        v30 = libmin_strtok(NULL, "/");
        v28 = v29 + 1;
        while (v30 != NULL) {
            // 0x1700
            v29 = v28;
            *(int32_t *)(v6 - 4 + 4 * v29) = libmin_atoi(v30);
            v30 = libmin_strtok(NULL, "/");
            v28 = v29 + 1;
        }
        // 0x1722
        v27 = v29 & 0xffffffff;
    }
    int64_t v31 = v24 + 1 & 0xffffffff; // 0x1722
    while (v31 < (int64_t)i) {
        // 0x1640
        v8 = v31;
        v9 = v27;
        v10 = 0x100000000 * v8 >> 29;
        v11 = (int64_t *)(v10 + v1);
        v12 = v11;
        v13 = v8;
        if (libmin_strcmp((char *)*v11, "+") == 0) {
            // 0x1662
            *v7 = 1;
            v12 = (int64_t *)(v10 + v3);
            v13 = v8 + 1 & 0xffffffff;
        }
        // 0x1678
        v14 = v13;
        v15 = v12;
        v16 = v14;
        if (libmin_strcmp((char *)*v12, "-") == 0) {
            // 0x1689
            *v7 = 2;
            v17 = v14 + 1;
            v15 = (int64_t *)((0x100000000 * v17 >> 29) + v1);
            v16 = v17 & 0xffffffff;
        }
        // 0x169d
        v18 = v16;
        v19 = v15;
        v20 = v18;
        if (libmin_strcmp((char *)*v15, "*") == 0) {
            // 0x16ae
            *v7 = 3;
            v21 = v18 + 1;
            v19 = (int64_t *)((0x100000000 * v21 >> 29) + v1);
            v20 = v21 & 0xffffffff;
        }
        // 0x16c2
        v22 = v20;
        v23 = v19;
        v24 = v22;
        if (libmin_strcmp((char *)*v19, "/") == 0) {
            // 0x16d1
            *v7 = 4;
            v25 = v22 + 1;
            v23 = (int64_t *)((0x100000000 * v25 >> 29) + v1);
            v24 = v25 & 0xffffffff;
        }
        // 0x16e5
        v26 = libmin_strtok((char *)*v23, "/");
        v27 = v9;
        if (v26 != NULL) {
            // 0x16f8
            v29 = 0x100000000 * v9 + 0x100000000 >> 32;
            *(int32_t *)(v6 - 4 + 4 * v29) = libmin_atoi(v26);
            v30 = libmin_strtok(NULL, "/");
            v28 = v29 + 1;
            while (v30 != NULL) {
                // 0x1700
                v29 = v28;
                *(int32_t *)(v6 - 4 + 4 * v29) = libmin_atoi(v30);
                v30 = libmin_strtok(NULL, "/");
                v28 = v29 + 1;
            }
            // 0x1722
            v27 = v29 & 0xffffffff;
        }
        // 0x1722
        v31 = v24 + 1 & 0xffffffff;
    }
    // 0x1731
    misto(v5, frac, i);
  lab_0x1607:
    // 0x1607
    v5 = 1;
    if (i < 1) {
        // 0x1731
        misto(1, frac, i);
        return;
    }
    goto lab_0x161b;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/frac-calc/frac-calc.c
// Address range: 0x1800 - 0x18c0
// Line range:    323 - 345
void divtokens(char * exp, int32_t * frac) {
    int64_t v1 = __readfsqword(40); // 0x181e
    int64_t v2; // bp-120, 0x1800
    libmin_strcpy((char *)&v2, exp);
    char * v3 = libmin_strtok((char *)&v2, " "); // 0x1847
    int32_t v4 = 0; // 0x184f
    int64_t v5; // bp-600, 0x1800
    if (v3 != NULL) {
        int64_t v6 = (int64_t)&v5 - 8; // 0x1865
        int64_t v7 = 1;
        *(int64_t *)(v6 + 8 * v7) = (int64_t)v3;
        char * v8 = libmin_strtok(NULL, " "); // 0x186a
        int64_t v9 = v7 + 1; // 0x1878
        while (v8 != NULL) {
            // 0x1860
            v7 = v9;
            *(int64_t *)(v6 + 8 * v7) = (int64_t)v8;
            v8 = libmin_strtok(NULL, " ");
            v9 = v7 + 1;
        }
        // 0x187a
        v4 = v7;
    }
    // 0x187a
    *(int32_t *)((int64_t)frac + 36) = v4;
    avaliatokens((char **)&v5, frac, v4);
    if (v1 == __readfsqword(40)) {
        // 0x189d
        return;
    }
    // 0x18b7
    __stack_chk_fail();
}

// From module:   /home/jad/asm-to-asm/bringup-bench/frac-calc/frac-calc.c
// Address range: 0x18c0 - 0x1a8b
// Line range:    451 - 512
float32_t calcula(int32_t * frac, int32_t * r) {
    // 0x18c0
    int128_t v1; // 0x18c0
    int128_t v2 = v1;
    int128_t v3 = v1;
    int64_t v4 = (int64_t)r;
    int64_t v5 = (int64_t)frac;
    int32_t * v6 = (int32_t *)(v5 + 4);
    int32_t * v7 = (int32_t *)(v5 + 12);
    int32_t v8 = *v7 * *v6; // 0x18c7
    int64_t v9 = v8; // 0x18c7
    *r = v8;
    int32_t v10 = *(int32_t *)(v5 + 40); // 0x18d0
    int32_t v11 = v5;
    if (v10 == 3) {
        uint32_t v12 = *(int32_t *)(v5 + 8) * v11; // 0x1a3a
        __asm_pxor(v3, v3);
        __asm_pxor(v2, v2);
        int128_t v13 = __asm_cvtsi2ss(v8); // 0x1a46
        int128_t v14 = __asm_cvtsi2ss(v12); // 0x1a4f
        *(int32_t *)(v4 + 4) = v12;
        int128_t v15 = __asm_divss(v14, v13); // 0x1a59
        int64_t v16 = 1;
        int64_t v17 = v9;
        int64_t v18 = v12; // 0x1a60
        int64_t v19 = 0x100000000 * (int64_t)((int32_t)v18 >> 31) | v18 & 0xffffffff; // 0x1a63
        int64_t v20 = v18; // 0x1a6a
        int64_t v21 = v17; // 0x1a6a
        int64_t v22; // 0x18c0
        int64_t v23; // 0x18c0
        int64_t v24; // 0x1a6f
        if ((int32_t)(v19 % v16) == 0) {
            // 0x1a6c
            v24 = 0x100000000 * (int64_t)((int32_t)v17 >> 31) | v17 & 0xffffffff;
            v23 = (int32_t)(v24 % v16) == 0 ? v19 / v16 : v18;
            v22 = (int32_t)(v24 % v16) == 0 ? v24 / v16 : v17;
            v20 = v23 & 0xffffffff;
            v21 = v22 & 0xffffffff;
        }
        int64_t v25 = v21;
        int64_t v26 = v20; // 0x1a82
        int64_t v27 = v16 + 1; // 0x1a7a
        while ((int32_t)v27 != 13) {
            // 0x1a60
            v16 = v27 & 0xffffffff;
            v17 = v25;
            v18 = v26;
            v19 = 0x100000000 * (int64_t)((int32_t)v18 >> 31) | v18 & 0xffffffff;
            v20 = v18;
            v21 = v17;
            if ((int32_t)(v19 % v16) == 0) {
                // 0x1a6c
                v24 = 0x100000000 * (int64_t)((int32_t)v17 >> 31) | v17 & 0xffffffff;
                v23 = (int32_t)(v24 % v16) == 0 ? v19 / v16 : v18;
                v22 = (int32_t)(v24 % v16) == 0 ? v24 / v16 : v17;
                v20 = v23 & 0xffffffff;
                v21 = v22 & 0xffffffff;
            }
            // 0x1a7a
            v25 = v21;
            v26 = v20;
            v27 = v16 + 1;
        }
        // 0x1a82
        *(int32_t *)(v4 + 12) = (int32_t)v26;
        *(int32_t *)(v4 + 16) = (int32_t)v25;
        return (int32_t)v15;
    }
    if (v10 > 3) {
        if (v10 != 4) {
            // 0x19c8
            return (int32_t)__asm_pxor(v3, v3);
        }
        uint32_t v28 = *(int32_t *)(v5 + 8) * *v6; // 0x1969
        __asm_pxor(v3, v3);
        __asm_pxor(v2, v2);
        *r = v28;
        int128_t v29 = __asm_cvtsi2ss(v28); // 0x1980
        uint32_t v30 = *v7 * v11; // 0x1985
        int128_t v31 = __asm_cvtsi2ss(v30); // 0x1989
        *(int32_t *)(v4 + 4) = v30;
        int128_t v32 = __asm_divss(v31, v29); // 0x1991
        int64_t v33 = v28;
        int64_t v34 = v30;
        int64_t v35 = 1;
        int64_t v36 = 0x100000000 * (int64_t)((int32_t)v34 >> 31) | v34 & 0xffffffff; // 0x199b
        int64_t v37 = v34; // 0x19a1
        int64_t v38 = v33; // 0x19a1
        int64_t v39; // 0x18c0
        int64_t v40; // 0x18c0
        int64_t v41; // 0x19a7
        if ((int32_t)(v36 % v35) == 0) {
            // 0x19a3
            v41 = 0x100000000 * (int64_t)((int32_t)v33 >> 31) | v33 & 0xffffffff;
            v39 = (int32_t)(v41 % v35) == 0 ? v36 / v35 : v34;
            v40 = (int32_t)(v41 % v35) == 0 ? v41 / v35 : v33;
            v37 = v39 & 0xffffffff;
            v38 = v40 & 0xffffffff;
        }
        int64_t v42 = v38;
        int64_t v43 = v37;
        int64_t v44 = v35 + 1; // 0x19b2
        while ((int32_t)v44 != 13) {
            // 0x1998
            v33 = v42;
            v34 = v43;
            v35 = v44 & 0xffffffff;
            v36 = 0x100000000 * (int64_t)((int32_t)v34 >> 31) | v34 & 0xffffffff;
            v37 = v34;
            v38 = v33;
            if ((int32_t)(v36 % v35) == 0) {
                // 0x19a3
                v41 = 0x100000000 * (int64_t)((int32_t)v33 >> 31) | v33 & 0xffffffff;
                v39 = (int32_t)(v41 % v35) == 0 ? v36 / v35 : v34;
                v40 = (int32_t)(v41 % v35) == 0 ? v41 / v35 : v33;
                v37 = v39 & 0xffffffff;
                v38 = v40 & 0xffffffff;
            }
            // 0x19b2
            v42 = v38;
            v43 = v37;
            v44 = v35 + 1;
        }
        // 0x19ba
        *(int32_t *)(v4 + 12) = (int32_t)v43;
        *(int32_t *)(v4 + 16) = (int32_t)v42;
        return (int32_t)v32;
    }
    if (v10 != 1) {
        if (v10 != 2) {
            // 0x19c8
            return (int32_t)__asm_pxor(v3, v3);
        }
        // 0x18f4
        __asm_pxor(v3, v3);
        __asm_pxor(v2, v2);
        int128_t v45 = __asm_cvtsi2ss(v8); // 0x18ff
        uint32_t v46 = *v6; // 0x1903
        int64_t v47 = 0x100000000 * (int64_t)(v8 >> 31) | v9; // 0x1903
        uint32_t v48 = *v7; // 0x190e
        int32_t v49 = *(int32_t *)(v5 + 8); // 0x1911
        uint32_t v50 = (int32_t)(v47 / (int64_t)v46) * v11 - v49 * (int32_t)(v47 / (int64_t)v48); // 0x191c
        int128_t v51 = __asm_cvtsi2ss(v50); // 0x191e
        *(int32_t *)(v4 + 4) = v50;
        int128_t v52 = __asm_divss(v51, v45); // 0x1926
        int64_t v53 = 1;
        int64_t v54 = v9;
        int64_t v55 = v50; // 0x1930
        int64_t v56 = 0x100000000 * (int64_t)((int32_t)v55 >> 31) | v55 & 0xffffffff; // 0x1933
        int64_t v57 = v55; // 0x193a
        int64_t v58 = v54; // 0x193a
        int64_t v59; // 0x18c0
        int64_t v60; // 0x193f
        if ((int32_t)(v56 % v53) == 0) {
            // 0x193c
            v60 = 0x100000000 * (int64_t)((int32_t)v54 >> 31) | v54 & 0xffffffff;
            v59 = (int32_t)(v60 % v53) == 0 ? v60 / v53 : v54;
            v57 = ((int32_t)(v60 % v53) == 0 ? v56 / v53 : v55) & 0xffffffff;
            v58 = v59 & 0xffffffff;
        }
        int64_t v61 = v58;
        int64_t v62 = v57; // 0x1952
        int64_t v63 = v53 + 1; // 0x194a
        while ((int32_t)v63 != 13) {
            // 0x1930
            v53 = v63 & 0xffffffff;
            v54 = v61;
            v55 = v62;
            v56 = 0x100000000 * (int64_t)((int32_t)v55 >> 31) | v55 & 0xffffffff;
            v57 = v55;
            v58 = v54;
            if ((int32_t)(v56 % v53) == 0) {
                // 0x193c
                v60 = 0x100000000 * (int64_t)((int32_t)v54 >> 31) | v54 & 0xffffffff;
                v59 = (int32_t)(v60 % v53) == 0 ? v60 / v53 : v54;
                v57 = ((int32_t)(v60 % v53) == 0 ? v56 / v53 : v55) & 0xffffffff;
                v58 = v59 & 0xffffffff;
            }
            // 0x194a
            v61 = v58;
            v62 = v57;
            v63 = v53 + 1;
        }
        // 0x1952
        *(int32_t *)(v4 + 12) = (int32_t)v62;
        *(int32_t *)(v4 + 16) = (int32_t)v61;
        return (int32_t)v52;
    }
    // 0x19d0
    __asm_pxor(v3, v3);
    __asm_pxor(v2, v2);
    int128_t v64 = __asm_cvtsi2ss(v8); // 0x19db
    uint32_t v65 = *v6; // 0x19df
    int64_t v66 = 0x100000000 * (int64_t)(v8 >> 31) | v9; // 0x19df
    uint32_t v67 = *v7; // 0x19eb
    int32_t v68 = *(int32_t *)(v5 + 8); // 0x19ee
    uint32_t v69 = v68 * (int32_t)(v66 / (int64_t)v67) + (int32_t)(v66 / (int64_t)v65) * v11; // 0x19f2
    int128_t v70 = __asm_cvtsi2ss(v69); // 0x19f6
    *(int32_t *)(v4 + 4) = v69;
    int128_t v71 = __asm_divss(v70, v64); // 0x19fe
    int64_t v72 = 1;
    int64_t v73 = v9;
    int64_t v74 = v69; // 0x1a08
    int64_t v75 = 0x100000000 * (int64_t)((int32_t)v74 >> 31) | v74 & 0xffffffff; // 0x1a0b
    int64_t v76 = v74; // 0x1a12
    int64_t v77 = v73; // 0x1a12
    int64_t v78; // 0x18c0
    int64_t v79; // 0x18c0
    int64_t v80; // 0x1a17
    if ((int32_t)(v75 % v72) == 0) {
        // 0x1a14
        v80 = 0x100000000 * (int64_t)((int32_t)v73 >> 31) | v73 & 0xffffffff;
        v78 = (int32_t)(v80 % v72) == 0 ? v75 / v72 : v74;
        v79 = (int32_t)(v80 % v72) == 0 ? v80 / v72 : v73;
        v76 = v78 & 0xffffffff;
        v77 = v79 & 0xffffffff;
    }
    int64_t v81 = v77;
    int64_t v82 = v76; // 0x1a2a
    int64_t v83 = v72 + 1; // 0x1a22
    while ((int32_t)v83 != 13) {
        // 0x1a08
        v72 = v83 & 0xffffffff;
        v73 = v81;
        v74 = v82;
        v75 = 0x100000000 * (int64_t)((int32_t)v74 >> 31) | v74 & 0xffffffff;
        v76 = v74;
        v77 = v73;
        if ((int32_t)(v75 % v72) == 0) {
            // 0x1a14
            v80 = 0x100000000 * (int64_t)((int32_t)v73 >> 31) | v73 & 0xffffffff;
            v78 = (int32_t)(v80 % v72) == 0 ? v75 / v72 : v74;
            v79 = (int32_t)(v80 % v72) == 0 ? v80 / v72 : v73;
            v76 = v78 & 0xffffffff;
            v77 = v79 & 0xffffffff;
        }
        // 0x1a22
        v81 = v77;
        v82 = v76;
        v83 = v72 + 1;
    }
    // 0x1a2a
    *(int32_t *)(v4 + 12) = (int32_t)v82;
    *(int32_t *)(v4 + 16) = (int32_t)v81;
    return (int32_t)v71;
}

// Address range: 0x1a90 - 0x1acc
int64_t simplifica(int64_t a1) {
    int64_t v1 = a1 & 0xffffffff;
    int64_t v2 = (int64_t)*(int32_t *)(a1 + 4);
    int64_t v3 = 1;
    int64_t v4 = 0x100000000 * (int64_t)((int32_t)v2 >> 31) | v2 & 0xffffffff; // 0x1aa3
    int64_t v5 = v4 / v3; // 0x1aa3
    int64_t v6 = v5; // 0x1aaa
    int64_t v7 = v2; // 0x1aaa
    int64_t v8 = v1; // 0x1aaa
    int64_t v9; // 0x1ab0
    int64_t v10; // 0x1ab0
    if ((int32_t)(v4 % v3) == 0) {
        // 0x1aac
        v9 = 0x100000000 * (int64_t)((int32_t)v1 >> 31) | v1 & 0xffffffff;
        v10 = v9 / v3;
        v6 = v10;
        v7 = ((int32_t)(v9 % v3) == 0 ? v5 : v2) & 0xffffffff;
        v8 = ((int32_t)(v9 % v3) == 0 ? v10 : v1) & 0xffffffff;
    }
    int64_t v11 = v8;
    int64_t v12 = v7;
    int64_t v13 = v3 + 1; // 0x1abc
    while ((int32_t)v13 != 13) {
        // 0x1aa0
        v1 = v11;
        v2 = v12;
        v3 = v13 & 0xffffffff;
        v4 = 0x100000000 * (int64_t)((int32_t)v2 >> 31) | v2 & 0xffffffff;
        v5 = v4 / v3;
        v6 = v5;
        v7 = v2;
        v8 = v1;
        if ((int32_t)(v4 % v3) == 0) {
            // 0x1aac
            v9 = 0x100000000 * (int64_t)((int32_t)v1 >> 31) | v1 & 0xffffffff;
            v10 = v9 / v3;
            v6 = v10;
            v7 = ((int32_t)(v9 % v3) == 0 ? v5 : v2) & 0xffffffff;
            v8 = ((int32_t)(v9 % v3) == 0 ? v10 : v1) & 0xffffffff;
        }
        // 0x1abc
        v11 = v8;
        v12 = v7;
        v13 = v3 + 1;
    }
    // 0x1ac4
    *(int32_t *)(a1 + 12) = (int32_t)v12;
    *(int32_t *)(a1 + 16) = (int32_t)v11;
    return v6 & 0xffffffff;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/frac-calc/frac-calc.c
// Address range: 0x1ad0 - 0x1b54
// Line range:    516 - 526
void print(char * exp, int32_t * r, float32_t dec, int32_t * frac) {
    // 0x1ad0
    __asm_cvtss2sd((int128_t)(int32_t)dec);
    libmin_printf("\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\nINTERMEDIATE: %d/%d\nRESULT: %d/%d\nDECIMAL: %.3f\n");
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x1b60 - 0x1b71
// Line range:    124 - 127
void libtarg_success(void) {
    // 0x1b60
    exit(0);
    // UNREACHABLE
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x1b80 - 0x1b8f
// Line range:    162 - 165
void libtarg_fail(int32_t code) {
    // 0x1b80
    exit(code);
    // UNREACHABLE
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x1b90 - 0x1ba4
// Line range:    188 - 191
void libtarg_putc(char c) {
    // 0x1b90
    fputc((int32_t)c, g9);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x1bb0 - 0x1bb9
// Line range:    230 - 236
char * libtarg_sbrk(int64_t inc) {
    // 0x1bb0
    return (char *)sbrk(inc);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_atoi.c
// Address range: 0x1bc0 - 0x1c46
// Line range:    6 - 18
int32_t libmin_atoi(char * s) {
    int64_t v1 = (int64_t)s;
    int64_t v2 = (int64_t)g6; // 0x1bc8
    int64_t v3 = v1; // 0x1bd6
    int64_t v4 = v1; // 0x1bd6
    char v5 = v1; // 0x1bd6
    if ((*(char *)((0x100000000000000 * v1 >> 55) + v2) & 8) != 0) {
        v3++;
        char v6 = *(char *)v3; // 0x1be0
        v4 = v3;
        v5 = v6;
        while ((*(char *)(2 * (int64_t)v6 + v2) & 8) != 0) {
            // 0x1be0
            v3++;
            v6 = *(char *)v3;
            v4 = v3;
            v5 = v6;
        }
    }
    int32_t v7 = 0; // 0x1bf7
    int64_t v8; // 0x1bc0
    int32_t v9; // 0x1bc0
    if (v5 == 43) {
        goto lab_0x1c03;
    } else {
        // 0x1bf9
        v7 = 1;
        v8 = v4;
        v9 = 0;
        if (v5 != 45) {
            goto lab_0x1c07;
        } else {
            goto lab_0x1c03;
        }
    }
  lab_0x1c03:
    // 0x1c03
    v8 = v4 + 1;
    v9 = v7;
    goto lab_0x1c07;
  lab_0x1c07:;
    int64_t v10 = (int64_t)*(char *)v8; // 0x1c07
    int32_t v11; // 0x1bc0
    if ((*(char *)(2 * v10 + v2) & 4) == 0) {
        // 0x1c3b
        v11 = 0;
        return v9 == 0 ? -v11 : v11;
    }
    int64_t v12 = v8 + 1; // 0x1c26
    int64_t v13 = 48 - v10; // 0x1c2c
    int64_t v14 = (int64_t)*(char *)v12; // 0x1c2e
    int64_t v15 = v12; // 0x1c39
    int64_t v16 = v13 & 0xffffffff; // 0x1c39
    while ((*(char *)(2 * v14 + v2) & 4) != 0) {
        // 0x1c20
        v12 = v15 + 1;
        v13 = 48 - v14 + 10 * v16;
        v14 = (int64_t)*(char *)v12;
        v15 = v12;
        v16 = v13 & 0xffffffff;
    }
    // 0x1c3b
    v11 = v13;
    return v9 == 0 ? -v11 : v11;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_ctype.c
// Address range: 0x1c50 - 0x1c72
// Line range:    140 - 146
int32_t _isctype(uint32_t c, int32_t mask) {
    int32_t result = 0; // 0x1c5f
    if (c < 256) {
        uint16_t v1 = *(int16_t *)((0x100000000 * (int64_t)c >> 31) + (int64_t)g6); // 0x1c6b
        result = (int32_t)v1 & mask;
    }
    // 0x1c71
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_fail.c
// Address range: 0x1c80 - 0x1c9f
// Line range:    5 - 8
void libmin_fail(uint32_t code) {
    // 0x1c80
    libmin_printf("ERROR: failure with termination code `%d'\n", (int64_t)code);
    libtarg_fail(code);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_getopt.c
// Address range: 0x1ca0 - 0x1ec8
// Line range:    9 - 66
int32_t libmin_getopt(uint32_t argc, char ** argv, char * optstring) {
    uint32_t v1 = *(int32_t *)0x7274; // 0x1ca4
    int64_t v2; // 0x1ca0
    if (v1 == 0) {
        goto lab_0x1d00;
    } else {
        // 0x1cb3
        v2 = v1;
        if (g11 != 0) {
            goto lab_0x1d00;
        } else {
            goto lab_0x1cbd;
        }
    }
  lab_0x1d00:
    // 0x1d00
    g11 = 0;
    g12 = 0;
    g8 = 1;
    v2 = 1;
    goto lab_0x1cbd;
  lab_0x1cbd:
    // 0x1cbd
    if (v2 >= (int64_t)argc) {
        // 0x1cf9
        return 0xffffffff;
    }
    int64_t v3 = (int64_t)argv;
    int64_t v4 = *(int64_t *)((0x100000000 * v2 >> 29) + v3); // 0x1cc8
    if (v4 == 0) {
        // 0x1cf9
        return 0xffffffff;
    }
    int64_t v5 = (int64_t)optstring;
    char v6 = v5;
    if (*(char *)v4 != 45) {
        int64_t result = 0xffffffff; // 0x1cdd
        if (v6 == 45) {
            // 0x1ce3
            g15 = v4;
            g8 = (int32_t)v2 + 1;
            result = 1;
        }
        // 0x1cf9
        return result;
    }
    int64_t v7 = v4 + 1;
    char * v8 = (char *)v7;
    switch (*v8) {
        case 0: {
            // 0x1cf9
            return 0xffffffff;
        }
        case 45: {
            // 0x1e40
            if (*(char *)(v4 + 2) == 0) {
                // 0x1e4a
                g8 = (int32_t)v2 + 1;
                // 0x1cf9
                return 0xffffffff;
            }
            // break -> 0x1d3f
            break;
        }
    }
    int32_t v9 = g12; // 0x1d3f
    char * v10; // 0x1ca0
    int64_t v11; // 0x1ca0
    int64_t v12; // 0x1ca0
    int32_t v13; // 0x1ca0
    if (v9 == 0) {
        // 0x1e20
        g12 = 1;
        v10 = v8;
        v11 = v7;
        v13 = 2;
        v12 = 2;
    } else {
        int64_t v14 = v4 + (int64_t)v9; // 0x1d56
        v10 = (char *)v14;
        v11 = v14;
        v13 = &g13;
        v12 = &g13;
    }
    char v15 = *v10; // 0x1d59
    g12 = v13;
    *(int32_t *)&g14 = (int32_t)v15;
    int32_t v16 = v13; // 0x1d6f
    if (*(char *)(v12 + v4) == 0) {
        // 0x1d71
        g12 = 0;
        g8 = (int32_t)v2 + 1;
        v16 = 0;
    }
    int64_t v17 = v5; // 0x1d92
    char v18 = v6; // 0x1d92
    if ((v6 - 43 & -3) == 0) {
        int64_t v19 = v5 + 1; // 0x1d88
        v17 = v19;
        v18 = *(char *)v19;
    }
    int64_t result2 = v15; // 0x1d59
    int64_t v20 = 1; // 0x1da3
    char v21 = v18;
    int64_t v22 = v20 + 1; // 0x1dab
    char v23 = *(char *)(v20 + v17); // 0x1daf
    v20 = v22;
    while (v15 != v21) {
        // 0x1da8
        v21 = v23;
        v22 = v20 + 1;
        v23 = *(char *)(v20 + v17);
        v20 = v22;
    }
    // 0x1db9
    if (v23 != 58) {
        // 0x1cf9
        return result2;
    }
    char * v24 = (char *)(v22 + v17);
    int32_t v25; // 0x1ca0
    if (*v24 == 58) {
        // 0x1ea0
        g15 = 0;
        if (v16 == 0 == *v24 == 58) {
            // 0x1cf9
            return result2;
        }
        // 0x1ebf
        v25 = g8;
    } else {
        // 0x1dce
        v25 = g8;
        if (g8 >= argc) {
            // 0x1ddd
            if (v18 == 58) {
                // 0x1cf9
                return 58;
            }
            // 0x1ded
            if (g7 != 0) {
                // 0x1e01
                libmin_printf("%s: unrecognized option: %c\n", (char *)(int64_t)v21, (char)v11);
            }
            // 0x1cf9
            return 63;
        }
    }
    int64_t v26 = *(int64_t *)(8 * (int64_t)v25 + v3); // 0x1e67
    g12 = 0;
    g8 = v25 + 1;
    g15 = v26 + (int64_t)v16;
    // 0x1cf9
    return result2;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_mgets.c
// Address range: 0x1ed0 - 0x1fad
// Line range:    6 - 23
char * libmin_mgets(char * s, int64_t size, int32_t * mfile) {
    // 0x1ed0
    if (libmin_meof(mfile) != 0) {
        // 0x1fa0
        return NULL;
    }
    int64_t v1 = (int64_t)mfile;
    int64_t v2 = (int64_t)s;
    int32_t * v3 = (int32_t *)(v1 + 24); // 0x1ef7
    int32_t v4 = *v3; // 0x1ef7
    int64_t * v5 = (int64_t *)(v1 + 16); // 0x1efb
    int32_t v6 = v4; // 0x1f06
    int64_t v7 = v2; // 0x1f06
    if (*(char *)(*v5 + (int64_t)v4) != 10) {
        int64_t v8 = size - 1; // 0x1f08
        if (v8 == 0) {
            // 0x1f6c
            *(char *)v2 = 0;
            return s;
        }
        int64_t v9 = v8 + v2; // 0x1f12
        int64_t v10 = v2;
        int32_t v11 = libmin_meof(mfile); // 0x1f52
        int32_t v12 = *v3;
        int64_t v13 = v12;
        int64_t v14 = *v5;
        while (v11 == 0) {
            int64_t v15 = v10 + 1; // 0x1f28
            *v3 = v12 + 1;
            *(char *)v10 = *(char *)(v14 + v13);
            int32_t v16 = *v3; // 0x1f39
            v6 = v16;
            v7 = v15;
            if (*(char *)(*v5 + (int64_t)v16) == 10) {
                goto lab_0x1f88;
            }
            // 0x1f4a
            if (v15 == v9) {
                // 0x1f6c
                *(char *)v9 = 0;
                return s;
            }
            v10 = v15;
            v11 = libmin_meof(mfile);
            v12 = *v3;
            v13 = v12;
            v14 = *v5;
        }
        // 0x1f5b
        v6 = v12;
        v7 = v10;
        if (*(char *)(v14 + v13) != 10) {
            // 0x1f6c
            *(char *)v10 = 0;
            return s;
        }
    }
  lab_0x1f88:
    // 0x1f88
    *v3 = v6 + 1;
    // 0x1f6c
    *(char *)v7 = 0;
    return s;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_mgets.c
// Address range: 0x1fb0 - 0x20a2
// Line range:    29 - 63
int32_t libmin_getline(char ** line, int64_t * bufflen, int32_t * fp) {
    if (line == NULL) {
        // 0x2080
        *bufflen = 80;
        libmin_malloc(80);
        abort();
        // UNREACHABLE
    }
    int64_t v1 = (int64_t)fp;
    int64_t v2 = (int64_t)bufflen; // 0x1fd8
    int64_t v3 = 0; // 0x1fd8
    int64_t v4; // 0x1fb0
    int64_t v5; // 0x1fb0
    int64_t v6; // 0x1fec
    while (true) {
      lab_0x1fe8:
        // 0x1fe8
        v5 = v3;
        int64_t v7 = v2;
        v6 = 0x100000000 * v5 >> 32;
        char v8; // 0x1fb0
        if (v6 == v7 - 1) {
            int64_t v9 = 2 * v7; // 0x2020
            int64_t v10 = libmin_malloc(v9); // 0x2023
            libmin_strncpy((char *)v10, (char *)v9, v7);
            libmin_free(v10);
            *(int64_t *)line = v10;
            *bufflen = 4 * v7;
            char v11 = libmin_mgetc(fp);
            v8 = v11;
            v2 = v9;
            if (v11 == 10) {
                // break -> 0x2060
                break;
            }
        } else {
            char v12 = libmin_mgetc(fp);
            v8 = v12;
            v2 = v7;
            if (v12 == 10) {
                // break -> 0x2060
                break;
            }
        }
        char v13 = v8;
        if (v13 == -1) {
            // break -> 0x2060
            break;
        }
        // 0x2008
        if (v13 != 8) {
            // 0x2011
            *(char *)(v6 + v1) = v13;
            v4 = v5;
            goto lab_0x1fe4;
        } else {
            int32_t v14 = v5; // 0x200c
            if (v14 >= 0 == (v14 != 0)) {
                // 0x1fe0
                v4 = v5 + 0xfffffffe & 0xffffffff;
                goto lab_0x1fe4;
            } else {
                // 0x2011
                *(char *)(v6 + v1) = v13;
                v4 = v5;
                goto lab_0x1fe4;
            }
        }
    }
    // 0x2060
    *(char *)(v6 + v1) = 0;
    return v5 == 0 ? 0xffffffff : v5;
  lab_0x1fe4:
    // 0x1fe4
    v3 = v4 + 1 & 0xffffffff;
    goto lab_0x1fe8;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x20b0 - 0x22f8
// Line range:    426 - 483
void fmtint(char * buffer, int64_t * currlen, uint64_t maxlen, int64_t value, int32_t base, int32_t min, int32_t max, uint32_t flags) {
    int64_t v1 = flags; // 0x20bf
    int64_t v2 = value; // 0x20df
    int64_t v3 = 0; // 0x20df
    int32_t v4 = 0; // 0x20df
    if ((flags & 64) == 0) {
        if (value < 0) {
            // 0x22c0
            v2 = -value;
            v3 = 45;
            v4 = -1;
        } else {
            // 0x20ea
            v2 = value;
            v3 = 43;
            v4 = -1;
            if ((v1 & 2) == 0) {
                uint32_t v5 = 8 * flags & 32; // 0x22e3
                v2 = value;
                v3 = v5;
                v4 = v5 != 0;
            }
        }
    }
    int64_t v6 = (int64_t)currlen;
    int64_t v7 = (int64_t)buffer;
    uint32_t v8 = max > 0 ? max : 0; // 0x20d7
    uint64_t v9 = (int64_t)base; // 0x2112
    int64_t v10; // bp-89, 0x20b0
    int64_t v11 = &v10; // 0x2115
    int64_t v12 = (v1 & 32) == 0 ? (int64_t)"0123456789abcdef" : (int64_t)"0123456789ABCDEF"; // 0x212d
    uint64_t v13 = v2; // 0x2131
    int64_t v14 = 1;
    *(char *)(v14 + v11) = *(char *)(v13 % v9 + v12);
    int32_t v15 = v14;
    int32_t v16 = v15 - 19; // 0x2158
    int64_t v17 = v14 + 1; // 0x2164
    while (v13 >= v9 == (v16 == 0 || v16 < 0 != (18 - v15 & v15) < 0)) {
        // 0x2138
        v13 /= v9;
        v14 = v17;
        *(char *)(v14 + v11) = *(char *)(v13 % v9 + v12);
        v15 = v14;
        v16 = v15 - 19;
        v17 = v14 + 1;
    }
    int64_t v18 = v15 == 20 ? 19 : v14 & 0xffffffff; // 0x2176
    int32_t v19 = v18; // 0x217a
    int32_t v20 = v8 - v19; // 0x217a
    int64_t v21 = 0x100000000 * v18 >> 32; // 0x2180
    int64_t v22; // bp-48, 0x20b0
    int64_t v23 = (int64_t)&v22 - 40 + v21; // 0x2187
    *(char *)v23 = 0;
    uint32_t v24 = min - (int32_t)(v20 < 0 == (v20 & v19) < 0 ? (int64_t)v8 : v18) + v4; // 0x2193
    uint32_t v25 = v20 > 0 ? v20 : 0; // 0x2199
    int64_t v26 = v25; // 0x2199
    int64_t v27 = v24 >= 0 ? (int64_t)v24 : 0; // 0x21a5
    int64_t v28; // 0x20b0
    int64_t v29; // 0x20b0
    int64_t v30; // 0x20b0
    if ((v1 & 16) == 0) {
        if (flags % 2 != 0) {
            // 0x22a0
            v29 = v6;
            v30 = -v27 & 0xffffffff;
            v28 = v26;
        } else {
            // 0x2264
            v29 = v6;
            v30 = v27;
            v28 = v26;
            if (v24 >= 1) {
                if (v6 < maxlen) {
                    // 0x2275
                    *(char *)(v6 + v7) = 32;
                }
                int64_t v31 = v6 + 1; // 0x227c
                *currlen = v31;
                uint32_t v32 = (int32_t)v27 - 1; // 0x2283
                int64_t v33 = v32; // 0x2286
                while (v32 != 0) {
                    int64_t v34 = v31;
                    int64_t v35 = v34; // 0x2273
                    if (v34 < maxlen) {
                        // 0x2275
                        *(char *)(v34 + v7) = 32;
                        v35 = v6;
                    }
                    // 0x227c
                    v31 = v35 + 1;
                    *currlen = v31;
                    v32 = (int32_t)v33 - 1;
                    v33 = v32;
                }
                int32_t v36 = v27; // 0x2288
                v29 = v31;
                v30 = v27 - (v36 >= 0 == (v36 != 0) ? v27 : 1) & 0xffffffff;
                v28 = v26;
            }
        }
    } else {
        int32_t v37 = v27; // 0x21b6
        int32_t v38 = v25 - v37; // 0x21b6
        v29 = v6;
        v30 = 0;
        v28 = v38 < 0 == (v38 & v37) < 0 ? v26 : v27;
    }
    int64_t v39 = v29; // 0x21c2
    if (v3 != 0) {
        int64_t v40 = v29; // 0x21c7
        if (v29 < maxlen) {
            // 0x22b0
            *(char *)(v29 + v7) = (char)v3;
            v40 = v6;
        }
        // 0x21cd
        v39 = v40 + 1;
        *currlen = v39;
    }
    int64_t v41 = v39; // 0x21d7
    uint32_t v42 = v28; // 0x21d7
    if ((int32_t)v28 != 0) {
        int64_t v43 = v39; // 0x2243
        if (v39 < maxlen) {
            // 0x2245
            *(char *)(v39 + v7) = 48;
            v43 = v6;
        }
        int64_t v44 = v43 + 1; // 0x224c
        *currlen = v44;
        v41 = v44;
        while (v42 != 0) {
            // 0x2240
            v42 = (int64_t)v42;
            int64_t v45 = v44;
            v43 = v45;
            if (v45 < maxlen) {
                // 0x2245
                *(char *)(v45 + v7) = 48;
                v43 = v6;
            }
            // 0x224c
            v44 = v43 + 1;
            *currlen = v44;
            v41 = v44;
        }
    }
    int64_t v46 = v23; // 0x21e8
    v46--;
    int64_t v47 = v41; // 0x21f3
    if (v41 < maxlen) {
        // 0x21f5
        *(char *)(v41 + v7) = *(char *)v46;
        v47 = v6;
    }
    int64_t v48 = v47 + 1; // 0x2200
    *currlen = v48;
    while (v21 + v11 - (v18 + 0xffffffff & 0xffffffff) != v46) {
        int64_t v49 = v48;
        v46--;
        v47 = v49;
        if (v49 < maxlen) {
            // 0x21f5
            *(char *)(v49 + v7) = *(char *)v46;
            v47 = v6;
        }
        // 0x2200
        v48 = v47 + 1;
        *currlen = v48;
    }
    // 0x2210
    if (v30 == 0) {
        // 0x2230
        return;
    }
    uint32_t v50 = v30; // 0x2212
    int64_t v51 = v48; // 0x221b
    if (v48 < maxlen) {
        // 0x221d
        *(char *)(v48 + v7) = 32;
        v51 = v6;
    }
    int64_t v52 = v51 + 1; // 0x2224
    *currlen = v52;
    while (v50 != 0) {
        // 0x2218
        v50 = (int64_t)v50;
        int64_t v53 = v52;
        v51 = v53;
        if (v53 < maxlen) {
            // 0x221d
            *(char *)(v53 + v7) = 32;
            v51 = v6;
        }
        // 0x2224
        v52 = v51 + 1;
        *currlen = v52;
    }
}

// Address range: 0x2300 - 0x23b3
int64_t my_modf_isra_0(int64_t a1) {
    // 0x2300
    int128_t v1; // 0x2300
    int128_t v2 = __asm_movapd(v1); // 0x2301
    int128_t v3 = __asm_movsd(0x3ff0000000000000); // 0x230e
    int128_t v4 = __asm_movsd(0x3fb999999999999a); // 0x2316
    int128_t v5 = __asm_movsd(0x4024000000000000); // 0x231e
    int128_t v6 = __asm_movapd(v3); // 0x2326
    int64_t v7; // bp-8, 0x2300
    bool v8 = &v7 < (int64_t *)32; // 0x232a
    int64_t result2 = 0;
    int128_t v9 = v6;
    int128_t v10; // 0x2300
    int128_t v11 = v10;
    int128_t v12 = v2;
    int64_t v13 = __asm_cvttsd2si_3(v12); // 0x2340
    __asm_pxor(v11, v11);
    int128_t v14 = __asm_addsd(__asm_movapd(v12), v3); // 0x234d
    int128_t v15 = __asm_cvtsi2sd(v13); // 0x2351
    __asm_comisd(v14, v15);
    while (v8) {
        int64_t v16 = result2 + 1; // 0x2334
        int64_t result = v16 & 0xffffffff; // 0x2334
        uint32_t v17 = (int32_t)v16; // 0x233b
        v8 = v17 < 100;
        int128_t v18 = __asm_mulsd(v12, v4); // 0x233e
        int128_t v19 = __asm_mulsd(v9, v5); // 0x233e
        if (v17 == 100) {
            // 0x2378
            *(int64_t *)a1 = 0;
            return result;
        }
        result2 = result;
        v9 = v19;
        v11 = v15;
        v12 = v18;
        v13 = __asm_cvttsd2si_3(v12);
        __asm_pxor(v11, v11);
        v14 = __asm_addsd(__asm_movapd(v12), v3);
        v15 = __asm_cvtsi2sd(v13);
        __asm_comisd(v14, v15);
    }
    // 0x235c
    __asm_comisd(v15, __asm_subsd(__asm_movapd(v12), v3));
    if (result2 == 0) {
        // 0x236e
        *(int64_t *)a1 = __asm_movsd_1(v15);
        return result2;
    }
    int128_t v20 = __asm_mulsd(v15, v9); // 0x2385
    __asm_subsd(v1, v20);
    int64_t v21 = __asm_movsd_1(v20); // 0x2392
    int64_t v22; // bp-16, 0x2300
    int64_t result3 = my_modf_isra_0((int64_t)&v22); // 0x2398
    *(int64_t *)a1 = __asm_movsd_1(__asm_addsd_2(__asm_movsd(v21), v22));
    return result3;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x23c0 - 0x2940
// Line range:    586 - 525
void fmtfp(char * buffer, int64_t * currlen, uint64_t maxlen, float128_t fvalue, int32_t min, uint32_t max, int32_t flags) {
    char iconvert[311]; // bp-704, 0x23c0
    char v1[311]; // 0x23c0
    char v2[311]; // 0x2928
    char v3[311]; // 0x2862
    char v4[311]; // 0x24c3
    char v5[311]; // 0x283c
    // 0x23c0
    int128_t v6; // 0x23c0
    int128_t v7 = v6;
    int128_t v8 = v6;
    int128_t v9 = v6;
    int3_t v10; // 0x23c0
    int3_t v11 = v10 - 1;
    float80_t v12; // 0x23c0
    __frontend_reg_store_fpr(v11, v12);
    int32_t v13 = 6; // 0x23e5
    int64_t v14 = 6; // 0x23e5
    if (max >= 0) {
        int32_t v15 = max - 16; // 0x23f1
        v14 = v15 == 0 | v15 < 0 != (15 - max & max) < 0 ? (int64_t)max : 16;
        v13 = max;
    }
    uint64_t v16 = (int64_t)flags;
    int3_t v17 = v10 - 2; // 0x23f8
    __frontend_reg_store_fpr(v17, 0.0L);
    float80_t v18 = __frontend_reg_load_fpr(v17); // 0x23fa
    float80_t v19 = __frontend_reg_load_fpr(v11); // 0x23fa
    float80_t v20 = __frontend_reg_load_fpr(v11);
    int32_t v21; // 0x23c0
    int32_t v22; // 0x23c0
    float64_t v23; // bp-744, 0x23c0
    int128_t v24; // 0x23c0
    if (v18 > v19) {
        // 0x2870
        __frontend_reg_store_fpr(v11, -v20);
        float64_t v25 = __frontend_reg_load_fpr(v11); // 0x287a
        v23 = v25;
        v22 = 45;
        v21 = 1;
        v24 = __asm_movsd((int64_t)v25);
    } else {
        float64_t v26 = v20; // 0x2402
        v23 = v26;
        int128_t v27 = __asm_movsd((int64_t)v26); // 0x2405
        v22 = 43;
        v21 = 1;
        v24 = v27;
        if ((v16 & 2) == 0) {
            int32_t v28 = 8 * flags & 32; // 0x241d
            v22 = v28;
            v21 = v28 != 0;
            v24 = v27;
        }
    }
    // 0x242e
    __asm_movapd(v24);
    float64_t fracpart; // bp-712, 0x23c0
    int64_t v29 = &fracpart; // 0x2438
    my_modf_isra_0(v29);
    bool v30; // 0x23c0
    bool v31; // 0x23c0
    int128_t v32; // 0x23c0
    int128_t v33; // 0x23c0
    int128_t v34; // 0x23c0
    bool v35; // 0x23c0
    bool v36; // 0x23c0
    if (v13 == 0) {
        int128_t v37 = __asm_movsd((int64_t)fracpart); // 0x28d4
        int128_t v38 = __asm_subsd(v24, v37); // 0x28da
        int64_t v39 = __asm_cvttsd2si_3(v38); // 0x28df
        v23 = __asm_movsd_1(v38);
        __frontend_reg_store_fpr(v11, (float80_t)v39);
        __frontend_reg_store_fpr(v11, (float80_t)v23 - __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v17, 0.5L);
        float80_t v40 = __frontend_reg_load_fpr(v17); // 0x28fc
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v11, v40);
        float80_t v41 = __frontend_reg_load_fpr(v17); // 0x28fe
        float80_t v42 = __frontend_reg_load_fpr(v11); // 0x28fe
        bool v43 = false; // 0x28fe
        bool v44 = false; // 0x28fe
        bool v45 = false; // 0x28fe
        if (v41 <= v42) {
            v43 = true;
            v44 = false;
            v45 = false;
            if (v41 >= v42) {
                v43 = v41 != v42;
                v44 = v41 != v42;
                v45 = true;
            }
        }
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
        bool v46 = true; // 0x2902
        bool v47 = v44; // 0x2902
        bool v48 = v45; // 0x2902
        int64_t v49 = v39; // 0x2902
        if (!v43) {
            // 0x2904
            v49 = v39 + 1;
            v46 = v39 == -1;
            v47 = llvm_ctpop_i8((char)v49) % 2 == 0;
            v48 = v49 == 0;
        }
        // 0x2908
        __asm_pxor(v7, v7);
        int128_t v50 = __asm_movsd(0x3ff0000000000000); // 0x290d
        int128_t v51 = __asm_cvtsi2sd(v49); // 0x2915
        v23 = __asm_movsd_1(v51);
        __asm_comisd(v51, v50);
        __frontend_reg_store_fpr(v11, (float80_t)v23);
        int64_t v52 = __asm_movsd_1(v51); // 0x2928
        v2[0] = v52;
        iconvert = v2;
        if (v46) {
            // 0x24f0
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
            v30 = v47;
            v35 = v48;
            v32 = v37;
            v34 = v51;
            goto lab_0x24f8;
        } else {
            int128_t v53 = __asm_addsd(v37, v50); // 0x2935
            __frontend_reg_store_fpr(v17, 1.0L);
            v31 = v47;
            v36 = v48;
            v33 = v53;
            goto lab_0x282b;
        }
    } else {
        // 0x2449
        __frontend_reg_store_fpr(v11, 1.0L);
        __frontend_reg_store_fpr(v17, 10.0L);
        int64_t v54 = v14 & 0xffffffff; // 0x2451
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v17));
        uint32_t v55 = (int32_t)v54 - 1; // 0x245a
        int64_t v56 = v55; // 0x245d
        while (v55 != 0) {
            // 0x2458
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v17));
            v55 = (int32_t)v56 - 1;
            v56 = v55;
        }
        float80_t v57 = __frontend_reg_load_fpr(v17); // 0x245f
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v11, v57);
        int128_t v58 = __asm_movsd((int64_t)fracpart); // 0x2465
        v23 = __asm_movsd_1(__asm_subsd(v24, v58));
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17) * (float80_t)v23);
        int3_t v59 = v10 - 3;
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        float80_t v60 = __frontend_reg_load_fpr(v59); // 0x248c
        v23 = v60;
        __frontend_reg_store_fpr(v59, v60);
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17) - __frontend_reg_load_fpr(v59));
        __frontend_reg_store_fpr(v59, (float80_t)*(float32_t *)0x498c);
        float80_t v61 = __frontend_reg_load_fpr(v59); // 0x249e
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        __frontend_reg_store_fpr(v17, v61);
        float80_t v62 = __frontend_reg_load_fpr(v59); // 0x24a0
        float80_t v63 = __frontend_reg_load_fpr(v17); // 0x24a0
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17));
        if (v62 < v63) {
            // 0x2850
            __asm_pxor(v9, v9);
            int128_t v64 = __asm_cvtsi2sd((int64_t)v23); // 0x2854
            int64_t v65 = __asm_movsd_1(v64); // 0x285a
            v23 = v65;
            __frontend_reg_store_fpr(v17, (float80_t)(float64_t)v65);
            int64_t v66 = __asm_movsd_1(v64); // 0x2862
            v3[0] = v66;
            v1 = v3;
        } else {
            // 0x24aa
            __asm_pxor(v9, v9);
            int128_t v67 = __asm_cvtsi2sd((int64_t)v23 + 1); // 0x24b6
            int64_t v68 = __asm_movsd_1(v67); // 0x24bb
            v23 = v68;
            __frontend_reg_store_fpr(v17, (float80_t)(float64_t)v68);
            int64_t v69 = __asm_movsd_1(v67); // 0x24c3
            v4[0] = v69;
            v1 = v4;
        }
        // 0x24c9
        iconvert = v1;
        __frontend_reg_store_fpr(v59, 1.0L);
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
        uint32_t v70 = (int32_t)v54 - 1; // 0x24d2
        int64_t v71 = v70; // 0x24d5
        while (v70 != 0) {
            // 0x24d0
            __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
            v70 = (int32_t)v71 - 1;
            v71 = v70;
        }
        float80_t v72 = __frontend_reg_load_fpr(v59); // 0x24d7
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        __frontend_reg_store_fpr(v17, v72);
        float80_t v73 = __frontend_reg_load_fpr(v59); // 0x24d9
        float80_t v74 = __frontend_reg_load_fpr(v17); // 0x24d9
        bool v75 = false; // 0x24d9
        bool v76 = false; // 0x24d9
        bool v77 = false; // 0x24d9
        if (v73 <= v74) {
            v75 = true;
            v76 = false;
            v77 = false;
            if (v73 >= v74) {
                v75 = v73 != v74;
                v76 = v73 != v74;
                v77 = true;
            }
        }
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v59));
        if (!v75) {
            int128_t v78 = __asm_addsd_2(v58, 0x3ff0000000000000); // 0x2810
            __frontend_reg_store_fpr(v59, 1.0L);
            __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
            uint32_t v79 = (int32_t)v54 - 1; // 0x2822
            int64_t v80 = v79; // 0x2825
            while (v79 != 0) {
                // 0x2820
                __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
                v79 = (int32_t)v80 - 1;
                v80 = v79;
            }
            unsigned char v81 = llvm_ctpop_i8((char)v79); // 0x2822
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v59));
            float80_t v82 = __frontend_reg_load_fpr(v17); // 0x2829
            __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
            __frontend_reg_store_fpr(v11, v82);
            v31 = v81 % 2 == 0;
            v36 = true;
            v33 = v78;
            goto lab_0x282b;
        } else {
            // 0x24e3
            __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17));
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
            v30 = v76;
            v35 = v77;
            v32 = v58;
            v34 = __asm_movsd(*(int64_t *)&iconvert);
            goto lab_0x24f8;
        }
    }
  lab_0x24f8:;
    int64_t v83 = (int64_t)currlen;
    int64_t v84 = (int64_t)buffer;
    int64_t v85 = &v23; // 0x23d0
    int64_t v86; // bp-697, 0x23c0
    int64_t v87 = &v86; // 0x24fd
    int128_t v88 = __asm_pxor(v8, v8); // 0x2502
    int128_t v89 = __asm_movsd(0x3fb999999999999a); // 0x2507
    int128_t v90 = __asm_movsd(0x3fa999999999999a); // 0x2510
    int128_t v91 = __asm_movsd(0x4024000000000000); // 0x2520
    bool v92 = v30; // 0x2529
    bool v93 = v35; // 0x2529
    int64_t v94 = 1;
    int128_t v95 = __asm_movapd(__asm_mulsd(v32, v89)); // 0x254c
    my_modf_isra_0(v29);
    int128_t v96 = __asm_movsd((int64_t)fracpart); // 0x2556
    int128_t v97 = __asm_subsd(v95, v96); // 0x255c
    __asm_ucomisd(v96, v88);
    int32_t v98 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v97, v90), v91)); // 0x2570
    char v99 = *(char *)((int64_t)v98 + (int64_t)"0123456789abcdef"); // 0x2577
    *(char *)(v94 + v87) = v99;
    bool v100; // 0x23c0
    int64_t v101; // 0x23c0
    bool v102; // 0x23c0
    while (v92 || !v93) {
        int64_t v103 = v94 - 311; // 0x2534
        unsigned char v104 = llvm_ctpop_i8((char)v103); // 0x2534
        v92 = v104 % 2 == 0;
        v93 = false;
        v100 = v104 % 2 == 0;
        v102 = true;
        v101 = 310;
        if (v103 == 0) {
            goto lab_0x2593;
        }
        v94++;
        v95 = __asm_movapd(__asm_mulsd(v96, v89));
        my_modf_isra_0(v29);
        v96 = __asm_movsd((int64_t)fracpart);
        v97 = __asm_subsd(v95, v96);
        __asm_ucomisd(v96, v88);
        v98 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v97, v90), v91));
        v99 = *(char *)((int64_t)v98 + (int64_t)"0123456789abcdef");
        *(char *)(v94 + v87) = v99;
    }
    int32_t v105 = (int32_t)v94 - 311; // 0x2584
    v100 = llvm_ctpop_i8((char)v105) % 2 == 0;
    v102 = v105 == 0;
    v101 = v105 == 0 ? 310 : v94 & 0xffffffff;
  lab_0x2593:
    // 0x2593
    __asm_ucomisd(v34, v88);
    int64_t v106 = 0x100000000 * v101 >> 32; // 0x2598
    v23 = v106;
    int64_t v107 = v85 + 48; // 0x259f
    *(char *)(v106 + v107) = 0;
    int64_t v108 = v14; // 0x25a4
    int64_t v109 = 0; // 0x25a4
    if (v100 || !v102) {
        bool v110 = v100; // 0x25be
        bool v111 = v102; // 0x25be
        int64_t v112 = 1;
        int128_t v113 = __asm_mulsd(v34, v89); // 0x25d1
        __asm_movapd(v113);
        int128_t v114 = __asm_movapd(v113); // 0x25de
        my_modf_isra_0((int64_t)&iconvert);
        int128_t v115 = __asm_movsd(*(int64_t *)&iconvert); // 0x25e8
        int128_t v116 = __asm_subsd(v114, v115); // 0x25f1
        __asm_ucomisd(v115, v88);
        int32_t v117 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v116, v90), v91)); // 0x2605
        char v118 = *(char *)((int64_t)v117 + (int64_t)"0123456789abcdef"); // 0x260c
        int64_t v119; // bp-377, 0x23c0
        *(char *)(v112 + (int64_t)&v119) = v118;
        while (v110 || !v111) {
            int64_t v120 = v112 - 311; // 0x25c4
            v110 = llvm_ctpop_i8((char)v120) % 2 == 0;
            v111 = false;
            if (v120 == 0) {
                goto lab_0x28b8;
            }
            v112++;
            v113 = __asm_mulsd(v115, v89);
            __asm_movapd(v113);
            v114 = __asm_movapd(v113);
            my_modf_isra_0((int64_t)&iconvert);
            v115 = __asm_movsd(*(int64_t *)&iconvert);
            v116 = __asm_subsd(v114, v115);
            __asm_ucomisd(v115, v88);
            v117 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v116, v90), v91));
            v118 = *(char *)((int64_t)v117 + (int64_t)"0123456789abcdef");
            *(char *)(v112 + (int64_t)&v119) = v118;
        }
        if ((int32_t)v112 == 311) {
          lab_0x28b8:
            // 0x28b8
            v108 = v14 + 0xfffffeca;
            v109 = 310;
        } else {
            // 0x2625
            v108 = v14 - v112;
            v109 = v112 & 0xffffffff;
        }
    }
    int64_t v121 = (0x100000000 * v109 >> 32) + v85;
    int64_t v122 = v121 + 368; // 0x2635
    *(char *)v122 = 0;
    int32_t v123 = -1 - (int32_t)v14 + (int32_t)(float32_t)(float64_t)(int64_t)min - v21 - (int32_t)v101; // 0x264d
    int64_t v124 = v123 >= 0 ? (int64_t)v123 : 0; // 0x2652
    int64_t v125; // 0x23c0
    int64_t v126; // 0x23c0
    int64_t v127; // 0x23c0
    int64_t v128; // 0x23c0
    int64_t v129; // 0x23c0
    int64_t v130; // 0x23c0
    if (v16 % 2 == 0) {
        if ((v16 & 16) == 0) {
            // 0x27d0
            v129 = v83;
            v125 = v124;
            if (v123 >= 1) {
                if (v83 < maxlen) {
                    // 0x27e5
                    *(char *)(v83 + v84) = 32;
                }
                int64_t v131 = v83 + 1; // 0x27ec
                *currlen = v131;
                uint32_t v132 = (int32_t)v124 - 1; // 0x27f3
                int64_t v133 = v132; // 0x27f7
                while (v132 != 0) {
                    int64_t v134 = v131;
                    int64_t v135 = v134; // 0x27e3
                    if (v134 < maxlen) {
                        // 0x27e5
                        *(char *)(v134 + v84) = 32;
                        v135 = v83;
                    }
                    // 0x27ec
                    v131 = v135 + 1;
                    *currlen = v131;
                    v132 = (int32_t)v133 - 1;
                    v133 = v132;
                }
                int32_t v136 = v124; // 0x27f9
                v129 = v131;
                v125 = v124 - (v136 >= 0 == (v136 != 0) ? v124 : 1) & 0xffffffff;
            }
            goto lab_0x2663;
        } else {
            // 0x278e
            v129 = v83;
            v125 = v124;
            if (v123 < 1) {
                goto lab_0x2663;
            } else {
                // 0x2797
                v130 = v83;
                v126 = v124;
                if (v22 != 0) {
                    // 0x28a1
                    v128 = v83;
                    v127 = v124;
                    if (v83 < maxlen) {
                        // 0x28aa
                        *(char *)(v83 + v84) = (char)v22;
                        v128 = v83;
                        v127 = v124;
                    }
                    goto lab_0x27b4;
                } else {
                    goto lab_0x27a8;
                }
            }
        }
    } else {
        // 0x2660
        v129 = v83;
        v125 = -v124 & 0xffffffff;
        goto lab_0x2663;
    }
  lab_0x282b:
    // 0x282b
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) - __frontend_reg_load_fpr(v17));
    fracpart = __asm_movsd_1(v33);
    float64_t v137 = __frontend_reg_load_fpr(v11); // 0x2833
    v23 = v137;
    int128_t v138 = __asm_movsd((int64_t)v137); // 0x2836
    int64_t v139 = __asm_movsd_1(v138); // 0x283c
    v5[0] = v139;
    iconvert = v5;
    v30 = v31;
    v35 = v36;
    v32 = v33;
    v34 = v138;
    goto lab_0x24f8;
  lab_0x2663:;
    int64_t v140 = v129; // 0x2669
    int64_t v141 = v125; // 0x2669
    if (v22 != 0) {
        int64_t v142 = v129; // 0x266e
        if (v129 < maxlen) {
            // 0x2670
            *(char *)(v129 + v84) = (char)v22;
            v142 = v83;
        }
        int64_t v143 = v142 + 1; // 0x2676
        *currlen = v143;
        v140 = v143;
        v141 = v125;
    }
    goto lab_0x267d;
  lab_0x267d:;
    int64_t v144 = v107 + (int64_t)v23 - 1;
    int64_t v145; // 0x23c0
    if (v140 < maxlen) {
        // 0x2695
        *(char *)(v145 + v84) = *(char *)v144;
    }
    int64_t v146 = v140 + 1; // 0x26a0
    *currlen = v146;
    int64_t v147 = v146; // 0x26ae
    int64_t v148 = v144; // 0x26ae
    while (v87 - (v101 + 0xffffffff & 0xffffffff) + (int64_t)v23 != v144) {
        // 0x2690
        v144 = v148 - 1;
        if (v147 < maxlen) {
            // 0x2695
            *(char *)(v145 + v84) = *(char *)v144;
        }
        // 0x26a0
        v146 = v147 + 1;
        *currlen = v146;
        v147 = v146;
        v148 = v144;
    }
    if (v13 != 0) {
        int64_t v149 = v146; // 0x26b8
        if (v146 < maxlen) {
            // 0x26ba
            *(char *)(v146 + v84) = 46;
            v149 = v83;
        }
        int64_t v150 = v149 + 1; // 0x26c1
        *currlen = v150;
        int64_t v151 = v150; // 0x26ca
        if ((int32_t)v108 >= 1) {
            int64_t v152 = v151;
            int64_t v153 = v152; // 0x26d3
            if (v152 < maxlen) {
                // 0x26d5
                *(char *)(v152 + v84) = 48;
                v153 = v83;
            }
            int64_t v154 = v153 + 1; // 0x26dc
            *currlen = v154;
            uint32_t v155 = (int32_t)(v108 & 0xffffffff) - 1; // 0x26e3
            int64_t v156 = v155; // 0x26e6
            while (v155 != 0) {
                // 0x26d0
                v152 = v154;
                v153 = v152;
                if (v152 < maxlen) {
                    // 0x26d5
                    *(char *)(v152 + v84) = 48;
                    v153 = v83;
                }
                // 0x26dc
                v154 = v153 + 1;
                *currlen = v154;
                v155 = (int32_t)v156 - 1;
                v156 = v155;
            }
        }
        if (v109 != 0) {
            int64_t v157 = v122 - 1;
            if (v83 < maxlen) {
                // 0x270d
                *(char *)(v83 + v84) = *(char *)v157;
            }
            int64_t v158 = v83 + 1; // 0x2718
            *currlen = v158;
            int64_t v159 = v157; // 0x2726
            while (367 - (v109 + 0xffffffff & 0xffffffff) + v121 != v157) {
                int64_t v160 = v158;
                v157 = v159 - 1;
                int64_t v161 = v160; // 0x270b
                if (v160 < maxlen) {
                    // 0x270d
                    *(char *)(v160 + v84) = *(char *)v157;
                    v161 = v83;
                }
                // 0x2718
                v158 = v161 + 1;
                *currlen = v158;
                v159 = v157;
            }
        }
    }
    // 0x2728
    if ((int32_t)v141 == 0) {
        // 0x2749
        return;
    }
    if (v83 < maxlen) {
        // 0x2735
        *(char *)(v83 + v84) = 32;
    }
    int64_t v162 = v83 + 1; // 0x273c
    *currlen = v162;
    uint32_t v163 = (int32_t)v141 + 1; // 0x2743
    int64_t v164 = v163; // 0x2747
    while (v163 != 0) {
        int64_t v165 = v162;
        int64_t v166 = v165; // 0x2733
        if (v165 < maxlen) {
            // 0x2735
            *(char *)(v165 + v84) = 32;
            v166 = v83;
        }
        // 0x273c
        v162 = v166 + 1;
        *currlen = v162;
        v163 = (int32_t)v164 + 1;
        v164 = v163;
    }
  lab_0x27a8:;
    int64_t v167 = v126;
    int64_t v168 = v130;
    v128 = v168;
    v127 = v167;
    if (v168 < maxlen) {
        // 0x27ad
        *(char *)(v168 + v84) = 48;
        v128 = v83;
        v127 = v167;
    }
    goto lab_0x27b4;
  lab_0x27b4:;
    int64_t v169 = v128 + 1; // 0x27b4
    *currlen = v169;
    uint32_t v170 = (int32_t)v127 - 1; // 0x27bb
    int64_t v171 = v170; // 0x27bb
    v140 = v169;
    v141 = v171;
    v130 = v169;
    v126 = v171;
    if (v170 != 0) {
        goto lab_0x27a8;
    } else {
        goto lab_0x267d;
    }
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x2940 - 0x325d
// Line range:    130 - 290
int64_t dopr(char * buffer, uint64_t maxlen, char * format, int32_t * args) {
    // 0x2940
    int64_t v1; // 0x2940
    uint64_t v2 = v1;
    int64_t v3 = (int64_t)buffer;
    int64_t v4 = (int64_t)format + 1; // 0x2953
    int64_t v5 = v4; // 0x2953
    int64_t result2 = 0; // 0x2969
    int64_t v6; // 0x2940
    int64_t v7; // 0x2940
    int64_t v8; // 0x2940
    int64_t v9; // 0x2940
    char v10; // 0x2940
    int64_t v11; // 0x2940
    int64_t v12; // 0x2940
    if ((char)v2 != 0) {
        int64_t v13 = (int64_t)args;
        int64_t * v14 = (int64_t *)(v13 + 8);
        v6 = v4;
        v7 = v2 % 256;
        v12 = 0;
        while (true) {
          lab_0x29be:;
            char v15 = v7; // 0x29c5
            int64_t v16 = v6; // 0x29c8
            char v17 = v15; // 0x29c8
            int64_t v18 = v12; // 0x29c8
            int64_t v19 = v6; // 0x29c8
            int64_t v20 = v12; // 0x29c8
            if (v15 != 37) {
                while (true) {
                  lab_0x29ca:;
                    uint64_t v21 = v18;
                    int64_t v22 = v16; // 0x29cd
                    if (v21 < maxlen) {
                        // 0x29cf
                        *(char *)(v21 + v3) = v17;
                        v22 = v5;
                    }
                    char v23 = *(char *)v22; // 0x29d3
                    int64_t v24 = v22 + 1; // 0x29d6
                    v5 = v24;
                    int64_t v25 = v21 + 1; // 0x29da
                    result2 = v25;
                    v16 = v24;
                    v17 = v23;
                    v18 = v25;
                    v19 = v24;
                    v20 = v25;
                    switch (v23) {
                        case 0: {
                            goto lab_0x2970_3;
                        }
                        case 37: {
                            goto lab_0x29e9;
                        }
                        default: {
                            goto lab_0x29ca;
                        }
                    }
                }
            }
          lab_0x29e9:
            // 0x29e9
            v11 = v20;
            unsigned char v26 = *(char *)v19; // 0x29f3
            result2 = v11;
            if (v26 == 0) {
                // break -> 0x2970
                break;
            }
            int64_t v27 = v26; // 0x29f3
            int64_t result = v27; // 0x2a0b
            if (v26 < 49) {
                // 0x2983
                return result;
            }
            int64_t v28 = v19 + 1; // 0x29fe
            int64_t v29 = (int64_t)g6; // 0x2a1a
            v5 = 0;
            int64_t v30 = v27; // 0x2a2a
            int64_t v31 = v28; // 0x2a2a
            int32_t v32 = 0; // 0x2a2a
            int64_t v33 = v27; // 0x2a2a
            int64_t v34 = v28; // 0x2a2a
            if ((*(char *)(2 * v27 + v29) & 4) != 0) {
                int64_t v35 = 0xffffffd0 + (0x100000000000000 * v30 >> 56); // 0x2a36
                int64_t v36 = v35 & 0xffffffff; // 0x2a36
                v5 = v36;
                unsigned char v37 = *(char *)v31; // 0x2a3a
                result2 = v11;
                if (v37 == 0) {
                    // break (via goto) -> 0x2970
                    goto lab_0x2970_3;
                }
                int64_t v38 = v31 + 1; // 0x2a32
                int64_t v39 = v37; // 0x2a3a
                v31 = v38;
                while ((*(char *)(2 * v39 + v29) & 4) != 0) {
                    // 0x2a2c
                    v35 = 10 * v36 + 0xffffffd0 + (0x100000000000000 * v39 >> 56);
                    v36 = v35 & 0xffffffff;
                    v5 = v36;
                    v37 = *(char *)v31;
                    result2 = v11;
                    if (v37 == 0) {
                        // break (via goto) -> 0x2970
                        goto lab_0x2970_3;
                    }
                    // 0x2a46
                    v38 = v31 + 1;
                    v39 = v37;
                    v31 = v38;
                }
                // 0x2a52
                v32 = v35;
                v33 = v39;
                v34 = v38;
            }
            int64_t v40 = v34;
            int64_t v41 = v33; // 0x2a54
            int64_t v42 = v40; // 0x2a54
            if (v33 == 42) {
                uint32_t v43 = v32; // 0x2f88
                if (v43 < 48) {
                    // 0x2f8f
                    v5 = *(int64_t *)(v13 + 16) + (int64_t)v43;
                    *args = v43 + 8;
                } else {
                    int64_t v44 = *v14; // 0x2fe3
                    v5 = v44;
                    *v14 = v44 + 8;
                }
                unsigned char v45 = *(char *)v40; // 0x2f9a
                result2 = v11;
                if (v45 == 0) {
                    // break -> 0x2970
                    break;
                }
                // 0x2fac
                v41 = v45;
                v42 = v40 + 1;
            }
            int64_t v46 = v42;
            int64_t v47 = v41; // 0x2a62
            int64_t v48 = v46; // 0x2a62
            if ((char)v41 == 46) {
                char v49 = *(char *)v46; // 0x2b18
                result2 = v11;
                if (v49 == 0) {
                    // break -> 0x2970
                    break;
                }
                int64_t v50 = v46;
                unsigned char v51 = v49;
                int64_t v52 = v50 + 1;
                int64_t v53 = v51;
                while ((*(char *)(2 * v53 + v29) & 4) != 0) {
                    char v54 = *(char *)v52; // 0x2b4c
                    result2 = v11;
                    if (v54 == 0) {
                        // break (via goto) -> 0x2970
                        goto lab_0x2970_3;
                    }
                    v50 = v52;
                    v51 = v54;
                    v52 = v50 + 1;
                    v53 = v51;
                }
                // 0x2ed0
                v47 = v53;
                v48 = v52;
                if (v51 == 42) {
                    uint32_t v55 = *(int32_t *)&v5; // 0x2ed8
                    if (v55 < 48) {
                        // 0x2ee3
                        *args = v55 + 8;
                    } else {
                        // 0x2fb4
                        *v14 = *v14 + 8;
                    }
                    unsigned char v56 = *(char *)v52; // 0x2eee
                    result2 = v11;
                    if (v56 == 0) {
                        // break -> 0x2970
                        break;
                    }
                    // 0x2f01
                    v47 = v56;
                    v48 = v50 + 2;
                }
            }
            int64_t v57 = v48;
            int64_t v58 = v47;
            switch ((char)v58) {
                case 104: {
                    char v59 = *(char *)v57; // 0x2f6e
                    v10 = v59;
                    v9 = v57 + 1;
                    if (v59 == 0) {
                        // break -> 0x2970
                        break;
                    }
                    goto lab_0x2f26;
                }
                case 108: {
                    char v60 = *(char *)v57; // 0x2f09
                    int64_t v61 = v57 + 1;
                    result2 = v11;
                    v10 = v60;
                    v9 = v61;
                    switch (v60) {
                        case 108: {
                            char v62 = *(char *)v61; // 0x2fc5
                            v10 = v62;
                            v9 = v57 + 2;
                            if (v62 == 0) {
                                // break -> 0x2970
                                break;
                            }
                            goto lab_0x2f26;
                        }
                        case 0: {
                            goto lab_0x2970_3;
                        }
                        default: {
                            goto lab_0x2f26;
                        }
                    }
                }
                case 76: {
                    unsigned char v63 = *(char *)v57; // 0x2f3f
                    if (v63 == 0) {
                        // break -> 0x2970
                        break;
                    }
                    int64_t v64 = (int64_t)v63 + 0xffffffdb; // 0x2f4b
                    v8 = v57 + 1;
                    if ((char)v64 < 84) {
                        int32_t v65 = *(int32_t *)((4 * v64 & 1020) + (int64_t)&g4); // 0x2f64
                        return (int64_t)v65 + (int64_t)&g4;
                    }
                    goto lab_0x2bb3;
                }
                default: {
                    // 0x2a80
                    v8 = v57;
                    if ((char)(v58 + 0xffffffdb) < 84) {
                        // 0x2a8b
                        int64_t v66; // 0x2a80
                        int32_t v67 = *(int32_t *)((4 * v66 & 1020) + (int64_t)&g2); // 0x2a95
                        return (int64_t)v67 + (int64_t)&g2;
                    }
                    goto lab_0x2bb3;
                }
            }
        }
    }
  lab_0x2970_3:
    // 0x2970
    if (maxlen == 0) {
        // 0x2983
        return result2;
    }
    uint64_t v68 = maxlen - 1;
    if (v68 > result2) {
        // 0x297e
        *(char *)(result2 + v3) = 0;
        // 0x2983
        return result2;
    }
    // 0x2998
    *(char *)(v68 + v3) = 0;
    return result2;
  lab_0x2bb3:;
    unsigned char v69 = *(char *)v8; // 0x2bb3
    int64_t v70 = v8 + 1; // 0x2bb7
    v5 = v70;
    result2 = v11;
    v6 = v70;
    v7 = v69;
    v12 = v11;
    if (v69 == 0) {
        // break -> 0x2970
        goto lab_0x2970_3;
    }
    goto lab_0x29be;
  lab_0x2f26:;
    int64_t v71 = (int64_t)v10 + 0xffffffdb; // 0x2f26
    v8 = v9;
    if ((char)v71 < 84) {
        int32_t v72 = *(int32_t *)((4 * v71 & 1020) + (int64_t)&g3); // 0x2f34
        return (int64_t)v72 + (int64_t)&g3;
    }
    goto lab_0x2bb3;
}

// Address range: 0x325d - 0x3268
int64_t function_325d(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x325d
    int64_t v1; // 0x325d
    return v1 & 0xffffffff;
}

// Address range: 0x3268 - 0x3273
int64_t function_3268(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3268
    int64_t v1; // 0x3268
    return v1 & 0xffffffff;
}

// Address range: 0x3273 - 0x327e
int64_t function_3273(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3273
    int64_t v1; // 0x3273
    return v1 & 0xffffffff;
}

// Address range: 0x327e - 0x3285
int64_t function_327e(void) {
    // 0x327e
    int64_t v1; // 0x327e
    return v1 & 0xffffffff;
}

// Address range: 0x3285 - 0x3290
int64_t function_3285(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3285
    int64_t v1; // 0x3285
    return v1 & 0xffffffff;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x3290 - 0x339c
// Line range:    751 - 769
int32_t libmin_printf(char * fmt, ...) {
    // 0x3290
    int64_t v1; // 0x3290
    if ((char)v1 != 0) {
        // 0x32cc
        int128_t v2; // 0x3290
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
    }
    int64_t v3 = 8; // bp-1248, 0x3336
    char v4; // bp-1224, 0x3290
    dopr(&v4, (int64_t)&g1, fmt, (int32_t *)&v3);
    if (v4 == 0) {
        // 0x3390
        return 0;
    }
    int64_t v5 = &v4;
    libtarg_putc(v4);
    int64_t v6 = v5 + 1; // 0x3379
    char v7 = *(char *)v6; // 0x3379
    while (v7 != 0) {
        // 0x3370
        v5 = v6;
        libtarg_putc(v7);
        v6 = v5 + 1;
        v7 = *(char *)v6;
    }
    // 0x3386
    int64_t v8; // bp+1225, 0x3290
    return v5 + (int64_t)&v8;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x33a0 - 0x344b
// Line range:    772 - 782
int32_t libmin_snprintf(char * s, int64_t size, char * fmt, ...) {
    // 0x33a0
    int64_t v1; // 0x33a0
    if ((char)v1 != 0) {
        // 0x33c6
        int128_t v2; // 0x33a0
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
    }
    int64_t v3 = 24; // bp-224, 0x341a
    dopr(s, size, fmt, (int32_t *)&v3);
    *(char *)((int64_t)s - 1 + size) = 0;
    return libmin_strlen(s);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strcmp.c
// Address range: 0x3450 - 0x34a1
// Line range:    5 - 8
int32_t libmin_strcmp(char * l, char * r) {
    uint64_t v1 = (int64_t)r;
    uint64_t v2 = (int64_t)l;
    int64_t v3 = v2 % 256; // 0x3454
    int64_t v4 = v1 % 256; // 0x3457
    if ((char)v2 != (char)v1) {
        // 0x349e
        return (int32_t)v3 - (int32_t)v4;
    }
    int64_t v5 = 1; // 0x3461
    int64_t v6 = v4;
    int64_t result = v3;
    while (result != 0) {
        if (v6 == 0) {
            // 0x3490
            return result;
        }
        unsigned char v7 = *(char *)(v5 + v2); // 0x346c
        int64_t v8 = v7; // 0x346c
        unsigned char v9 = *(char *)(v5 + v1); // 0x3474
        int64_t v10 = v9; // 0x3474
        v5++;
        int64_t v11 = v8; // 0x347b
        int64_t v12 = v10; // 0x347b
        if (v7 != v9) {
            // 0x349e
            return (int32_t)v11 - (int32_t)v12;
        }
        v6 = v10;
        result = v8;
    }
    // 0x3481
    return -(int32_t)v6;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strcpy.c
// Address range: 0x34b0 - 0x34d0
// Line range:    5 - 10
char * libmin_strcpy(char * dest, char * src) {
    int64_t v1 = 0; // 0x34b9
    char v2 = *(char *)(v1 + (int64_t)src); // 0x34c0
    *(char *)(v1 + (int64_t)dest) = v2;
    v1++;
    while (v2 != 0) {
        // 0x34c0
        v2 = *(char *)(v1 + (int64_t)src);
        *(char *)(v1 + (int64_t)dest) = v2;
        v1++;
    }
    // 0x34cf
    return dest;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strlen.c
// Address range: 0x34d0 - 0x34fb
// Line range:    5 - 15
int64_t libmin_strlen(char * str) {
    int64_t v1 = (int64_t)str;
    if (str == NULL || (char)v1 == 0) {
        // 0x34f8
        return 0;
    }
    int64_t v2 = v1; // 0x34d7
    v2++;
    while (*(char *)v2 != 0) {
        // 0x34e8
        v2++;
    }
    // 0x34f1
    return v2 - v1;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strncpy.c
// Address range: 0x3500 - 0x3545
// Line range:    9 - 25
char * libmin_strncpy(char * dst, char * src, int64_t n) {
    if (n == 0) {
        // 0x350e
        return dst;
    }
    int64_t v1 = n; // 0x3528
    int64_t v2 = (int64_t)src; // 0x3500
    int64_t v3 = (int64_t)dst;
    char v4 = *(char *)v2; // 0x351d
    int64_t v5 = v3 + 1; // 0x3524
    v1--;
    *(char *)v3 = v4;
    while (v4 != 0) {
        // 0x3518
        v2++;
        if (v1 == 0) {
            // 0x350e
            return dst;
        }
        v3 = v5;
        v4 = *(char *)v2;
        v5 = v3 + 1;
        v1--;
        *(char *)v3 = v4;
    }
    if (v1 == 0) {
        // 0x350e
        return dst;
    }
    // 0x3538
    memset((int64_t *)v5, 0, (int32_t)v1);
    return dst;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strtok.c
// Address range: 0x3550 - 0x35f9
// Line range:    5 - 19
char * libmin_strtok(char * s, char * sep) {
    char * v1 = s; // 0x3564
    if (s == NULL) {
        // 0x35c8
        v1 = g16;
        if (v1 == NULL) {
            // 0x3599
            return NULL;
        }
    }
    char * v2 = v1;
    int64_t v3 = libmin_strspn(v2, sep) + (int64_t)v2; // 0x3571
    char * result = (char *)v3; // 0x3574
    if (*result == 0) {
        // 0x35e0
        g16 = NULL;
        return NULL;
    }
    int64_t v4 = libmin_strcspn(result, sep) + v3; // 0x3586
    char * v5 = (char *)v4; // 0x3589
    if (*v5 == 0) {
        // 0x358e
        g16 = NULL;
        // 0x3599
        return result;
    }
    // 0x35a8
    *v5 = 0;
    g16 = (char *)(v4 + 1);
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_success.c
// Address range: 0x3600 - 0x3609
// Line range:    5 - 7
void libmin_success(void) {
    // 0x3600
    libtarg_success();
}

// Address range: 0x3610 - 0x3698
int64_t libmin_free_part_0(int64_t a1) {
    char * v1 = libtarg_sbrk(0); // 0x3616
    int64_t v2 = *(int64_t *)(a1 - 24); // 0x361b
    int64_t result = v2 + a1; // 0x3622
    if (result != (int64_t)v1) {
        // 0x362b
        *(int32_t *)(a1 - 16) = 1;
        return result;
    }
    // 0x3638
    if (head == tail) {
        // 0x3680
        *(int64_t *)&tail = 0;
        *(int64_t *)&head = 0;
        // 0x3670
        return (int64_t)libtarg_sbrk(-24 - v2);
    }
    int64_t v3 = (int64_t)head;
    while (v3 != 0) {
        int64_t * v4 = (int64_t *)(v3 + 16);
        int64_t v5 = *v4; // 0x3658
        if (v5 == (int64_t)tail) {
            // 0x3661
            *v4 = 0;
            *(int64_t *)&tail = v3;
            return (int64_t)libtarg_sbrk(-24 - v2);
        }
        v3 = v5;
    }
  lab_0x3670:
    // 0x3670
    return (int64_t)libtarg_sbrk(-24 - v2);
}

// Address range: 0x36a0 - 0x3744
int64_t libmin_malloc(uint64_t a1) {
    if (a1 == 0) {
        // 0x371d
        return 0;
    }
    // 0x36ad
    if (head != NULL) {
        int64_t v1 = (int64_t)head;
        int32_t * v2 = (int32_t *)(v1 + 8);
        if (*v2 != 0) {
            // 0x36c7
            if (*(int64_t *)v1 >= a1) {
                // 0x3728
                *v2 = 0;
                return v1 + 24;
            }
        }
        int64_t v3 = *(int64_t *)(v1 + 16); // 0x36cc
        while (v3 != 0) {
            // 0x36c0
            v1 = v3;
            v2 = (int32_t *)(v1 + 8);
            if (*v2 != 0) {
                // 0x36c7
                if (*(int64_t *)v1 >= a1) {
                    // 0x3728
                    *v2 = 0;
                    return v1 + 24;
                }
            }
            // 0x36cc
            v3 = *(int64_t *)(v1 + 16);
        }
    }
    char * v4 = libtarg_sbrk(a1 + 24); // 0x36d9
    if (v4 == (char *)-1) {
        // 0x371d
        return 0;
    }
    int64_t v5 = (int64_t)v4; // 0x36d9
    *(int64_t *)v4 = a1;
    *(int32_t *)(v5 + 8) = 0;
    *(int64_t *)(v5 + 16) = 0;
    if (head == NULL) {
        // 0x373b
        *(int64_t *)&head = v5;
    }
    // 0x3700
    if (tail != NULL) {
        // 0x370c
        *(int64_t *)((int64_t)tail + 16) = v5;
    }
    // 0x3710
    *(int64_t *)&tail = v5;
    return v5 + 24;
}

// Address range: 0x3750 - 0x3761
int64_t libmin_free(int64_t a1) {
    // 0x3750
    if (a1 == 0) {
        // 0x3760
        int64_t result; // 0x3750
        return result;
    }
    // 0x3759
    return libmin_free_part_0(a1);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_malloc.c
// Address range: 0x3770 - 0x37cf
// Line range:    102 - 117
char * libmin_calloc(uint64_t num, uint64_t nsize) {
    // 0x3770
    if (num == 0 || nsize == 0) {
        // 0x37ae
        return NULL;
    }
    uint128_t v1 = (int128_t)nsize * (int128_t)num; // 0x3789
    if (v1 > 0xffffffffffffffff) {
        // 0x37ae
        return NULL;
    }
    int64_t v2 = v1; // 0x3789
    int64_t v3 = libmin_malloc(v2); // 0x3794
    char * result = (char *)v3;
    if (v3 != 0) {
        // 0x37a1
        libmin_memset(result, 0, v2);
    }
    // 0x37ae
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_malloc.c
// Address range: 0x37d0 - 0x383c
// Line range:    120 - 123
char * libmin_realloc(char * block, uint64_t size) {
    if (block == NULL || size == 0) {
        // 0x3830
        return (char *)libmin_malloc(size);
    }
    int64_t v1 = (int64_t)block;
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x37ee
    if (*v2 >= size) {
        // 0x37f4
        return (char *)v1;
    }
    int64_t v3 = libmin_malloc(size); // 0x3800
    if (v3 == 0) {
        // 0x37f4
        return (char *)0;
    }
    char * result = (char *)v3; // 0x3817
    libmin_memcpy(result, (int32_t *)block, *v2);
    libmin_free_part_0(v1);
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_memcpy.c
// Address range: 0x3840 - 0x3863
// Line range:    5 - 11
char * libmin_memcpy(char * dest, int32_t * src, int64_t n) {
    // 0x3840
    if (n == 0) {
        // 0x3862
        return dest;
    }
    int64_t v1 = 0; // 0x384a
    char v2 = *(char *)(v1 + (int64_t)src); // 0x3850
    *(char *)(v1 + (int64_t)dest) = v2;
    v1++;
    while (v1 != n) {
        // 0x3850
        v2 = *(char *)(v1 + (int64_t)src);
        *(char *)(v1 + (int64_t)dest) = v2;
        v1++;
    }
    // 0x3862
    return dest;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_memset.c
// Address range: 0x3870 - 0x38d2
// Line range:    5 - 37
char * libmin_memset(char * dest, uint32_t c, uint64_t n) {
    if (n == 0) {
        // 0x38cc
        return dest;
    }
    int64_t v1 = (int64_t)dest;
    char v2 = c; // 0x387e
    int64_t v3 = v1 + n;
    *(char *)(v3 - 1) = v2;
    *dest = v2;
    if (n < 3) {
        // 0x38cc
        return dest;
    }
    // 0x388c
    *(char *)(v3 - 2) = v2;
    *(char *)(v1 + 1) = v2;
    *(char *)(v3 - 3) = v2;
    *(char *)(v1 + 2) = v2;
    if (n < 7) {
        // 0x38cc
        return dest;
    }
    // 0x38a4
    *(char *)(v3 - 4) = v2;
    *(char *)(v1 + 3) = v2;
    if (n >= 9) {
        uint64_t v4 = -v1 % 4; // 0x38ba
        memset((int64_t *)(v4 + v1), c % 256, (int32_t)(n - v4) & -4);
    }
    // 0x38cc
    return dest;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_meof.c
// Address range: 0x38e0 - 0x38f3
// Line range:    6 - 9
int32_t libmin_meof(int32_t * mfile) {
    int64_t v1 = (int64_t)mfile;
    uint64_t v2 = *(int64_t *)(v1 + 8); // 0x38e8
    return v2 <= (int64_t)*(int32_t *)(v1 + 24);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_mgetc.c
// Address range: 0x3900 - 0x3926
// Line range:    6 - 11
int32_t libmin_mgetc(int32_t * mfile) {
    int64_t v1 = (int64_t)mfile;
    int32_t * v2 = (int32_t *)(v1 + 24); // 0x3904
    int32_t v3 = *v2; // 0x3904
    uint64_t v4 = (int64_t)v3; // 0x3904
    if (*(int64_t *)(v1 + 8) <= v4) {
        // 0x3920
        return -1;
    }
    // 0x3911
    *v2 = v3 + 1;
    return (int32_t)*(char *)(*(int64_t *)(v1 + 16) + v4);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strcspn.c
// Address range: 0x3930 - 0x3ad7
// Line range:    28 - 37
int64_t libmin_strcspn(char * s, char * c) {
    int64_t v1 = (int64_t)c;
    int64_t v2 = (int64_t)s;
    int64_t v3 = v2;
    char v4 = v1;
    if (v4 == 0) {
        // 0x3993
        return libmin_strlen(s) + v2 - v2;
    }
    // 0x3948
    if (*(char *)(v1 + 1) != 0) {
        // 0x39c0
        int64_t v5; // bp-56, 0x3930
        int64_t v6 = &v5; // 0x3939
        libmin_memset((char *)&v5, 0, 32);
        int64_t v7 = v1; // 0x39c5
        uint64_t v8 = (int64_t)v4;
        v7++;
        char v9 = *(char *)v7; // 0x39cf
        int64_t * v10 = (int64_t *)(8 * v8 / 64 + v6); // 0x39d5
        *v10 = *v10 | 1 << v8 % 64;
        while (v9 != 0) {
            // 0x39c0
            v8 = (int64_t)v9;
            v7++;
            v9 = *(char *)v7;
            v10 = (int64_t *)(8 * v8 / 64 + v6);
            *v10 = *v10 | 1 << v8 % 64;
        }
        char v11 = *(char *)&v3;
        int64_t v12 = v2; // 0x39e6
        if (v11 == 0) {
            // 0x3993
            return 0;
        }
        char v13 = v11; // 0x39e6
        while ((1 << (int64_t)v13 % 64 & *(int64_t *)(((int64_t)v13 / 8 & 24) + v6)) == 0) {
            // 0x39f0
            v12++;
            v13 = *(char *)v12;
            if (v13 == 0) {
                // break -> 0x3990
                break;
            }
        }
        // 0x3993
        return v12 - v2;
    }
    int64_t v14 = v2; // 0x3960
    int64_t v15 = v2; // 0x3960
    if (v2 % 8 != 0) {
        char v16 = *(char *)v14; // 0x3980
        while (v16 != 0 && v16 != v4) {
            // 0x3974
            v14++;
            v15 = v14;
            if (v14 % 8 == 0) {
                goto lab_0x3a18;
            }
            v16 = *(char *)v14;
        }
        // 0x3993
        return v14 - v2;
    }
  lab_0x3a18:;
    int64_t v17 = *(int64_t *)v15; // 0x3a25
    int64_t v18 = 0x101010101010101 * (v1 % 256); // 0x3a32
    int64_t v19 = v17 ^ v18; // 0x3a39
    int64_t v20 = v15; // 0x3a5a
    int64_t v21; // 0x3930
    char v22; // 0x3930
    if (((v19 - 0x101010101010101 & (v19 ^ -0x7f7f7f7f7f7f7f80) | v17 - 0x101010101010101 & (v17 ^ -0x7f7f7f7f7f7f7f80)) & -0x7f7f7f7f7f7f7f80) != 0) {
        goto lab_0x3ab4;
    } else {
        int64_t v23 = v15 + 8; // 0x3a70
        int64_t v24 = *(int64_t *)v23; // 0x3a70
        int64_t v25 = v24 ^ v18; // 0x3a7b
        int64_t v26 = v23; // 0x3a98
        while (((v25 - 0x101010101010101 & (v25 ^ -0x7f7f7f7f7f7f7f80) | v24 - 0x101010101010101 & (v24 ^ -0x7f7f7f7f7f7f7f80)) & -0x7f7f7f7f7f7f7f80) == 0) {
            // 0x3a70
            v23 = v26 + 8;
            v24 = *(int64_t *)v23;
            v25 = v24 ^ v18;
            v26 = v23;
        }
        char v27 = *(char *)v23; // 0x3a9a
        v21 = v23;
        v22 = v27;
        if (v27 == 0) {
            // 0x3993
            return v23 - v2;
        }
        goto lab_0x3aa8;
    }
  lab_0x3ab4:;
    char v28 = *(char *)v20; // 0x3ab4
    int64_t v29 = v20; // 0x3ab9
    v21 = v20;
    v22 = v28;
    if (v28 == 0) {
        // 0x3993
        return v29 - v2;
    }
    goto lab_0x3aa8;
  lab_0x3aa8:
    // 0x3aa8
    v29 = v21;
    if (v22 == v4) {
        // 0x3993
        return v29 - v2;
    }
    // 0x3ab0
    v20 = v21 + 1;
    goto lab_0x3ab4;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strspn.c
// Address range: 0x3ae0 - 0x3b83
// Line range:    8 - 21
int64_t libmin_strspn(char * s, char * c) {
    // 0x3ae0
    int128_t v1; // 0x3ae0
    int128_t v2 = v1;
    uint64_t v3 = (int64_t)c;
    char v4 = v3;
    int128_t v5 = __asm_pxor(v2, v2); // 0x3ae7
    __asm_movaps(v5);
    __asm_movaps(v5);
    if (v4 == 0) {
        // 0x3b23
        return 0;
    }
    int64_t v6 = (int64_t)s;
    char v7 = v6;
    int64_t v8 = v3 + 1;
    char v9 = *(char *)v8; // 0x3afb
    int64_t v10; // 0x3ae0
    if (v9 == 0) {
        // 0x3b0e
        if (v4 != v7) {
            // 0x3b23
            return 0;
        }
        int64_t v11 = v6; // 0x3b10
        v11++;
        v10 = v11;
        while (*(char *)v11 == v4) {
            // 0x3b18
            v11++;
            v10 = v11;
        }
      lab_0x3b20:
        // 0x3b23
        return v10 - v6;
    }
    // 0x3b28
    int64_t v12; // 0x3ae0
    int64_t v13 = v12 - 40; // 0x3b42
    int64_t * v14 = (int64_t *)(v13 + (v3 / 8 & 24)); // 0x3b42
    *v14 = *v14 | 1 << v3 % 64;
    int64_t v15 = v8;
    v15++;
    char v16 = *(char *)v15; // 0x3b2b
    uint64_t v17 = (int64_t)v9;
    int64_t * v18 = (int64_t *)((v17 / 8 & 24) + v13); // 0x3b42
    *v18 = 1 << v17 % 64 | *v18;
    while (v16 != 0) {
        unsigned char v19 = v16;
        v15++;
        v16 = *(char *)v15;
        v17 = (int64_t)v19;
        v18 = (int64_t *)((v17 / 8 & 24) + v13);
        *v18 = 1 << v17 % 64 | *v18;
    }
    char v20 = v7; // 0x3b51
    if (v7 == 0) {
        // 0x3b23
        return 0;
    }
    int64_t v21 = v6;
    while ((1 << (int64_t)v20 % 64 & *(int64_t *)(((int64_t)v20 / 8 & 24) + v13)) != 0) {
        int64_t v22 = v21 + 1; // 0x3b58
        v20 = *(char *)v22;
        v10 = v22;
        if (v20 == 0) {
            return v10 - v6;
        }
        v21 = v22;
    }
    // 0x3b23
    return v21 - v6;
}

// Address range: 0x3b84 - 0x3b91
int64_t _fini(void) {
    // 0x3b84
    int64_t result; // 0x3b84
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 61

