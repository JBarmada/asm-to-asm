//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;
typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

float64_t __cos(float64_t x, float64_t y);
int64_t __do_global_dtors_aux(void);
int32_t __rem_pio2(float64_t x, float64_t * y);
int32_t __rem_pio2_large(float64_t * x, float64_t * y, uint32_t e0, int32_t nx, int32_t prec);
int128_t __sin(int64_t a1);
int64_t _fini(void);
int64_t _init(void);
int32_t _isctype(uint32_t c, int32_t mask);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
float64_t bin_fact(int32_t n, int32_t k);
int64_t binary(int64_t a1);
int64_t deregister_tm_clones(void);
int64_t dopr(char * buffer, uint64_t maxlen, char * format, int32_t * args);
int128_t e_series(int64_t a1);
void fmtfp(char * buffer, int64_t * currlen, uint64_t maxlen, float128_t fvalue, int32_t min, uint32_t max, int32_t flags);
void fmtint(char * buffer, int64_t * currlen, uint64_t maxlen, int64_t value, int32_t base, int32_t min, int32_t max, uint32_t flags);
int64_t frame_dummy(void);
void function_1060(int64_t * d);
int32_t function_1070(int32_t c, struct _IO_FILE * stream);
int64_t * function_1080(int64_t delta);
void function_1090(int32_t status);
int64_t function_3b4d(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3b58(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3b63(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3b6e(void);
int64_t function_3b75(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
float64_t J(int32_t n, float64_t x);
int128_t j_series(int64_t a1);
int32_t kepler(float64_t * E, float64_t M, float64_t e, float64_t my_derror, uint32_t m);
float64_t libmin_atof(char * s);
int32_t libmin_atoi(char * s);
float64_t libmin_cos(float64_t x);
float64_t libmin_fabs(float64_t x);
float32_t libmin_fabsf(float32_t x);
float64_t libmin_floor(float64_t x);
float64_t libmin_pow(float64_t x, float64_t y);
int32_t libmin_printf(char * fmt, ...);
float64_t libmin_scalbn(float64_t x, int32_t n);
float64_t libmin_sin(float64_t x);
int32_t libmin_snprintf(char * s, int64_t size, char * fmt, ...);
float64_t libmin_sqrt(float64_t x);
int32_t libmin_strcmp(char * l, char * r);
int64_t libmin_strlen(char * str);
void libmin_success(void);
void libtarg_fail(int32_t code);
void libtarg_putc(char c);
char * libtarg_sbrk(int64_t inc);
void libtarg_success(void);
int64_t my_modf_isra_0(int64_t a1);
float64_t newton(float64_t E, float64_t e, float64_t M, int32_t reset);
int64_t register_tm_clones(void);
float64_t strict_iteration(float64_t E, float64_t e, float64_t M, int32_t reset);

// --------------------- Global Variables ---------------------

float64_t PIo2[8] = {1.5707962512969971, 7.5497894158615964e-8, 5.3903025299577648e-15, 3.2820034158079129e-22, 1.2706557530806761e-29, 1.2293330898111133e-36, 2.7337005381646456e-44, 2.1674168387780482e-51}; // 0x6920
int32_t argc = 5; // 0x9018
char * argv[5] = {
    "U`",
    "\x12`",
    "\\`",
    "^`",
    "c`"
}; // 0x9040
float64_t derror = 9.9999999e-7; // 0x9020
int32_t g1 = 0; // 0x3c9
bool g2 = false; // 0x3fe
int32_t g3 = 0; // 0x3ff
int32_t g4 = 0; // 0x400
bool g5 = false; // 0x432
int64_t g6 = 0x300034332e300033; // 0x605c
int128_t g7; // 0x62b8
int128_t g8; // 0x62c8
int128_t g9; // 0x62e8
int128_t g10; // 0x62f8
int128_t g11; // 0x6420
int64_t g12 = -0x2ffc00002e59; // 0x64a0
int64_t g13 = -0x314c00002fa9; // 0x65f0
int64_t g14 = -0x329c000030f9; // 0x6740
int128_t g15; // 0x6b00
int32_t g16 = 0; // 0x792
int32_t g17 = 7; // 0x7c8
int64_t g18 = 0x3fe921fb54442eea; // 0x9010
char (*g20)[5] = "0.25"; // 0x9060
int64_t g21 = 0x20002000200020; // 0x9082
struct _IO_FILE * g23 = NULL; // 0x9290
char g24 = 0; // 0x9298
int32_t g25 = 0; // 0x929c
int32_t g26 = 0; // 0x929d
int32_t g27 = 0; // 0x92a0
int32_t g28 = 0; // 0x92a1
int32_t init_jk[4] = {3, 4, 4, 6}; // 0x6a70
int32_t ipio2[66] = {0xa2f983, 0x6e4e44, 0x1529fc, 0x2757d1, 0xf534dd, 0xc0db62, 0x95993c, 0x439041, 0xfe5163, 0xabdebb, 0xc561b7, 0x246e3a, 0x424dd2, 0xe00649, 0x2eea09, 0xd1921c, 0xfe1deb, 0x1cb129, 0xa73ee8, 0x8235f5, 0x2ebb44, 0x84e99c, 0x7026b4, 0x5f7e41, 0x3991d6, 0x398353, 0x39f49c, 0x845f8b, 0xbdf928, 0x3b1ff8, 0x97ffde, 0x5980f, 0xef2f11, 0x8b5a0a, 0x6d1f6d, 0x367ecf, 0x27cb09, 0xb74f46, 0x3f669e, 0x5fea2d, 0x7527ba, 0xc7ebe5, 0xf17b3d, 0x739f7, 0x8a5292, 0xea6bfb, 0x5fb11f, 0x8d5d08, 0x560330, 0x46fc7b, 0x6babf0, 0xcfbc20, 0x9af436, 0x1da9e3, 0x91615e, 0xe61b08, 0x659985, 0x5f14a0, 0x68408d, 0xffd880, 0x4d7327, 0x310606, 0x1556ca, 0x73a8c9, 0x60e27b, 0xc08c6b}; // 0x6960
int32_t g29;
char * g19[4] = {
    "-m",
    (char *)&g6,
    "0.34",
    "0.25"
}; // 0x9048
int64_t * g22 = &g21; // 0x9288

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x8fd8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g29;
    }
    // 0x1016
    return result;
}

// Address range: 0x1060 - 0x106b
void function_1060(int64_t * d) {
    // 0x1060
    __cxa_finalize(d);
}

// Address range: 0x1070 - 0x107b
int32_t function_1070(int32_t c, struct _IO_FILE * stream) {
    // 0x1070
    return fputc(c, stream);
}

// Address range: 0x1080 - 0x108b
int64_t * function_1080(int64_t delta) {
    // 0x1080
    return sbrk(delta);
}

// Address range: 0x1090 - 0x109b
void function_1090(int32_t status) {
    // 0x1090
    exit(status);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/kepler/kepler.c
// Address range: 0x10a0 - 0x149b
// Line range:    272 - 335
int main() {
    int64_t v1 = *(int64_t *)&g19; // 0x10b2
    int64_t v2 = (int64_t)&argv; // 0x10bc
    int64_t v3 = 3; // 0x10bc
    int64_t v4 = v1; // 0x10bc
    int64_t v5 = 1; // 0x10bc
    bool v6; // 0x10a0
    int64_t v7; // 0x10a0
    int128_t v8; // 0x10a0
    int128_t v9; // 0x10a0
    bool v10; // 0x10a0
    if ((char)v1 == 45) {
        while (libmin_strcmp((char *)v4, "-h") != 0) {
            int64_t v11 = v2;
            int64_t * v12 = (int64_t *)(v11 | 8); // 0x1100
            if (libmin_strcmp((char *)*v12, "-v") == 0) {
                // 0x133c
                libmin_printf("%s\n", "1.11");
                libmin_success();
                // UNREACHABLE
            }
            int64_t v13 = v3;
            int64_t v14; // 0x10a0
            if (libmin_strcmp((char *)*v12, "-a") == 0) {
                int64_t v15 = v11 + 16;
                int64_t v16 = *(int64_t *)v15; // 0x1368
                int128_t v17 = (float32_t)libmin_atof((char *)v16); // 0x136c
                int128_t v18 = __asm_movsd_1(0x3cb0000000000000); // 0x1371
                derror = __asm_movsd(v17);
                __asm_comisd(v18, v17);
                libmin_printf("Warning: requested precision may exceed implementation limit.\n");
                v2 = v15;
                v14 = v5;
            } else {
                // 0x1128
                if (libmin_strcmp((char *)*v12, "-m") != 0) {
                    int64_t v19 = *(int64_t *)((0x100000000 * v13 - 0x200000000 >> 29) + (int64_t)&argv); // 0x13d8
                    libmin_printf("kepler: Unknown option %s\n", (char *)v19);
                    goto lab_0x13e3;
                }
                int64_t v20 = v11 + 16;
                uint32_t v21 = libmin_atoi((char *)*(int64_t *)v20); // 0x1144
                int64_t v22 = v21; // 0x1149
                v2 = v20;
                v14 = v22;
                if (v21 >= 6) {
                    // 0x13a0
                    libmin_printf("Bad method number %d\n", v22);
                    return 1;
                }
            }
            int64_t v23 = v14;
            v4 = *(int64_t *)((0x100000000 * v13 >> 29) + (int64_t)&argv);
            char * v24 = (char *)v4;
            v3 = v13 + 2 & 0xffffffff;
            v5 = v23;
            if (*v24 != 45) {
                // 0x1176
                if (argc < 5) {
                    goto lab_0x13e3;
                } else {
                    int64_t v25 = __asm_movsd((int128_t)(int32_t)(float32_t)libmin_atof(v24)); // 0x118f
                    int128_t v26 = (float32_t)libmin_atof(g20); // 0x1195
                    uint32_t v27 = (int32_t)v23; // 0x119f
                    int128_t v28 = __asm_movsd_1(0x100000000 * v25 >> 32); // 0x11ac
                    int64_t v29 = __asm_movsd(v26); // 0x11b2
                    v7 = v29;
                    v6 = v27 < 4;
                    v10 = false;
                    v8 = v26;
                    v9 = v28;
                    if (v27 == 4) {
                        // 0x13ff
                        __asm_comisd(v26, g9);
                        v7 = v29;
                        v6 = v27 < 4;
                        v10 = true;
                        v8 = v26;
                        v9 = v28;
                        goto lab_0x11c2;
                    } else {
                        goto lab_0x11c2;
                    }
                }
            }
        }
        // 0x1310
        libmin_printf("%s\n", "kepler [-h -v -a <.nnnn...> -m <k>] M e\n-h: print this helpful message\n-v: print version number and exit\n-a: obtain solution to accuracy of  < .nnnn (default .0000001)\n-m: use selected calculation method k, where\n\tk = 1: Simple iteration.\n\tk = 2: Newton's method.\n\tk = 3: Binary search.\n\tk = 4: Series in powers of e. (e<.6627434193.)\n\tk = 5: Fourier Bessel series.\nM = mean anomaly (radians)\ne = orbit eccentricty.");
        libmin_success();
        // UNREACHABLE
    }
    // 0x1452
    if (argc < 3) {
      lab_0x13e3:
        // 0x13e3
        libmin_printf("%s\n", "kepler [-h -v -a <.nnnn...> -m <k>] M e");
        // 0x13b6
        return 1;
    }
    float64_t v30 = libmin_atof((char *)v1); // 0x145b
    int64_t v31 = *(int64_t *)0x9050; // 0x1460
    int64_t v32 = __asm_movsd((int128_t)(int32_t)(float32_t)v30); // 0x146e
    int128_t v33 = (float32_t)libmin_atof((char *)v31); // 0x1474
    int128_t v34 = __asm_movsd_1(0x100000000 * v32 >> 32); // 0x1479
    v7 = __asm_movsd(v33);
    v6 = false;
    v10 = false;
    v8 = v33;
    v9 = v34;
    goto lab_0x11c2;
  lab_0x11c2:;
    int128_t v35 = v8;
    int128_t v36 = __asm_movsd_1(v7); // 0x11c2
    int128_t v37 = __asm_pxor(v35, v35); // 0x11c8
    __asm_comisd(v37, v36);
    int128_t v38; // 0x1431
    if (!v6 && !v10) {
        // 0x1431
        v38 = __asm_movsd_1(v7);
        libmin_printf("Eccentricity %f out of range.\n", (float64_t)(int64_t)v38);
        // 0x13b6
        return 1;
    }
    // 0x11d6
    __asm_comisd(v36, g7);
    if (!v6) {
        // 0x1431
        v38 = __asm_movsd_1(v7);
        libmin_printf("Eccentricity %f out of range.\n", (float64_t)(int64_t)v38);
        // 0x13b6
        return 1;
    }
    // 0x1280
    __asm_comisd(v9, v37);
    int64_t v39 = g7;
    __asm_movq(v39);
    int128_t v40 = __asm_movsd_1(-0x4010000000000000); // 0x11f6
    int128_t v41 = __asm_movapd(v9); // 0x11fe
    int64_t v42 = __asm_movsd(v40); // 0x1202
    float64_t v43 = libmin_fabs((float64_t)(int64_t)v41); // 0x1208
    int128_t v44 = __asm_divsd(__asm_movapd((int128_t)(int32_t)(float32_t)v43), 0x401921fb54442eea); // 0x1211
    int128_t v45 = __asm_movapd(v44); // 0x1219
    int64_t v46 = __asm_movsd(v44); // 0x121d
    float64_t v47 = libmin_floor((float64_t)(int64_t)v45); // 0x1223
    int128_t v48 = __asm_movsd_1(0x100000000 * v46 >> 32); // 0x1228
    int128_t v49 = __asm_movsd_1(v42); // 0x122e
    int128_t v50 = __asm_subsd(v48, (int128_t)(int32_t)(float32_t)v47); // 0x1234
    int128_t v51 = __asm_addsd(__asm_movapd(v50), v50); // 0x123c
    int128_t v52 = __asm_movsd_1((int64_t)g10); // 0x1240
    int128_t v53 = __asm_mulsd(__asm_mulsd(v51, v52), v49); // 0x124c
    __asm_comisd(v53, v52);
    int64_t v54 = __asm_movsd(v53); // 0x1254
    int128_t v55 = __asm_movsd_1(0x3ff921fb54442eea); // 0x1294
    while (true) {
        // 0x12be
        __asm_movsd_1(v54);
        __asm_movsd_1(v7);
        int128_t v56 = __asm_movapd(v55); // 0x12cc
        int128_t v57 = __asm_movsd_1(__asm_movsd(v55)); // 0x12d8
        int64_t v58 = __asm_movsd(v56); // 0x12de
        int128_t v59 = __asm_subsd(v57, v56); // 0x12e4
        float64_t v60 = libmin_fabs((float64_t)(int64_t)__asm_movapd(v59)); // 0x12ec
        __asm_comisd((int128_t)(int32_t)(float32_t)v60, *(int128_t *)&derror);
        int64_t v61 = 0x100000000 * v58 >> 32; // 0x1296
        __asm_mulsd_2(__asm_movsd_1(v61), v39);
        libmin_printf("n = %d\tE = %f\n");
        v55 = __asm_movsd_1(v61);
    }
}

// Address range: 0x14a0 - 0x14c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x14a0
    int64_t v1; // 0x14a0
    __libc_start_main(0x10a0, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x14d0 - 0x14f9
int64_t deregister_tm_clones(void) {
    // 0x14d0
    return (int64_t)&g23;
}

// Address range: 0x1500 - 0x1539
int64_t register_tm_clones(void) {
    // 0x1500
    return 0;
}

// Address range: 0x1540 - 0x1579
int64_t __do_global_dtors_aux(void) {
    // 0x1540
    if (g24 != 0) {
        // 0x1578
        int64_t result; // 0x1540
        return result;
    }
    // 0x154d
    if (*(int64_t *)0x8fe8 != 0) {
        // 0x155b
        __cxa_finalize((int64_t *)*(int64_t *)0x9008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1567
    g24 = 1;
    return result2;
}

// Address range: 0x1580 - 0x1589
int64_t frame_dummy(void) {
    // 0x1580
    return register_tm_clones();
}

// From module:   /home/jad/asm-to-asm/bringup-bench/kepler/kepler.c
// Address range: 0x1590 - 0x15b8
// Line range:    124 - 130
float64_t strict_iteration(float64_t E, float64_t e, float64_t M, int32_t reset) {
    int64_t v1 = __asm_movsd((int128_t)(int32_t)(float32_t)e); // 0x1598
    int64_t v2 = __asm_movsd((int128_t)(int32_t)(float32_t)M); // 0x159d
    int128_t v3 = __asm_mulsd_2((int128_t)(int32_t)(float32_t)libmin_sin(E), v1); // 0x15a8
    return (int64_t)__asm_addsd_5(v3, v2);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/kepler/kepler.c
// Address range: 0x15c0 - 0x163d
// Line range:    138 - 143
float64_t newton(float64_t E, float64_t e, float64_t M, int32_t reset) {
    int64_t v1 = __asm_movsd((int128_t)(int32_t)(float32_t)M); // 0x15c8
    int64_t v2 = __asm_movsd((int128_t)(int32_t)(float32_t)e); // 0x15ce
    int64_t v3 = __asm_movsd((int128_t)(int32_t)(float32_t)E); // 0x15d4
    int128_t v4 = __asm_mulsd_2((int128_t)(int32_t)(float32_t)libmin_sin(E), v2); // 0x15df
    int128_t v5 = __asm_movsd_1(v1); // 0x15e5
    int128_t v6 = __asm_movsd_1(v3); // 0x15eb
    int64_t v7 = __asm_movsd(v6); // 0x15f1
    int128_t v8 = __asm_addsd(v5, v4); // 0x15f7
    int128_t v9 = __asm_movapd(v6); // 0x15fb
    int64_t v10 = __asm_movsd(__asm_subsd(v8, v6)); // 0x1603
    int128_t v11 = __asm_mulsd_2((int128_t)(int32_t)(float32_t)libmin_cos((float64_t)(int64_t)v9), v2); // 0x160e
    int128_t v12 = __asm_movsd_1((int64_t)g7); // 0x1614
    int128_t v13 = __asm_movsd_1(v10); // 0x161c
    int128_t v14 = __asm_movsd_1(v7); // 0x1622
    int128_t v15 = __asm_movapd(__asm_divsd_7(v13, __asm_subsd(v12, v11))); // 0x1634
    return (int64_t)__asm_addsd(v15, v14);
}

// Address range: 0x1640 - 0x16da
int64_t binary(int64_t a1) {
    // 0x1640
    int128_t v1; // 0x1640
    int128_t v2 = v1;
    int64_t v3 = __asm_movsd(v1); // 0x1648
    int64_t v4 = __asm_movsd(v1); // 0x164e
    if ((int32_t)a1 != 0) {
        int128_t v5 = __asm_movsd_1(0x3fe921fb54442eea); // 0x1658
        __asm_pxor(v2, v2);
        g18 = __asm_movsd(v5);
        int64_t result; // 0x1640
        return result;
    }
    int64_t v6 = __asm_movsd(v2); // 0x1678
    float64_t result2 = libmin_sin((float64_t)(int64_t)v2); // 0x167e
    int128_t v7 = __asm_movsd_1(v3); // 0x1683
    int128_t v8 = __asm_movsd_1(v6); // 0x1689
    int128_t v9 = __asm_movsd_1(v4); // 0x168f
    int128_t v10 = __asm_mulsd(v7, (int128_t)(int32_t)(float32_t)result2); // 0x1695
    int128_t v11 = __asm_subsd(__asm_movapd(v8), v10); // 0x169d
    int128_t v12 = __asm_movsd_1(g18); // 0x16a1
    __asm_comisd(v9, v11);
    __asm_movapd(__asm_subsd(v8, v12));
    g18 = __asm_movsd(__asm_mulsd_2(v12, (int64_t)g8));
    return result2;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/kepler/kepler.c
// Address range: 0x16e0 - 0x1775
// Line range:    357 - 373
float64_t bin_fact(int32_t n, int32_t k) {
    // 0x16e0
    int128_t v1; // 0x16e0
    int128_t v2 = v1;
    int128_t v3 = v1;
    __asm_pxor(v2, v2);
    int128_t v4 = __asm_movsd_1((int64_t)g8); // 0x16e8
    __asm_pxor(v3, v3);
    int128_t v5 = __asm_cvtsi2sd(n); // 0x16f4
    int32_t v6 = n - k; // 0x16f8
    int128_t v7 = __asm_cvtsi2sd(k); // 0x16fa
    int128_t v8 = __asm_subsd(__asm_mulsd(v4, v5), v7); // 0x1702
    int128_t v9 = __asm_movsd_1((int64_t)g7);
    if (v6 < 2) {
        // 0x1768
        return (int64_t)__asm_movapd(v9);
    }
    int64_t v10 = v6; // 0x16f8
    int128_t v11 = __asm_subsd(v5, v7); // 0x1713
    int128_t v12 = __asm_movapd(v9); // 0x171d
    int128_t v13; // 0x16e0
    int128_t v14 = v13;
    __asm_pxor(v14, v14);
    int128_t v15 = __asm_movapd(v8); // 0x1726
    int128_t v16 = __asm_cvtsi2sd((int32_t)v10); // 0x172c
    int128_t v17 = v15; // 0x1732
    int128_t v18 = v16; // 0x1732
    if (0 < (int64_t)k) {
        // 0x1734
        v18 = __asm_mulsd(v16, __asm_addsd(__asm_subsd(__asm_movapd(v11), v16), v9));
        v17 = __asm_mulsd(__asm_movapd(v8), v8);
    }
    int64_t v19 = v10 + 0xffffffff; // 0x1750
    v12 = __asm_mulsd(v12, __asm_divsd_7(v17, v18));
    int64_t v20 = v19 & 0xffffffff; // 0x175a
    while ((int32_t)v19 != 1) {
        // 0x1720
        v14 = v18;
        __asm_pxor(v14, v14);
        v15 = __asm_movapd(v8);
        v16 = __asm_cvtsi2sd((int32_t)v20);
        v17 = v15;
        v18 = v16;
        if ((v10 - v20 & 0xffffffff) < (int64_t)k) {
            // 0x1734
            v18 = __asm_mulsd(v16, __asm_addsd(__asm_subsd(__asm_movapd(v11), v16), v9));
            v17 = __asm_mulsd(__asm_movapd(v8), v8);
        }
        // 0x174c
        v19 = v20 + 0xffffffff;
        v12 = __asm_mulsd(v12, __asm_divsd_7(v17, v18));
        v20 = v19 & 0xffffffff;
    }
    // 0x175c
    return (int64_t)__asm_movapd(v12);
}

// Address range: 0x1780 - 0x18b6
int128_t e_series(int64_t a1) {
    // 0x1780
    int128_t v1; // 0x1780
    int128_t v2 = v1;
    int128_t v3 = v1;
    int128_t v4 = v1;
    int64_t v5 = __asm_movsd(v4); // 0x178b
    int64_t v6 = __asm_movsd(v2); // 0x1791
    if ((int32_t)a1 != 0) {
        // 0x18a0
        g27 = 0;
        return __asm_pxor(v4, v4);
    }
    int32_t v7 = g27; // 0x17a1
    if (v7 == 0) {
        // 0x1850
        g27 = 1;
        return __asm_movsd_1(v6);
    }
    int64_t v8 = __asm_movq_3(v3); // 0x17af
    __asm_pxor(v3, v3);
    int128_t v9 = __asm_pxor(v2, v2); // 0x17b8
    int128_t v10 = __asm_cvtsi2sd(v7); // 0x17bc
    int64_t v11 = __asm_movsd(v9); // 0x17c0
    int128_t v12 = __asm_movapd(v10); // 0x17c5
    int64_t v13 = v10; // 0x17c9
    int64_t v14 = v11; // 0x17c9
    if (v7 >= 0) {
        int64_t v15 = v11; // 0x1780
        int128_t v16 = v12; // 0x1780
        int64_t v17 = a1 & 0xffffffff; // 0x1780
        int32_t v18 = v7; // 0x1780
        int32_t v19; // 0x1804
        while (true) {
          lab_0x17cf:;
            int64_t v20 = v15; // 0x17d6
            int128_t v21 = v16; // 0x17d6
            int128_t v22 = __asm_movq((int64_t)g7); // 0x17d6
            int64_t v23 = v17; // 0x17d6
            int32_t v24 = v18; // 0x17d6
            while (true) {
              lab_0x17db:;
                uint64_t v25 = v23 + 1; // 0x17dd
                float64_t v26 = bin_fact(v24, (int32_t)v23); // 0x17e0
                int128_t v27 = __asm_mulsd_2(v21, v6); // 0x17e5
                int64_t v28 = __asm_movsd(__asm_mulsd((int128_t)(int32_t)(float32_t)v26, v22)); // 0x17ef
                float64_t v29 = libmin_sin((float64_t)(int64_t)__asm_movapd(v27)); // 0x17f9
                v19 = g27;
                int128_t v30 = __asm_addsd_5(__asm_mulsd_2((int128_t)(int32_t)(float32_t)v29, v28), v20); // 0x180d
                v14 = __asm_movsd(v30);
                if ((2 * v25 & 0xfffffffe) > (int64_t)v19) {
                    // break (via goto) -> 0x1870
                    goto lab_0x1870;
                }
                // 0x181b
                v23 = v25 & 0xffffffff;
                __asm_pxor(v30, v30);
                __asm_pxor(v27, v27);
                int128_t v31 = __asm_cvtsi2sd((int32_t)v25); // 0x182a
                int128_t v32 = __asm_cvtsi2sd(v19); // 0x182e
                v22 = __asm_movq(-0x4010000000000000);
                v21 = __asm_subsd(v32, __asm_addsd(v31, v31));
                v15 = v14;
                v16 = v21;
                v17 = v23;
                v18 = v19;
                v20 = v14;
                v24 = v19;
                if (v25 % 2 != 0) {
                    goto lab_0x17db;
                } else {
                    goto lab_0x17cf;
                }
            }
        }
      lab_0x1870:
        // 0x1870
        __asm_pxor(v10, v10);
        v13 = __asm_cvtsi2sd(v19);
    }
    int128_t v33 = __asm_movq(v8); // 0x187b
    g27 = &g28;
    return __asm_addsd_5(__asm_mulsd_2((int128_t)(int32_t)(float32_t)libmin_pow((float64_t)(int64_t)v33, (float64_t)v13), v14), v5);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/kepler/kepler.c
// Address range: 0x18c0 - 0x19bb
// Line range:    392 - 394
float64_t J(int32_t n, float64_t x) {
    // 0x18c0
    int128_t v1; // 0x18c0
    int128_t v2 = v1;
    int128_t v3 = (float32_t)x;
    __asm_pxor(v2, v2);
    uint32_t v4 = n < 0 ? -n : n; // 0x18cc
    int128_t v5 = __asm_cvtsi2sd(v4); // 0x18cf
    int128_t v6 = __asm_movsd_1((int64_t)g7);
    int128_t v7; // 0x18c0
    int128_t v8; // 0x18c0
    if (n == 0) {
        // 0x19a8
        v7 = __asm_movapd(v6);
    } else {
        int128_t v9 = __asm_movapd(v6); // 0x18f1
        int64_t v10 = 1; // 0x18f1
        int128_t v11; // 0x18c0
        int128_t v12 = v11;
        __asm_pxor(v12, v12);
        int128_t v13 = __asm_movapd(v3); // 0x18fc
        int128_t v14 = __asm_cvtsi2sd((int32_t)v10); // 0x1900
        int64_t v15 = v10 + 1; // 0x1904
        int128_t v16 = __asm_addsd(v14, v14); // 0x1907
        v9 = __asm_mulsd(v9, __asm_divsd_7(v13, v16));
        v10 = v15 & 0xffffffff;
        v7 = v9;
        v8 = v16;
        while (v4 + 1 != (int32_t)v15) {
            // 0x18f8
            v12 = v16;
            __asm_pxor(v12, v12);
            v13 = __asm_movapd(v3);
            v14 = __asm_cvtsi2sd((int32_t)v10);
            v15 = v10 + 1;
            v16 = __asm_addsd(v14, v14);
            v9 = __asm_mulsd(v9, __asm_divsd_7(v13, v16));
            v10 = v15 & 0xffffffff;
            v7 = v9;
            v8 = v16;
        }
    }
    int128_t v17 = __asm_mulsd(v3, v3); // 0x1917
    int128_t v18 = __asm_movsd_1(-0x4010000000000000); // 0x191b
    int128_t v19 = __asm_movsd_1(0x4010000000000000); // 0x1923
    int128_t v20 = __asm_movapd(v7); // 0x192c
    int128_t v21 = __asm_movsd_1(0x3cb0000000000000); // 0x1930
    int128_t v22 = v7; // 0x193e
    int128_t v23 = v20; // 0x193e
    int64_t v24 = 1; // 0x193e
    int128_t v25 = v8;
    __asm_pxor(v25, v25);
    int128_t v26 = __asm_movapd(v18); // 0x1944
    int32_t v27 = v24; // 0x1948
    int128_t v28 = __asm_cvtsi2sd(v27); // 0x1948
    int128_t v29 = v26; // 0x194e
    if (v24 % 2 == 0) {
        // 0x1950
        v29 = __asm_movapd(v6);
    }
    int128_t v30 = __asm_movapd(v28); // 0x1955
    int128_t v31 = __asm_addsd(v28, v5); // 0x1959
    uint32_t v32 = v27 + 1; // 0x195d
    int128_t v33 = __asm_mulsd(v31, __asm_mulsd(v30, v19)); // 0x1965
    v22 = __asm_mulsd(v22, __asm_divsd_7(__asm_movapd(v17), v33));
    int128_t v34 = __asm_mulsd(v29, v22); // 0x1975
    __asm_comisd(v22, v21);
    v23 = __asm_addsd(v23, v34);
    v24 = v32;
    while (v27 != -1 && v32 != 0) {
        // 0x1940
        v25 = v33;
        __asm_pxor(v25, v25);
        v26 = __asm_movapd(v18);
        v27 = v24;
        v28 = __asm_cvtsi2sd(v27);
        v29 = v26;
        if (v24 % 2 == 0) {
            // 0x1950
            v29 = __asm_movapd(v6);
        }
        // 0x1955
        v30 = __asm_movapd(v28);
        v31 = __asm_addsd(v28, v5);
        v32 = v27 + 1;
        v33 = __asm_mulsd(v31, __asm_mulsd(v30, v19));
        v22 = __asm_mulsd(v22, __asm_divsd_7(__asm_movapd(v17), v33));
        v34 = __asm_mulsd(v29, v22);
        __asm_comisd(v22, v21);
        v23 = __asm_addsd(v23, v34);
        v24 = v32;
    }
    int128_t v35 = __asm_movsd_1(-0x4010000000000000); // 0x198f
    if (v4 % 2 == 0) {
        // 0x1991
        v35 = __asm_movapd(v6);
    }
    int128_t v36 = v23; // 0x1998
    if (n < 0) {
        // 0x199a
        v36 = __asm_mulsd(v23, v35);
    }
    // 0x199e
    return (int64_t)__asm_movapd(v36);
}

// Address range: 0x19c0 - 0x1a79
int128_t j_series(int64_t a1) {
    // 0x19c0
    int128_t v1; // 0x19c0
    int128_t v2 = v1;
    int128_t v3 = v1;
    int64_t v4 = __asm_movsd(v3); // 0x19c8
    if ((int32_t)a1 != 0) {
        // 0x1a68
        g25 = 0;
        return __asm_pxor(v3, v3);
    }
    int32_t v5 = g25; // 0x19d5
    int128_t v6 = __asm_movapd(v1); // 0x19db
    if (v5 == 0) {
        // 0x19e4
        g25 = 1;
        return __asm_movapd(v1);
    }
    // 0x1a00
    __asm_pxor(v2, v2);
    int128_t v7 = __asm_cvtsi2sd(v5); // 0x1a05
    int128_t v8 = __asm_mulsd(v1, v7); // 0x1a0a
    int128_t v9 = __asm_mulsd(v6, v7); // 0x1a0f
    int128_t v10 = __asm_movapd(v8); // 0x1a14
    int128_t v11 = __asm_movapd((int128_t)(int32_t)(float32_t)J(v5, (float64_t)(int64_t)v10)); // 0x1a1d
    int64_t v12 = __asm_movsd(__asm_mulsd(__asm_divsd_7(__asm_movsd_1(0x4000000000000000), v7), v11)); // 0x1a32
    int128_t v13 = __asm_movapd(v9); // 0x1a38
    int128_t v14 = __asm_mulsd_2((int128_t)(int32_t)(float32_t)libmin_sin((float64_t)(int64_t)v13), v12); // 0x1a42
    int128_t v15 = __asm_movsd_1(v4); // 0x1a4e
    g25 = &g26;
    return __asm_addsd(v14, v15);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/kepler/kepler.c
// Address range: 0x1a80 - 0x1c46
// Line range:    429 - 436
int32_t kepler(float64_t * E, float64_t M, float64_t e, float64_t my_derror, uint32_t m) {
    // 0x1a80
    int128_t v1; // 0x1a80
    int128_t v2 = v1;
    int128_t v3 = v1;
    int128_t v4 = (float32_t)e;
    int64_t v5 = __asm_movsd(v4); // 0x1a8e
    int64_t v6 = __asm_movsd((int128_t)(int32_t)(float32_t)my_derror); // 0x1a94
    if (m >= 5) {
        // 0x1c3e
        return -1;
    }
    if (m == 3) {
        // 0x1c30
        __asm_comisd(v4, g9);
    }
    int128_t v7 = __asm_movsd_1(v5); // 0x1abd
    int128_t v8 = __asm_pxor(v3, v3); // 0x1ac3
    __asm_comisd(v8, v7);
    if (m >= 4) {
        // 0x1c3e
        return -1;
    }
    // 0x1ad1
    __asm_comisd(v7, g7);
    if (m >= 3) {
        // 0x1c3e
        return -1;
    }
    // 0x1b79
    __asm_comisd((int128_t)(int32_t)(float32_t)M, v8);
    __asm_movq((int64_t)g7);
    int64_t v9 = __asm_movsd(__asm_movsd_1(-0x4010000000000000)); // 0x1af9
    float64_t v10 = libmin_fabs(M); // 0x1aff
    int128_t v11 = __asm_divsd(__asm_movapd((int128_t)(int32_t)(float32_t)v10), 0x401921fb54442eea); // 0x1b08
    int128_t v12 = __asm_movapd(v11); // 0x1b10
    int64_t v13 = __asm_movsd(v11); // 0x1b14
    float64_t v14 = libmin_floor((float64_t)(int64_t)v12); // 0x1b19
    int128_t v15 = __asm_movsd_1(v13); // 0x1b1e
    int128_t v16 = __asm_pxor(v2, v2); // 0x1b23
    int128_t v17 = __asm_movsd_1(v9); // 0x1b27
    int128_t v18 = __asm_subsd(v15, (int128_t)(int32_t)(float32_t)v14); // 0x1b34
    int128_t v19 = __asm_addsd(__asm_movapd(v18), v18); // 0x1b3f
    int128_t v20 = __asm_mulsd(__asm_mulsd_2(v19, (int64_t)g10), v17); // 0x1b4b
    __asm_comisd(v20, v16);
    __asm_movq_3(__asm_movsd_1(-0x4010000000000000));
    int128_t v21 = (float32_t)libmin_fabs((float64_t)(int64_t)v20); // 0x1b62
    __asm_comisd(v21, g10);
    int128_t v22 = __asm_movapd(v21); // 0x1b84
    int128_t v23 = __asm_movsd_1(0x3ff921fb54442eea); // 0x1b84
    while (true) {
        int64_t v24 = __asm_movsd(v22); // 0x1b9a
        __asm_movsd_1(v5);
        int128_t v25 = __asm_movapd(v23); // 0x1ba6
        int128_t v26 = __asm_movsd_1(__asm_movsd(v23)); // 0x1bb1
        *E = (float64_t)__asm_movsd(v25);
        int128_t v27 = __asm_movapd(__asm_subsd(v26, v25)); // 0x1bbe
        __asm_comisd((int128_t)(int32_t)(float32_t)libmin_fabs((float64_t)(int64_t)v27), (int128_t)v6);
        v22 = __asm_movsd_1(v24);
        v23 = __asm_movsd_1(0);
    }
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x1c50 - 0x1c61
// Line range:    124 - 127
void libtarg_success(void) {
    // 0x1c50
    exit(0);
    // UNREACHABLE
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x1c70 - 0x1c7f
// Line range:    162 - 165
void libtarg_fail(int32_t code) {
    // 0x1c70
    exit(code);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x1c80 - 0x1c94
// Line range:    188 - 191
void libtarg_putc(char c) {
    // 0x1c80
    fputc((int32_t)c, g23);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x1ca0 - 0x1ca9
// Line range:    230 - 236
char * libtarg_sbrk(int64_t inc) {
    // 0x1ca0
    return (char *)sbrk(inc);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_atof.c
// Address range: 0x1cb0 - 0x1e41
// Line range:    6 - 42
float64_t libmin_atof(char * s) {
    // 0x1cb0
    int128_t v1; // 0x1cb0
    int128_t v2 = v1;
    int64_t v3; // 0x1cb0
    char v4 = v3;
    if (v4 == 0) {
        // 0x1e3a
        return (int64_t)__asm_pxor(v2, v2);
    }
    int64_t v5 = (int64_t)g22; // 0x1cc7
    int128_t v6 = __asm_movsd_1(0x4024000000000000); // 0x1cce
    int128_t v7 = __asm_pxor(v2, v2); // 0x1cda
    int64_t v8 = (int64_t)s;
    char v9 = v4;
    int128_t v10; // 0x1cb0
    int128_t v11 = v10;
    int128_t v12 = v7;
    int64_t v13 = v9;
    int64_t v14 = v8 + 1;
    int64_t result; // 0x1cb0
    while ((*(char *)(2 * v13 + v5) & 4) != 0) {
        int128_t v15 = __asm_mulsd(v12, v6); // 0x1ce0
        __asm_pxor(v11, v11);
        int128_t v16 = __asm_cvtsi2sd((int32_t)v9 - 48); // 0x1cef
        char v17 = *(char *)v14; // 0x1cf3
        v7 = __asm_addsd(v15, v16);
        if (v17 == 0) {
            // 0x1df0
            result = v7;
            return result;
        }
        v8 = v14;
        v9 = v17;
        v11 = v16;
        v12 = v7;
        v13 = v9;
        v14 = v8 + 1;
    }
    int64_t v18; // 0x1cb0
    int64_t v19; // 0x1cb0
    int64_t v20; // 0x1cb0
    int64_t v21; // 0x1cb0
    int128_t v22; // 0x1cb0
    int128_t v23; // 0x1cb0
    int128_t v24; // 0x1cb0
    if (v9 != 46) {
        // 0x1e28
        v22 = v12;
        v19 = 0;
        v18 = v14;
        result = v12;
        if ((v13 & 0xffffffdf) != 69) {
          lab_0x1df0_2:
            // 0x1df0
            return result;
        }
        goto lab_0x1d74;
    } else {
        char v25 = *(char *)v14; // 0x1d16
        int128_t v26 = __asm_movsd_1(0x4024000000000000); // 0x1d1e
        if (v25 == 0) {
            // 0x1e3f
            return (int64_t)v12;
        }
        int128_t v27 = v11; // 0x1d4a
        char v28 = v25; // 0x1d4e
        int64_t v29 = v8 + 2;
        int64_t v30 = 0;
        int128_t v31 = v12;
        int64_t v32 = v28;
        while ((*(char *)(2 * v32 + v5) & 4) != 0) {
            int128_t v33 = v27;
            __asm_pxor(v33, v33);
            int64_t v34 = v30 + 0xffffffff & 0xffffffff; // 0x1d43
            int128_t v35 = __asm_mulsd(v31, v26); // 0x1d46
            v27 = __asm_cvtsi2sd((int32_t)v28 - 48);
            v28 = *(char *)v29;
            int128_t v36 = __asm_addsd(v35, v27); // 0x1d56
            v24 = v36;
            v21 = v34;
            if (v28 == 0) {
                goto lab_0x1df5;
            }
            v29++;
            v30 = v34;
            v31 = v36;
            v32 = v28;
        }
        // 0x1d68
        v22 = v31;
        v19 = v30;
        v18 = v29;
        v23 = v31;
        v20 = v30;
        if ((v32 & 0xffffffdf) != 69) {
            goto lab_0x1df1;
        } else {
            goto lab_0x1d74;
        }
    }
  lab_0x1d74:;
    char v37 = *(char *)v18; // 0x1d74
    int64_t v38 = v18 + 1;
    int64_t v39; // 0x1cb0
    int64_t v40; // 0x1cb0
    char v41; // 0x1cb0
    if (v37 == 43) {
        // 0x1e10
        v39 = v18 + 2;
        v41 = *(char *)v38;
        v40 = 1;
    } else {
        // 0x1d82
        v39 = v38;
        v41 = v37;
        v40 = 1;
        if (v37 == 45) {
            // 0x1d92
            v39 = v18 + 2;
            v41 = *(char *)v38;
            v40 = -1;
        }
    }
    int64_t v42 = v41;
    int64_t v43 = v39; // 0x1daa
    v23 = v22;
    v20 = v19;
    if ((*(char *)(2 * v42 + v5) & 4) != 0) {
        int64_t v44 = 0xffffffd0 + v42; // 0x1db7
        int64_t v45 = (int64_t)*(char *)v43; // 0x1dbc
        v43++;
        int64_t v46 = v44 & 0xffffffff; // 0x1dc6
        while ((*(char *)(2 * v45 + v5) & 4) != 0) {
            // 0x1db0
            v44 = v45 + 0xffffffd0 + 10 * v46;
            v45 = (int64_t)*(char *)v43;
            v43++;
            v46 = v44 & 0xffffffff;
        }
        int64_t v47 = (0x100000000 * v44 >> 32) * v40 + v19; // 0x1dcc
        int64_t v48 = v47 & 0xffffffff; // 0x1dcc
        v23 = v22;
        v20 = v48;
        if ((int32_t)v47 >= 1) {
            int128_t v49 = __asm_movsd_1(0x4024000000000000); // 0x1dd2
            int128_t v50 = __asm_mulsd(v22, v49); // 0x1de0
            uint32_t v51 = (int32_t)v48 - 1; // 0x1de4
            int128_t v52 = v50; // 0x1de7
            int64_t v53 = v51; // 0x1de7
            while (v51 != 0) {
                // 0x1de0
                v50 = __asm_mulsd(v52, v49);
                v51 = (int32_t)v53 - 1;
                v52 = v50;
                v53 = v51;
            }
            // 0x1de9
            return (int64_t)v50;
        }
    }
    goto lab_0x1df1;
  lab_0x1df1:
    // 0x1df1
    v24 = v23;
    v21 = v20;
    if ((int32_t)v20 == 0) {
        // 0x1e40
        return (int64_t)v23;
    }
  lab_0x1df5:;
    int128_t v54 = __asm_movsd_1(0x3fb999999999999a); // 0x1df5
    int128_t v55 = __asm_mulsd(v24, v54); // 0x1e00
    uint32_t v56 = (int32_t)v21 + 1; // 0x1e04
    int128_t v57 = v55; // 0x1e07
    int64_t v58 = v56; // 0x1e07
    while (v56 != 0) {
        // 0x1e00
        v55 = __asm_mulsd(v57, v54);
        v56 = (int32_t)v58 + 1;
        v57 = v55;
        v58 = v56;
    }
    // 0x1e09
    return (int64_t)v55;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_atoi.c
// Address range: 0x1e50 - 0x1ed6
// Line range:    6 - 18
int32_t libmin_atoi(char * s) {
    int64_t v1 = (int64_t)s;
    int64_t v2 = (int64_t)g22; // 0x1e58
    int64_t v3 = v1; // 0x1e66
    int64_t v4 = v1; // 0x1e66
    char v5 = v1; // 0x1e66
    if ((*(char *)((0x100000000000000 * v1 >> 55) + v2) & 8) != 0) {
        v3++;
        char v6 = *(char *)v3; // 0x1e70
        v4 = v3;
        v5 = v6;
        while ((*(char *)(2 * (int64_t)v6 + v2) & 8) != 0) {
            // 0x1e70
            v3++;
            v6 = *(char *)v3;
            v4 = v3;
            v5 = v6;
        }
    }
    int32_t v7 = 0; // 0x1e87
    int64_t v8; // 0x1e50
    int32_t v9; // 0x1e50
    if (v5 == 43) {
        goto lab_0x1e93;
    } else {
        // 0x1e89
        v7 = 1;
        v8 = v4;
        v9 = 0;
        if (v5 != 45) {
            goto lab_0x1e97;
        } else {
            goto lab_0x1e93;
        }
    }
  lab_0x1e93:
    // 0x1e93
    v8 = v4 + 1;
    v9 = v7;
    goto lab_0x1e97;
  lab_0x1e97:;
    int64_t v10 = (int64_t)*(char *)v8; // 0x1e97
    int32_t v11; // 0x1e50
    if ((*(char *)(2 * v10 + v2) & 4) == 0) {
        // 0x1ecb
        v11 = 0;
        return v9 == 0 ? -v11 : v11;
    }
    int64_t v12 = v8 + 1; // 0x1eb6
    int64_t v13 = 48 - v10; // 0x1ebc
    int64_t v14 = (int64_t)*(char *)v12; // 0x1ebe
    int64_t v15 = v12; // 0x1ec9
    int64_t v16 = v13 & 0xffffffff; // 0x1ec9
    while ((*(char *)(2 * v14 + v2) & 4) != 0) {
        // 0x1eb0
        v12 = v15 + 1;
        v13 = 48 - v14 + 10 * v16;
        v14 = (int64_t)*(char *)v12;
        v15 = v12;
        v16 = v13 & 0xffffffff;
    }
    // 0x1ecb
    v11 = v13;
    return v9 == 0 ? -v11 : v11;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_ctype.c
// Address range: 0x1ee0 - 0x1f02
// Line range:    140 - 146
int32_t _isctype(uint32_t c, int32_t mask) {
    int32_t result = 0; // 0x1eef
    if (c < 256) {
        uint16_t v1 = *(int16_t *)((0x100000000 * (int64_t)c >> 31) + (int64_t)g22); // 0x1efb
        result = (int32_t)v1 & mask;
    }
    // 0x1f01
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_fabs.c
// Address range: 0x1f10 - 0x1f24
// Line range:    5 - 10
float64_t libmin_fabs(float64_t x) {
    int64_t v1 = __asm_movq_3((int128_t)(int32_t)(float32_t)x); // 0x1f14
    return (int64_t)__asm_movq(v1 & 0x7fffffffffffffff);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_fabs.c
// Address range: 0x1f30 - 0x1f42
// Line range:    13 - 18
float32_t libmin_fabsf(float32_t x) {
    uint32_t v1 = __asm_movd((int128_t)(int32_t)x); // 0x1f34
    return (int32_t)__asm_movd_8(v1 % 0x80000000);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_floor.c
// Address range: 0x1f50 - 0x2001
// Line range:    7 - 23
float64_t libmin_floor(float64_t x) {
    // 0x1f50
    int128_t v1; // 0x1f50
    int128_t v2 = v1;
    int128_t v3 = (float32_t)x;
    uint64_t v4 = __asm_movq_3(v3); // 0x1f54
    int64_t v5 = __asm_movq_3(v3); // 0x1f59
    uint32_t v6 = (int32_t)(v4 / 0x10000000000000) % 2048; // 0x1f67
    int64_t result = (float32_t)x;
    if (v6 > (int32_t)&g5) {
        // 0x1fb2
        return result;
    }
    int32_t v7 = v6 - 1074; // 0x1f67
    unsigned char v8 = llvm_ctpop_i8((char)v7); // 0x1f67
    int128_t v9 = __asm_pxor(v2, v2); // 0x1f72
    __asm_ucomisd(v3, v9);
    if (v7 != 0 ? v7 >= 0 == (v7 != 0) : v8 % 2 != 0) {
        // 0x1fb2
        return result;
    }
    int128_t v10 = __asm_movsd_1(0x4330000000000000); // 0x1f84
    int128_t v11 = __asm_movapd(v3); // 0x1f8c
    int128_t v12; // 0x1f50
    if (v5 < 0) {
        int128_t v13 = __asm_subsd(__asm_addsd(__asm_subsd(v11, v10), v10), v3); // 0x1fc0
        v12 = v13;
        if (v6 <= (int32_t)&g2) {
            // 0x1fcb
            __asm_movsd_1(__asm_movsd(v13));
            return (int64_t)__asm_movsd_1(-0x4010000000000000);
        }
    } else {
        int128_t v14 = __asm_subsd(__asm_subsd(__asm_addsd(v11, v10), v10), v3); // 0x1f9d
        v12 = v14;
        if (v6 <= (int32_t)&g2) {
            // 0x1ff0
            __asm_movsd_1(__asm_movsd(v14));
            return (int64_t)__asm_movapd(v9);
        }
    }
    // 0x1fa8
    __asm_comisd(v12, v9);
    int128_t v15 = __asm_addsd(v3, v12); // 0x1fac
    if (v6 < 1023) {
        // 0x1fb2
        return (int64_t)v15;
    }
    // 0x1fe0
    return (int64_t)__asm_subsd_4(v15, (int64_t)g7);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_pow.c
// Address range: 0x2010 - 0x2998
// Line range:    84 - 279
float64_t libmin_pow(float64_t x, float64_t y) {
    // 0x2010
    int128_t v1; // 0x2010
    int128_t v2 = v1;
    int128_t v3 = (float32_t)y;
    uint64_t v4 = __asm_movq_3(v3); // 0x201a
    uint64_t v5 = __asm_movq_3(v3); // 0x2021
    uint64_t v6 = v5 / 0x100000000; // 0x2026
    uint64_t v7 = v6 % 0x80000000; // 0x202f
    if ((int32_t)(v7 || v4) == 0) {
        // 0x20b0
        return (int64_t)__asm_movsd_1((int64_t)g7);
    }
    int128_t v8 = (float32_t)x;
    uint64_t v9 = __asm_movq_3(v8); // 0x2040
    int128_t v10 = __asm_movapd(v8); // 0x2045
    int64_t v11 = __asm_movq_3(v8); // 0x2049
    int64_t result; // 0x2010
    if (v9 % 0xffffffff00000001 == 0x3ff0000000000000) {
        // 0x205b
        result = __asm_movsd_1((int64_t)g7);
        if ((int32_t)v11 == 0) {
            // 0x20a0
            return result;
        }
    }
    uint64_t v12 = v9 / 0x100000000; // 0x204e
    int64_t v13 = v12 % 0x80000000; // 0x206a
    uint32_t v14 = (int32_t)v13;
    if (v14 > 0x7ff00000) {
        // 0x20a0
        return (int64_t)__asm_movapd(__asm_addsd(v10, v3));
    }
    int32_t v15 = v11; // 0x207d
    if (v13 == 0x7ff00000 == (v15 != 0)) {
        // 0x20a0
        return (int64_t)__asm_movapd(__asm_addsd(v10, v3));
    }
    uint32_t v16 = (int32_t)v7; // 0x2086
    if (v16 > 0x7ff00000) {
        // 0x20a0
        return (int64_t)__asm_movapd(__asm_addsd(v10, v3));
    }
    uint32_t v17 = (int32_t)v4; // 0x2090
    if (v17 != 0 && v16 == 0x7ff00000) {
        // 0x20a0
        return (int64_t)__asm_movapd(__asm_addsd(v10, v3));
    }
    int64_t v18 = 0; // 0x20d5
    int64_t v19; // 0x2010
    int64_t v20; // 0x2010
    int128_t v21; // 0x2010
    int128_t v22; // 0x2010
    if ((int32_t)v12 < 0) {
        // 0x21b0
        v18 = 2;
        if (v16 > 0x433fffff) {
            goto lab_0x20db;
        } else {
            // 0x21bc
            v18 = 0;
            if (v16 < 0x3ff00000) {
                goto lab_0x20db;
            } else {
                int32_t v23 = v16 / 0x100000 - (int32_t)&g3; // 0x21cd
                if (v23 < 21) {
                    if (v17 != 0) {
                        int128_t v24 = __asm_movapd(v10); // 0x26ae
                        int64_t v25 = __asm_movsd(v10); // 0x26b2
                        float64_t v26 = libmin_fabs((float64_t)(int64_t)v24); // 0x26b8
                        int128_t v27 = __asm_movsd_1(v25); // 0x26bf
                        v22 = v27;
                        if (v15 != 0) {
                            goto lab_0x28b6;
                        } else {
                            // 0x26cb
                            v21 = (float32_t)v26;
                            v20 = 0;
                            v22 = v27;
                            if (v9 % 0x3fffffff00000001 != 0x3ff0000000000000 == (v13 != 0)) {
                                goto lab_0x28b6;
                            } else {
                                goto lab_0x26e8;
                            }
                        }
                    } else {
                        uint32_t v28 = (20 - v23) % 32; // 0x28d9
                        uint64_t v29 = v28 == 0 ? v7 : (int64_t)(v16 >> v28);
                        int64_t v30 = v28 == 0 ? v7 : (int64_t)((int32_t)v29 << v28);
                        v19 = 0;
                        if ((int32_t)v30 == v16) {
                            // 0x28e7
                            v19 = 2 - v29 % 2;
                        }
                        goto lab_0x20ec;
                    }
                } else {
                    uint32_t v31 = (20 - v23) % 32; // 0x21e6
                    uint64_t v32 = v31 == 0 ? v4 & 0xffffffff : (int64_t)(v17 >> v31);
                    int64_t v33 = v31 == 0 ? v4 : (int64_t)((int32_t)v32 << v31);
                    v18 = 0;
                    if ((int32_t)v33 == v17) {
                        // 0x21f5
                        v18 = 2 - v32 % 2;
                    }
                    goto lab_0x20db;
                }
            }
        }
    } else {
        goto lab_0x20db;
    }
  lab_0x20db:;
    int64_t v34 = v18; // 0x20de
    int128_t v35; // 0x2010
    if (v17 != 0) {
        goto lab_0x2117;
    } else {
        // 0x20e0
        v19 = v18;
        if (v7 == 0x7ff00000) {
            int128_t v36 = __asm_movsd_1((int64_t)g7); // 0x220f
            if ((v14 - 0x3ff00000 || v15) == 0) {
                // 0x20a0
                return (int64_t)v36;
            }
            if (v14 < 0x3ff00000) {
                // 0x287a
                if ((int32_t)v6 < 0) {
                    // 0x20a0
                    return (int64_t)__asm_movapd(__asm_xorpd(v3, g11));
                }
                // 0x21a1
                v35 = v36;
                // 0x20a0
                return (int64_t)__asm_pxor(v35, v35);
            }
            int128_t v37 = __asm_movapd(v3); // 0x222c
            if ((int32_t)v6 >= 0) {
                // 0x20a0
                return (int64_t)v37;
            }
            // 0x21a1
            v35 = v37;
            // 0x20a0
            return (int64_t)__asm_pxor(v35, v35);
        }
        goto lab_0x20ec;
    }
  lab_0x2117:;
    int128_t v38 = __asm_movapd(v10); // 0x2117
    int64_t v39 = __asm_movsd(v3); // 0x211f
    int64_t v40 = __asm_movsd(v10); // 0x2125
    int128_t v41 = (float32_t)libmin_fabs((float64_t)(int64_t)v38); // 0x212b
    int128_t v42 = __asm_movsd_1(v40); // 0x2136
    int128_t v43 = __asm_movsd_1(v39); // 0x213c
    if (v15 != 0) {
        goto lab_0x2162;
    } else {
        // 0x2144
        v21 = v41;
        v20 = v34 & 0xffffffff;
        if (v9 % 0x3fffffff00000001 == 0x3ff0000000000000 || v13 == 0) {
            goto lab_0x26e8;
        } else {
            goto lab_0x2162;
        }
    }
  lab_0x2162:;
    int64_t v44 = g7;
    int128_t v45 = __asm_movsd_1(v44); // 0x2162
    int128_t v46 = v45; // 0x216d
    if ((int32_t)v12 < 0) {
        int32_t v47 = v34; // 0x2690
        v22 = v42;
        if (v47 == 0) {
            goto lab_0x28b6;
        } else {
            // 0x2698
            v46 = v45;
            if (v47 == 1) {
                // 0x26a1
                v46 = __asm_movsd_1(-0x4010000000000000);
            }
            goto lab_0x2173;
        }
    } else {
        goto lab_0x2173;
    }
  lab_0x20ec:
    if (v7 == 0x3ff00000) {
        // 0x2836
        result = __asm_movapd(v10);
        if ((int32_t)v6 < 0) {
            int128_t v48 = __asm_divsd_7(__asm_movsd_1((int64_t)g7), v10); // 0x284b
            result = __asm_movapd(v48);
        }
        // 0x20a0
        return result;
    }
    if (v5 % 0xffffffff00000001 == 0x4000000000000000) {
        // 0x20a0
        return (int64_t)__asm_movapd(__asm_mulsd(v10, v10));
    }
    // 0x2105
    v34 = v19;
    if (v5 % 0xffffffff00000001 == 0x3fe0000000000000 == (int32_t)v12 >= 0) {
        // 0x296b
        return libmin_sqrt((float64_t)(int64_t)__asm_movapd(v10));
    }
    goto lab_0x2117;
  lab_0x2173:;
    // 0x2173
    int64_t v49; // 0x2010
    int64_t v50; // 0x2010
    int64_t v51; // 0x2010
    int32_t v52; // 0x2010
    int32_t v53; // 0x2010
    int32_t v54; // 0x2010
    int128_t v55; // 0x2010
    int128_t v56; // 0x2010
    int128_t v57; // 0x2010
    int128_t v58; // 0x2010
    int128_t v59; // 0x2010
    int128_t v60; // 0x2010
    int128_t v61; // 0x2010
    if (v16 < 0x41e00001) {
        int32_t v62; // 0x2010
        int64_t v63; // 0x2010
        int32_t v64; // 0x2010
        if (v9 % 0x7ff0000000000001 == 0) {
            int128_t v65 = __asm_mulsd_2(v41, 0x4340000000000000); // 0x2813
            int64_t v66 = __asm_movq_3(v65) / 0x100000000; // 0x282a
            v62 = v66;
            v49 = __asm_movq_3(v65);
            v64 = -1076;
            v63 = v66;
        } else {
            // 0x225d
            v62 = v14;
            v49 = __asm_movq_3(v41);
            v64 = -1023;
            v63 = v13;
        }
        uint64_t v67 = v63 % 0x100000; // 0x2267
        int32_t v68 = v64 + (v62 >> 20); // 0x2271
        int64_t v69 = v67 | 0x3ff00000; // 0x227b
        uint32_t v70 = (int32_t)v67; // 0x2288
        v50 = v69;
        v53 = v68;
        if (v70 < 0x3988f) {
            goto lab_0x22a0;
        } else {
            if (v70 < 0xbb67a) {
                int128_t v71 = __asm_movsd_1(0x3fe2b80340000000); // 0x28f6
                int128_t v72 = __asm_movsd_1(0x3e4cfdeb43cfd006); // 0x28fe
                int128_t v73 = __asm_movsd_1(0x3ff8000000000000); // 0x290b
                v57 = __asm_movsd_1(v44);
                v60 = v71;
                v61 = v72;
                v56 = v73;
                v51 = v69;
                v54 = v68;
                v52 = 0xc0000;
                goto lab_0x22b7;
            } else {
                // 0x2297
                v50 = v69 + 0x3ff00000 & 0x3fefffff;
                v53 = v68 + 1;
                goto lab_0x22a0;
            }
        }
    } else {
        if (v16 >= 0x43f00001) {
            int32_t v74 = v6;
            if (v14 > 0x3fefffff) {
                // 0x2921
                if (v74 < 1) {
                    // 0x21a1
                    v35 = v41;
                    // 0x20a0
                    return (int64_t)__asm_pxor(v35, v35);
                }
            } else {
                // 0x2198
                if (v74 >= 0) {
                    // 0x21a1
                    v35 = v41;
                    // 0x20a0
                    return (int64_t)__asm_pxor(v35, v35);
                }
            }
            int128_t v75 = __asm_movsd_1(0x7e37e43c8800759c); // 0x292a
            // 0x20a0
            return (int64_t)__asm_mulsd(v75, v75);
        }
        if (v14 < 0x3fefffff) {
            if ((int32_t)v6 >= 0) {
                goto lab_0x274f;
            } else {
                goto lab_0x2861;
            }
        } else {
            if (v14 > 0x3ff00000) {
                int32_t v76 = v6; // 0x2982
                if (v76 >= 0 == (v76 != 0)) {
                    goto lab_0x2861;
                } else {
                    goto lab_0x274f;
                }
            } else {
                int128_t v77 = __asm_movsd_1(v44); // 0x2782
                int128_t v78 = __asm_movsd_1(0x3fd0000000000000); // 0x278a
                int128_t v79 = __asm_movsd_1(0x3fd5555555555555); // 0x279c
                int128_t v80 = __asm_movsd_1(0x3ff7154760000000); // 0x27a4
                int128_t v81 = __asm_subsd(v41, v77); // 0x27ac
                int128_t v82 = __asm_movsd_1(0x3e54ae0bf85ddf44); // 0x27b0
                int128_t v83 = __asm_mulsd(v78, v81); // 0x27b8
                int128_t v84 = __asm_mulsd(v80, v81); // 0x27bc
                int128_t v85 = __asm_mulsd(v82, v81); // 0x27c0
                int128_t v86 = __asm_subsd(v79, v83); // 0x27c4
                int128_t v87 = __asm_movsd_1((int64_t)g8); // 0x27c8
                int128_t v88 = __asm_mulsd(v86, v81); // 0x27d0
                int128_t v89 = __asm_mulsd(v81, v81); // 0x27d4
                int128_t v90 = __asm_subsd(v87, v88); // 0x27d8
                int128_t v91 = __asm_movapd(v84); // 0x27dc
                int128_t v92 = __asm_subsd(v85, __asm_mulsd_2(__asm_mulsd(v90, v89), 0x3ff71547652b82fe)); // 0x27ec
                uint64_t v93 = __asm_movq_3(__asm_addsd(v91, v92)); // 0x27f4
                int64_t v94 = v93 < 0xffffffff00000001 ? v93 : v93 + 0xffffffff; // 0x27f9
                int128_t v95 = __asm_movq(v94); // 0x27fc
                v58 = v77;
                v59 = __asm_movq(v94);
                v55 = __asm_subsd(v92, __asm_subsd(v95, v84));
                goto lab_0x2497;
            }
        }
    }
  lab_0x26e8:;
    int128_t v96 = v21; // 0x26eb
    if ((int32_t)v6 < 0) {
        // 0x26ed
        v96 = __asm_movapd(__asm_divsd_7(__asm_movsd_1((int64_t)g7), v21));
    }
    int128_t v97 = v96;
    int64_t result2 = v97;
    if ((int32_t)v12 >= 0) {
        // 0x20a0
        return result2;
    }
    int32_t v98 = v20; // 0x270d
    if ((v14 - 0x3ff00000 || v98) == 0) {
        int128_t v99 = __asm_subsd(v97, v97); // 0x2716
        // 0x20a0
        return (int64_t)__asm_divsd_7(v99, v99);
    }
    // 0x2955
    result = result2;
    if (v98 == 1) {
        // 0x295e
        result = __asm_xorpd(v97, g11);
    }
    // 0x20a0
    return result;
  lab_0x28b6:;
    int128_t v100 = v22;
    int128_t v101 = __asm_subsd(v100, v100); // 0x28b6
    // 0x20a0
    return (int64_t)__asm_movapd(__asm_divsd_7(v101, v101));
  lab_0x22a0:;
    int128_t v102 = __asm_movsd_1(v44); // 0x22a0
    int128_t v103 = __asm_pxor(v2, v2); // 0x22a8
    int128_t v104 = __asm_movapd(v103); // 0x22ae
    int128_t v105 = __asm_movapd(v102); // 0x22b2
    v57 = v102;
    v60 = v103;
    v61 = v104;
    v56 = v105;
    v51 = v50;
    v54 = v53;
    v52 = 0x80000;
    goto lab_0x22b7;
  lab_0x22b7:;
    int128_t v106 = v61;
    int128_t v107 = __asm_movapd(v57); // 0x22bc
    int64_t v108 = 0x100000000 * v51 | v49 & 0xffffffff; // 0x22cc
    int128_t v109 = __asm_movq(v108); // 0x22d6
    int128_t v110 = __asm_movq(v108); // 0x22db
    int128_t v111 = __asm_movq(v108); // 0x22e0
    int128_t v112 = __asm_addsd(v109, v56); // 0x22e8
    int128_t v113 = __asm_subsd(v110, v56); // 0x22ed
    int128_t v114 = __asm_divsd_7(v107, v112); // 0x2300
    int128_t v115 = __asm_movapd(v113); // 0x2304
    int128_t v116 = __asm_movq(0x100000000 * (int64_t)(((int32_t)v51 >> 1 | 0x20000000) + v52)); // 0x2309
    int128_t v117 = __asm_mulsd(v115, v114); // 0x230e
    uint64_t v118 = __asm_movq_3(v117); // 0x2313
    int64_t v119 = v118 < 0xffffffff00000001 ? v118 : v118 + 0xffffffff; // 0x2318
    int128_t v120 = __asm_movq(v119); // 0x231b
    int128_t v121 = __asm_movq(v119); // 0x2320
    int128_t v122 = __asm_mulsd(v120, v116); // 0x2325
    int128_t v123 = __asm_subsd(v111, __asm_subsd(v116, v56)); // 0x232f
    int128_t v124 = __asm_mulsd(__asm_movapd(v117), v117); // 0x2338
    int128_t v125 = __asm_subsd(v113, v122); // 0x233d
    int128_t v126 = __asm_movsd_1(0x4008000000000000); // 0x2342
    int128_t v127 = __asm_subsd(v125, __asm_mulsd(v123, v121)); // 0x2350
    int128_t v128 = __asm_addsd(__asm_movapd(v117), v121); // 0x235a
    int128_t v129 = __asm_mulsd(v127, v114); // 0x235f
    int128_t v130 = __asm_addsd_5(__asm_mulsd(__asm_movsd_1(0x3fca7e284a454eef), v124), 0x3fcd864a93c9db65); // 0x2370
    int128_t v131 = __asm_mulsd(v128, v129); // 0x2378
    int128_t v132 = __asm_mulsd(__asm_addsd_5(__asm_mulsd(v130, v124), 0x3fd17460a91d4101), v124); // 0x2389
    int128_t v133 = __asm_mulsd(__asm_addsd_5(v132, 0x3fd55555518f264d), v124); // 0x2395
    int128_t v134 = __asm_mulsd(__asm_addsd_5(v133, 0x3fdb6db6db6fabff), v124); // 0x23a1
    int128_t v135 = __asm_mulsd(__asm_addsd_5(v134, 0x3fe3333333333303), __asm_mulsd(v124, v124)); // 0x23b1
    int128_t v136 = __asm_mulsd(__asm_movq(v119), v121); // 0x23ba
    int128_t v137 = __asm_addsd(v131, v135); // 0x23bf
    uint64_t v138 = __asm_movq_3(__asm_addsd(__asm_addsd(__asm_movapd(v136), v126), v137)); // 0x23d0
    int64_t v139 = v138 < 0xffffffff00000001 ? v138 : v138 + 0xffffffff; // 0x23d5
    int128_t v140 = __asm_movq(v139); // 0x23d8
    int128_t v141 = __asm_movq(v139); // 0x23dd
    int128_t v142 = __asm_subsd(v140, v126); // 0x23e2
    int128_t v143 = __asm_mulsd(v129, v141); // 0x23e7
    int128_t v144 = __asm_mulsd(v121, v141); // 0x23ec
    int128_t v145 = __asm_movapd(__asm_subsd(v137, __asm_subsd(v142, v136))); // 0x23fb
    int128_t v146 = __asm_movapd(v144); // 0x23ff
    int128_t v147 = __asm_mulsd(v145, v117); // 0x2404
    int128_t v148 = __asm_movsd_1(0x3feec709e0000000); // 0x2409
    int128_t v149 = __asm_addsd(v147, v143); // 0x2412
    uint64_t v150 = __asm_movq_3(__asm_addsd(v146, v149)); // 0x241b
    int64_t v151 = v150 < 0xffffffff00000001 ? v150 : v150 + 0xffffffff; // 0x2420
    int128_t v152 = __asm_movq(v151); // 0x2423
    int128_t v153 = __asm_movq(v151); // 0x2428
    int128_t v154 = __asm_subsd(v152, v144); // 0x242d
    int128_t v155 = __asm_mulsd(v148, v153); // 0x2432
    int128_t v156 = __asm_mulsd_2(v153, -0x41c1d01feba4fe0b); // 0x2437
    int128_t v157 = __asm_addsd(__asm_mulsd_2(__asm_subsd(v149, v154), 0x3feec709dc3a03fd), v156); // 0x244b
    int128_t v158 = __asm_movapd(v155); // 0x244f
    int128_t v159 = __asm_addsd(v157, v106); // 0x2454
    __asm_pxor(v106, v106);
    int128_t v160 = __asm_cvtsi2sd(v54); // 0x245c
    uint64_t v161 = __asm_movq_3(__asm_addsd(__asm_addsd(__asm_addsd(v158, v159), v60), v160)); // 0x246c
    int64_t v162 = v161 < 0xffffffff00000001 ? v161 : v161 + 0xffffffff; // 0x2471
    int128_t v163 = __asm_movq(v162); // 0x2474
    int128_t v164 = __asm_movq(v162); // 0x2479
    int128_t v165 = __asm_movapd(__asm_subsd(__asm_subsd(v163, v160), v60)); // 0x2486
    int128_t v166 = __asm_movapd(v159); // 0x248a
    v58 = v57;
    v59 = v164;
    v55 = __asm_subsd(v166, __asm_subsd(v165, v155));
    goto lab_0x2497;
  lab_0x274f:;
    int128_t v219 = __asm_movsd_1(0x1a56e1fc2f8f359); // 0x274f
    // 0x20a0
    return (int64_t)__asm_mulsd(__asm_movapd(__asm_mulsd(v46, v219)), v219);
  lab_0x2861:;
    int128_t v220 = __asm_movsd_1(0x7e37e43c8800759c); // 0x2861
    // 0x20a0
    return (int64_t)__asm_mulsd(__asm_movapd(__asm_mulsd(v46, v220)), v220);
  lab_0x2497:;
    int128_t v167 = __asm_movapd(v43); // 0x24a1
    int128_t v168 = __asm_mulsd(v43, v55); // 0x24a5
    int128_t v169 = __asm_movq(v4 < 0xffffffff00000001 ? v4 : v4 + 0xffffffff); // 0x24ac
    int128_t v170 = __asm_mulsd(__asm_subsd(v167, v169), v59); // 0x24b5
    int128_t v171 = __asm_mulsd(v59, v169); // 0x24b9
    int128_t v172 = __asm_addsd(v168, v170); // 0x24bd
    int128_t v173 = __asm_addsd(__asm_movapd(v172), v171); // 0x24c5
    uint64_t v174 = __asm_movq_3(v173); // 0x24c9
    int64_t v175 = __asm_movq_3(v173); // 0x24ce
    uint64_t v176 = v174 / 0x100000000; // 0x24d3
    int32_t v177 = v176; // 0x24dd
    int64_t v178; // 0x2010
    int32_t v179; // 0x2010
    int64_t v180; // 0x2010
    int64_t v181; // 0x2010
    int128_t v182; // 0x2010
    if (v177 < 0x40900000) {
        uint32_t v183 = v177 % 0x80000000;
        if (v183 < 0x4090cc00) {
            // 0x28a1
            v182 = v171;
            v178 = v175;
            v180 = 0;
            v179 = 0;
            if (v183 > 0x3fe00000) {
                // 0x2990
                v181 = v183 / 0x100000;
                goto lab_0x2516;
            } else {
                goto lab_0x2585;
            }
        } else {
            if ((v177 + 0x3f6f3400 || (int32_t)v175) == 0) {
                // 0x2741
                __asm_comisd(__asm_subsd(v173, v171), v172);
            }
            goto lab_0x274f;
        }
    } else {
        if ((v177 - 0x40900000 || (int32_t)v175) != 0) {
            goto lab_0x2861;
        } else {
            // 0x250b
            __asm_comisd(__asm_addsd(__asm_movsd_1(0x3c971547652b82fe), v172), __asm_subsd(v173, v171));
            v181 = v174 / 0x10000000000000 % 2048;
            goto lab_0x2516;
        }
    }
  lab_0x2585:;
    uint64_t v184 = v178;
    int128_t v185 = __asm_movsd_1(0x3fe62e4300000000); // 0x258f
    int64_t v186 = v184 < 0xffffffff00000001 ? v184 : v184 + 0xffffffff; // 0x2597
    int128_t v187 = __asm_movq(v186); // 0x259a
    int128_t v188 = __asm_movq(v186); // 0x259f
    int128_t v189 = __asm_subsd(v187, v182); // 0x25a4
    int128_t v190 = __asm_mulsd(v185, v188); // 0x25a8
    int128_t v191 = __asm_mulsd_2(v188, -0x41dfa39ef35793c7); // 0x25ac
    int128_t v192 = __asm_addsd(__asm_mulsd_2(__asm_subsd(v172, v189), 0x3fe62e42fefa39ef), v191); // 0x25c0
    int128_t v193 = __asm_addsd(__asm_movapd(v190), v192); // 0x25c8
    int128_t v194 = __asm_movapd(v193); // 0x25cc
    int128_t v195 = __asm_mulsd(__asm_movapd(v193), v193); // 0x25d4
    int128_t v196 = __asm_subsd(v192, __asm_subsd(v194, v190)); // 0x25dc
    int128_t v197 = __asm_mulsd(__asm_movsd_1(0x3e66376972bea4d0), v195); // 0x25e8
    int128_t v198 = __asm_mulsd(__asm_subsd_4(v197, 0x3ebbbd41c5d26bf1), v195); // 0x25f4
    int128_t v199 = __asm_mulsd(__asm_addsd_5(v198, 0x3f11566aaf25de2c), v195); // 0x2600
    int128_t v200 = __asm_mulsd(__asm_subsd_4(v199, 0x3f66c16c16bebd93), v195); // 0x260c
    int128_t v201 = __asm_subsd(__asm_movapd(v193), __asm_mulsd(__asm_addsd_5(v200, 0x3fc555555555553e), v195)); // 0x2620
    int128_t v202 = __asm_divsd_7(__asm_mulsd(__asm_movapd(v193), v201), __asm_subsd_4(v201, 0x4000000000000000)); // 0x2634
    int128_t v203 = __asm_subsd(v202, __asm_addsd(v196, __asm_mulsd(__asm_movapd(v193), v196))); // 0x2644
    int128_t v204 = __asm_subsd(v58, __asm_subsd(v203, v193)); // 0x264c
    int64_t v205 = __asm_movq_3(v204) / 0x100000000 + v180; // 0x2660
    int128_t v206 = __asm_movq(0x100000000 * v205 | __asm_movq_3(v204) & 0xffffffff); // 0x2677
    int128_t v207 = v46; // 0x2677
    if ((int32_t)v205 < 0x100000) {
        int128_t v208 = __asm_movapd(v204); // 0x293b
        int64_t v209 = __asm_movsd(v46); // 0x293f
        v206 = (float32_t)libmin_scalbn((float64_t)(int64_t)v208, v179);
        v207 = __asm_movsd_1(v209);
    }
    // 0x20a0
    return (int64_t)__asm_mulsd(v206, v207);
  lab_0x2516:;
    uint64_t v210 = v176 + (int64_t)(0x100000 >> ((int32_t)v181 + 2) % 32); // 0x2528
    int32_t v211 = v210 / 0x100000;
    int64_t v212 = v210 % 0x100000 | 0x100000; // 0x2559
    int128_t v213 = __asm_movq(0x100000000 * (v210 & (int64_t)(-0x100000 >> (v211 + 1) % 32))); // 0x255f
    uint32_t v214 = (19 - v211) % 32; // 0x2564
    int64_t v215 = v214 == 0 ? v212 : (int64_t)((int32_t)v212 >> v214);
    int128_t v216 = __asm_subsd(v171, v213); // 0x2566
    int64_t v217 = v177 < 0 ? -v215 : v215; // 0x2574
    int128_t v218 = __asm_addsd(__asm_movapd(v172), v216); // 0x2577
    v182 = v216;
    v178 = __asm_movq_3(v218);
    v180 = 0x100000 * v217 & 0xfff00000;
    v179 = v217;
    goto lab_0x2585;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x29a0 - 0x2be8
// Line range:    426 - 483
void fmtint(char * buffer, int64_t * currlen, uint64_t maxlen, int64_t value, int32_t base, int32_t min, int32_t max, uint32_t flags) {
    int64_t v1 = flags; // 0x29af
    int64_t v2 = value; // 0x29cf
    int64_t v3 = 0; // 0x29cf
    int32_t v4 = 0; // 0x29cf
    if ((flags & 64) == 0) {
        if (value < 0) {
            // 0x2bb0
            v2 = -value;
            v3 = 45;
            v4 = -1;
        } else {
            // 0x29da
            v2 = value;
            v3 = 43;
            v4 = -1;
            if ((v1 & 2) == 0) {
                uint32_t v5 = 8 * flags & 32; // 0x2bd3
                v2 = value;
                v3 = v5;
                v4 = v5 != 0;
            }
        }
    }
    int64_t v6 = (int64_t)currlen;
    int64_t v7 = (int64_t)buffer;
    uint32_t v8 = max > 0 ? max : 0; // 0x29c7
    uint64_t v9 = (int64_t)base; // 0x2a02
    int64_t v10; // bp-89, 0x29a0
    int64_t v11 = &v10; // 0x2a05
    int64_t v12 = (v1 & 32) == 0 ? (int64_t)"0123456789abcdef" : (int64_t)"0123456789ABCDEF"; // 0x2a1d
    uint64_t v13 = v2; // 0x2a21
    int64_t v14 = 1;
    *(char *)(v14 + v11) = *(char *)(v13 % v9 + v12);
    int32_t v15 = v14;
    int32_t v16 = v15 - 19; // 0x2a48
    int64_t v17 = v14 + 1; // 0x2a54
    while (v13 >= v9 == (v16 == 0 || v16 < 0 != (18 - v15 & v15) < 0)) {
        // 0x2a28
        v13 /= v9;
        v14 = v17;
        *(char *)(v14 + v11) = *(char *)(v13 % v9 + v12);
        v15 = v14;
        v16 = v15 - 19;
        v17 = v14 + 1;
    }
    int64_t v18 = v15 == 20 ? 19 : v14 & 0xffffffff; // 0x2a66
    int32_t v19 = v18; // 0x2a6a
    int32_t v20 = v8 - v19; // 0x2a6a
    int64_t v21 = 0x100000000 * v18 >> 32; // 0x2a70
    int64_t v22; // bp-48, 0x29a0
    int64_t v23 = (int64_t)&v22 - 40 + v21; // 0x2a77
    *(char *)v23 = 0;
    uint32_t v24 = min - (int32_t)(v20 < 0 == (v20 & v19) < 0 ? (int64_t)v8 : v18) + v4; // 0x2a83
    uint32_t v25 = v20 > 0 ? v20 : 0; // 0x2a89
    int64_t v26 = v25; // 0x2a89
    int64_t v27 = v24 >= 0 ? (int64_t)v24 : 0; // 0x2a95
    int64_t v28; // 0x29a0
    int64_t v29; // 0x29a0
    int64_t v30; // 0x29a0
    if ((v1 & 16) == 0) {
        if (flags % 2 != 0) {
            // 0x2b90
            v29 = v6;
            v30 = -v27 & 0xffffffff;
            v28 = v26;
        } else {
            // 0x2b54
            v29 = v6;
            v30 = v27;
            v28 = v26;
            if (v24 >= 1) {
                if (v6 < maxlen) {
                    // 0x2b65
                    *(char *)(v6 + v7) = 32;
                }
                int64_t v31 = v6 + 1; // 0x2b6c
                *currlen = v31;
                uint32_t v32 = (int32_t)v27 - 1; // 0x2b73
                int64_t v33 = v32; // 0x2b76
                while (v32 != 0) {
                    int64_t v34 = v31;
                    int64_t v35 = v34; // 0x2b63
                    if (v34 < maxlen) {
                        // 0x2b65
                        *(char *)(v34 + v7) = 32;
                        v35 = v6;
                    }
                    // 0x2b6c
                    v31 = v35 + 1;
                    *currlen = v31;
                    v32 = (int32_t)v33 - 1;
                    v33 = v32;
                }
                int32_t v36 = v27; // 0x2b78
                v29 = v31;
                v30 = v27 - (v36 >= 0 == (v36 != 0) ? v27 : 1) & 0xffffffff;
                v28 = v26;
            }
        }
    } else {
        int32_t v37 = v27; // 0x2aa6
        int32_t v38 = v25 - v37; // 0x2aa6
        v29 = v6;
        v30 = 0;
        v28 = v38 < 0 == (v38 & v37) < 0 ? v26 : v27;
    }
    int64_t v39 = v29; // 0x2ab2
    if (v3 != 0) {
        int64_t v40 = v29; // 0x2ab7
        if (v29 < maxlen) {
            // 0x2ba0
            *(char *)(v29 + v7) = (char)v3;
            v40 = v6;
        }
        // 0x2abd
        v39 = v40 + 1;
        *currlen = v39;
    }
    int64_t v41 = v39; // 0x2ac7
    uint32_t v42 = v28; // 0x2ac7
    if ((int32_t)v28 != 0) {
        int64_t v43 = v39; // 0x2b33
        if (v39 < maxlen) {
            // 0x2b35
            *(char *)(v39 + v7) = 48;
            v43 = v6;
        }
        int64_t v44 = v43 + 1; // 0x2b3c
        *currlen = v44;
        v41 = v44;
        while (v42 != 0) {
            // 0x2b30
            v42 = (int64_t)v42;
            int64_t v45 = v44;
            v43 = v45;
            if (v45 < maxlen) {
                // 0x2b35
                *(char *)(v45 + v7) = 48;
                v43 = v6;
            }
            // 0x2b3c
            v44 = v43 + 1;
            *currlen = v44;
            v41 = v44;
        }
    }
    int64_t v46 = v23; // 0x2ad8
    v46--;
    int64_t v47 = v41; // 0x2ae3
    if (v41 < maxlen) {
        // 0x2ae5
        *(char *)(v41 + v7) = *(char *)v46;
        v47 = v6;
    }
    int64_t v48 = v47 + 1; // 0x2af0
    *currlen = v48;
    while (v21 + v11 - (v18 + 0xffffffff & 0xffffffff) != v46) {
        int64_t v49 = v48;
        v46--;
        v47 = v49;
        if (v49 < maxlen) {
            // 0x2ae5
            *(char *)(v49 + v7) = *(char *)v46;
            v47 = v6;
        }
        // 0x2af0
        v48 = v47 + 1;
        *currlen = v48;
    }
    // 0x2b00
    if (v30 == 0) {
        // 0x2b20
        return;
    }
    uint32_t v50 = v30; // 0x2b02
    int64_t v51 = v48; // 0x2b0b
    if (v48 < maxlen) {
        // 0x2b0d
        *(char *)(v48 + v7) = 32;
        v51 = v6;
    }
    int64_t v52 = v51 + 1; // 0x2b14
    *currlen = v52;
    while (v50 != 0) {
        // 0x2b08
        v50 = (int64_t)v50;
        int64_t v53 = v52;
        v51 = v53;
        if (v53 < maxlen) {
            // 0x2b0d
            *(char *)(v53 + v7) = 32;
            v51 = v6;
        }
        // 0x2b14
        v52 = v51 + 1;
        *currlen = v52;
    }
}

// Address range: 0x2bf0 - 0x2ca3
int64_t my_modf_isra_0(int64_t a1) {
    // 0x2bf0
    int128_t v1; // 0x2bf0
    int128_t v2 = __asm_movapd(v1); // 0x2bf1
    int128_t v3 = __asm_movsd_1((int64_t)g7); // 0x2bfe
    int128_t v4 = __asm_movsd_1(0x3fb999999999999a); // 0x2c06
    int128_t v5 = __asm_movsd_1(0x4024000000000000); // 0x2c0e
    int128_t v6 = __asm_movapd(v3); // 0x2c16
    int64_t v7; // bp-8, 0x2bf0
    bool v8 = &v7 < (int64_t *)32; // 0x2c1a
    int64_t result2 = 0;
    int128_t v9 = v6;
    int128_t v10; // 0x2bf0
    int128_t v11 = v10;
    int128_t v12 = v2;
    int64_t v13 = __asm_cvttsd2si_10(v12); // 0x2c30
    __asm_pxor(v11, v11);
    int128_t v14 = __asm_addsd(__asm_movapd(v12), v3); // 0x2c3d
    int128_t v15 = __asm_cvtsi2sd_9(v13); // 0x2c41
    __asm_comisd(v14, v15);
    while (v8) {
        int64_t v16 = result2 + 1; // 0x2c24
        int64_t result = v16 & 0xffffffff; // 0x2c24
        uint32_t v17 = (int32_t)v16; // 0x2c2b
        v8 = v17 < 100;
        int128_t v18 = __asm_mulsd(v12, v4); // 0x2c2e
        int128_t v19 = __asm_mulsd(v9, v5); // 0x2c2e
        if (v17 == 100) {
            // 0x2c68
            *(int64_t *)a1 = 0;
            return result;
        }
        result2 = result;
        v9 = v19;
        v11 = v15;
        v12 = v18;
        v13 = __asm_cvttsd2si_10(v12);
        __asm_pxor(v11, v11);
        v14 = __asm_addsd(__asm_movapd(v12), v3);
        v15 = __asm_cvtsi2sd_9(v13);
        __asm_comisd(v14, v15);
    }
    // 0x2c4c
    __asm_comisd(v15, __asm_subsd(__asm_movapd(v12), v3));
    if (result2 == 0) {
        // 0x2c5e
        *(int64_t *)a1 = __asm_movsd(v15);
        return result2;
    }
    int128_t v20 = __asm_mulsd(v15, v9); // 0x2c75
    __asm_subsd(v1, v20);
    int64_t v21 = __asm_movsd(v20); // 0x2c82
    int64_t v22; // bp-16, 0x2bf0
    int64_t result3 = my_modf_isra_0((int64_t)&v22); // 0x2c88
    *(int64_t *)a1 = __asm_movsd(__asm_addsd_5(__asm_movsd_1(v21), v22));
    return result3;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x2cb0 - 0x3230
// Line range:    586 - 525
void fmtfp(char * buffer, int64_t * currlen, uint64_t maxlen, float128_t fvalue, int32_t min, uint32_t max, int32_t flags) {
    char iconvert[311]; // bp-704, 0x2cb0
    char v1[311]; // 0x2cb0
    char v2[311]; // 0x3218
    char v3[311]; // 0x3152
    char v4[311]; // 0x2db3
    char v5[311]; // 0x312c
    // 0x2cb0
    int128_t v6; // 0x2cb0
    int128_t v7 = v6;
    int128_t v8 = v6;
    int128_t v9 = v6;
    int3_t v10; // 0x2cb0
    int3_t v11 = v10 - 1;
    float80_t v12; // 0x2cb0
    __frontend_reg_store_fpr(v11, v12);
    int32_t v13 = 6; // 0x2cd5
    int64_t v14 = 6; // 0x2cd5
    if (max >= 0) {
        int32_t v15 = max - 16; // 0x2ce1
        v14 = v15 == 0 | v15 < 0 != (15 - max & max) < 0 ? (int64_t)max : 16;
        v13 = max;
    }
    uint64_t v16 = (int64_t)flags;
    int3_t v17 = v10 - 2; // 0x2ce8
    __frontend_reg_store_fpr(v17, 0.0L);
    float80_t v18 = __frontend_reg_load_fpr(v17); // 0x2cea
    float80_t v19 = __frontend_reg_load_fpr(v11); // 0x2cea
    float80_t v20 = __frontend_reg_load_fpr(v11);
    int32_t v21; // 0x2cb0
    int32_t v22; // 0x2cb0
    float64_t v23; // bp-744, 0x2cb0
    int128_t v24; // 0x2cb0
    if (v18 > v19) {
        // 0x3160
        __frontend_reg_store_fpr(v11, -v20);
        float64_t v25 = __frontend_reg_load_fpr(v11); // 0x316a
        v23 = v25;
        v22 = 45;
        v21 = 1;
        v24 = __asm_movsd_1((int64_t)v25);
    } else {
        float64_t v26 = v20; // 0x2cf2
        v23 = v26;
        int128_t v27 = __asm_movsd_1((int64_t)v26); // 0x2cf5
        v22 = 43;
        v21 = 1;
        v24 = v27;
        if ((v16 & 2) == 0) {
            int32_t v28 = 8 * flags & 32; // 0x2d0d
            v22 = v28;
            v21 = v28 != 0;
            v24 = v27;
        }
    }
    // 0x2d1e
    __asm_movapd(v24);
    float64_t fracpart; // bp-712, 0x2cb0
    int64_t v29 = &fracpart; // 0x2d28
    my_modf_isra_0(v29);
    bool v30; // 0x2cb0
    bool v31; // 0x2cb0
    int128_t v32; // 0x2cb0
    int128_t v33; // 0x2cb0
    int128_t v34; // 0x2cb0
    bool v35; // 0x2cb0
    bool v36; // 0x2cb0
    if (v13 == 0) {
        int128_t v37 = __asm_movsd_1((int64_t)fracpart); // 0x31c4
        int128_t v38 = __asm_subsd(v24, v37); // 0x31ca
        int64_t v39 = __asm_cvttsd2si_10(v38); // 0x31cf
        v23 = __asm_movsd(v38);
        __frontend_reg_store_fpr(v11, (float80_t)v39);
        __frontend_reg_store_fpr(v11, (float80_t)v23 - __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v17, 0.5L);
        float80_t v40 = __frontend_reg_load_fpr(v17); // 0x31ec
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v11, v40);
        float80_t v41 = __frontend_reg_load_fpr(v17); // 0x31ee
        float80_t v42 = __frontend_reg_load_fpr(v11); // 0x31ee
        bool v43 = false; // 0x31ee
        bool v44 = false; // 0x31ee
        bool v45 = false; // 0x31ee
        if (v41 <= v42) {
            v43 = true;
            v44 = false;
            v45 = false;
            if (v41 >= v42) {
                v43 = v41 != v42;
                v44 = v41 != v42;
                v45 = true;
            }
        }
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
        bool v46 = true; // 0x31f2
        bool v47 = v44; // 0x31f2
        bool v48 = v45; // 0x31f2
        int64_t v49 = v39; // 0x31f2
        if (!v43) {
            // 0x31f4
            v49 = v39 + 1;
            v46 = v39 == -1;
            v47 = llvm_ctpop_i8((char)v49) % 2 == 0;
            v48 = v49 == 0;
        }
        // 0x31f8
        __asm_pxor(v7, v7);
        int128_t v50 = __asm_movsd_1((int64_t)g7); // 0x31fd
        int128_t v51 = __asm_cvtsi2sd_9(v49); // 0x3205
        v23 = __asm_movsd(v51);
        __asm_comisd(v51, v50);
        __frontend_reg_store_fpr(v11, (float80_t)v23);
        int64_t v52 = __asm_movsd(v51); // 0x3218
        v2[0] = v52;
        iconvert = v2;
        if (v46) {
            // 0x2de0
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
            v30 = v47;
            v35 = v48;
            v32 = v37;
            v34 = v51;
            goto lab_0x2de8;
        } else {
            int128_t v53 = __asm_addsd(v37, v50); // 0x3225
            __frontend_reg_store_fpr(v17, 1.0L);
            v31 = v47;
            v36 = v48;
            v33 = v53;
            goto lab_0x311b;
        }
    } else {
        // 0x2d39
        __frontend_reg_store_fpr(v11, 1.0L);
        __frontend_reg_store_fpr(v17, 10.0L);
        int64_t v54 = v14 & 0xffffffff; // 0x2d41
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v17));
        uint32_t v55 = (int32_t)v54 - 1; // 0x2d4a
        int64_t v56 = v55; // 0x2d4d
        while (v55 != 0) {
            // 0x2d48
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v17));
            v55 = (int32_t)v56 - 1;
            v56 = v55;
        }
        float80_t v57 = __frontend_reg_load_fpr(v17); // 0x2d4f
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v11, v57);
        int128_t v58 = __asm_movsd_1((int64_t)fracpart); // 0x2d55
        v23 = __asm_movsd(__asm_subsd(v24, v58));
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17) * (float80_t)v23);
        int3_t v59 = v10 - 3;
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        float80_t v60 = __frontend_reg_load_fpr(v59); // 0x2d7c
        v23 = v60;
        __frontend_reg_store_fpr(v59, v60);
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17) - __frontend_reg_load_fpr(v59));
        __frontend_reg_store_fpr(v59, 0.5L);
        float80_t v61 = __frontend_reg_load_fpr(v59); // 0x2d8e
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        __frontend_reg_store_fpr(v17, v61);
        float80_t v62 = __frontend_reg_load_fpr(v59); // 0x2d90
        float80_t v63 = __frontend_reg_load_fpr(v17); // 0x2d90
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17));
        if (v62 < v63) {
            // 0x3140
            __asm_pxor(v9, v9);
            int128_t v64 = __asm_cvtsi2sd_9((int64_t)v23); // 0x3144
            int64_t v65 = __asm_movsd(v64); // 0x314a
            v23 = v65;
            __frontend_reg_store_fpr(v17, (float80_t)(float64_t)v65);
            int64_t v66 = __asm_movsd(v64); // 0x3152
            v3[0] = v66;
            v1 = v3;
        } else {
            // 0x2d9a
            __asm_pxor(v9, v9);
            int128_t v67 = __asm_cvtsi2sd_9((int64_t)v23 + 1); // 0x2da6
            int64_t v68 = __asm_movsd(v67); // 0x2dab
            v23 = v68;
            __frontend_reg_store_fpr(v17, (float80_t)(float64_t)v68);
            int64_t v69 = __asm_movsd(v67); // 0x2db3
            v4[0] = v69;
            v1 = v4;
        }
        // 0x2db9
        iconvert = v1;
        __frontend_reg_store_fpr(v59, 1.0L);
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
        uint32_t v70 = (int32_t)v54 - 1; // 0x2dc2
        int64_t v71 = v70; // 0x2dc5
        while (v70 != 0) {
            // 0x2dc0
            __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
            v70 = (int32_t)v71 - 1;
            v71 = v70;
        }
        float80_t v72 = __frontend_reg_load_fpr(v59); // 0x2dc7
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        __frontend_reg_store_fpr(v17, v72);
        float80_t v73 = __frontend_reg_load_fpr(v59); // 0x2dc9
        float80_t v74 = __frontend_reg_load_fpr(v17); // 0x2dc9
        bool v75 = false; // 0x2dc9
        bool v76 = false; // 0x2dc9
        bool v77 = false; // 0x2dc9
        if (v73 <= v74) {
            v75 = true;
            v76 = false;
            v77 = false;
            if (v73 >= v74) {
                v75 = v73 != v74;
                v76 = v73 != v74;
                v77 = true;
            }
        }
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v59));
        if (!v75) {
            int128_t v78 = __asm_addsd_5(v58, (int64_t)g7); // 0x3100
            __frontend_reg_store_fpr(v59, 1.0L);
            __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
            uint32_t v79 = (int32_t)v54 - 1; // 0x3112
            int64_t v80 = v79; // 0x3115
            while (v79 != 0) {
                // 0x3110
                __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
                v79 = (int32_t)v80 - 1;
                v80 = v79;
            }
            unsigned char v81 = llvm_ctpop_i8((char)v79); // 0x3112
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v59));
            float80_t v82 = __frontend_reg_load_fpr(v17); // 0x3119
            __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
            __frontend_reg_store_fpr(v11, v82);
            v31 = v81 % 2 == 0;
            v36 = true;
            v33 = v78;
            goto lab_0x311b;
        } else {
            // 0x2dd3
            __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17));
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
            v30 = v76;
            v35 = v77;
            v32 = v58;
            v34 = __asm_movsd_1(*(int64_t *)&iconvert);
            goto lab_0x2de8;
        }
    }
  lab_0x2de8:;
    int64_t v83 = (int64_t)currlen;
    int64_t v84 = (int64_t)buffer;
    int64_t v85 = &v23; // 0x2cc0
    int64_t v86; // bp-697, 0x2cb0
    int64_t v87 = &v86; // 0x2ded
    int128_t v88 = __asm_pxor(v8, v8); // 0x2df2
    int128_t v89 = __asm_movsd_1(0x3fb999999999999a); // 0x2df7
    int128_t v90 = __asm_movsd_1(0x3fa999999999999a); // 0x2e00
    int128_t v91 = __asm_movsd_1(0x4024000000000000); // 0x2e10
    bool v92 = v30; // 0x2e19
    bool v93 = v35; // 0x2e19
    int64_t v94 = 1;
    int128_t v95 = __asm_movapd(__asm_mulsd(v32, v89)); // 0x2e3c
    my_modf_isra_0(v29);
    int128_t v96 = __asm_movsd_1((int64_t)fracpart); // 0x2e46
    int128_t v97 = __asm_subsd(v95, v96); // 0x2e4c
    __asm_ucomisd(v96, v88);
    int32_t v98 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v97, v90), v91)); // 0x2e60
    char v99 = *(char *)((int64_t)v98 + (int64_t)"0123456789abcdef"); // 0x2e67
    *(char *)(v94 + v87) = v99;
    bool v100; // 0x2cb0
    int64_t v101; // 0x2cb0
    bool v102; // 0x2cb0
    while (v92 || !v93) {
        int64_t v103 = v94 - 311; // 0x2e24
        unsigned char v104 = llvm_ctpop_i8((char)v103); // 0x2e24
        v92 = v104 % 2 == 0;
        v93 = false;
        v100 = v104 % 2 == 0;
        v102 = true;
        v101 = 310;
        if (v103 == 0) {
            goto lab_0x2e83;
        }
        v94++;
        v95 = __asm_movapd(__asm_mulsd(v96, v89));
        my_modf_isra_0(v29);
        v96 = __asm_movsd_1((int64_t)fracpart);
        v97 = __asm_subsd(v95, v96);
        __asm_ucomisd(v96, v88);
        v98 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v97, v90), v91));
        v99 = *(char *)((int64_t)v98 + (int64_t)"0123456789abcdef");
        *(char *)(v94 + v87) = v99;
    }
    int32_t v105 = (int32_t)v94 - 311; // 0x2e74
    v100 = llvm_ctpop_i8((char)v105) % 2 == 0;
    v102 = v105 == 0;
    v101 = v105 == 0 ? 310 : v94 & 0xffffffff;
  lab_0x2e83:
    // 0x2e83
    __asm_ucomisd(v34, v88);
    int64_t v106 = 0x100000000 * v101 >> 32; // 0x2e88
    v23 = v106;
    int64_t v107 = v85 + 48; // 0x2e8f
    *(char *)(v106 + v107) = 0;
    int64_t v108 = v14; // 0x2e94
    int64_t v109 = 0; // 0x2e94
    if (v100 || !v102) {
        bool v110 = v100; // 0x2eae
        bool v111 = v102; // 0x2eae
        int64_t v112 = 1;
        int128_t v113 = __asm_mulsd(v34, v89); // 0x2ec1
        __asm_movapd(v113);
        int128_t v114 = __asm_movapd(v113); // 0x2ece
        my_modf_isra_0((int64_t)&iconvert);
        int128_t v115 = __asm_movsd_1(*(int64_t *)&iconvert); // 0x2ed8
        int128_t v116 = __asm_subsd(v114, v115); // 0x2ee1
        __asm_ucomisd(v115, v88);
        int32_t v117 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v116, v90), v91)); // 0x2ef5
        char v118 = *(char *)((int64_t)v117 + (int64_t)"0123456789abcdef"); // 0x2efc
        int64_t v119; // bp-377, 0x2cb0
        *(char *)(v112 + (int64_t)&v119) = v118;
        while (v110 || !v111) {
            int64_t v120 = v112 - 311; // 0x2eb4
            v110 = llvm_ctpop_i8((char)v120) % 2 == 0;
            v111 = false;
            if (v120 == 0) {
                goto lab_0x31a8;
            }
            v112++;
            v113 = __asm_mulsd(v115, v89);
            __asm_movapd(v113);
            v114 = __asm_movapd(v113);
            my_modf_isra_0((int64_t)&iconvert);
            v115 = __asm_movsd_1(*(int64_t *)&iconvert);
            v116 = __asm_subsd(v114, v115);
            __asm_ucomisd(v115, v88);
            v117 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v116, v90), v91));
            v118 = *(char *)((int64_t)v117 + (int64_t)"0123456789abcdef");
            *(char *)(v112 + (int64_t)&v119) = v118;
        }
        if ((int32_t)v112 == 311) {
          lab_0x31a8:
            // 0x31a8
            v108 = v14 + 0xfffffeca;
            v109 = 310;
        } else {
            // 0x2f15
            v108 = v14 - v112;
            v109 = v112 & 0xffffffff;
        }
    }
    int64_t v121 = (0x100000000 * v109 >> 32) + v85;
    int64_t v122 = v121 + 368; // 0x2f25
    *(char *)v122 = 0;
    int32_t v123 = -1 - (int32_t)v14 + (int32_t)(float32_t)(float64_t)(int64_t)min - v21 - (int32_t)v101; // 0x2f3d
    int64_t v124 = v123 >= 0 ? (int64_t)v123 : 0; // 0x2f42
    int64_t v125; // 0x2cb0
    int64_t v126; // 0x2cb0
    int64_t v127; // 0x2cb0
    int64_t v128; // 0x2cb0
    int64_t v129; // 0x2cb0
    int64_t v130; // 0x2cb0
    if (v16 % 2 == 0) {
        if ((v16 & 16) == 0) {
            // 0x30c0
            v129 = v83;
            v125 = v124;
            if (v123 >= 1) {
                if (v83 < maxlen) {
                    // 0x30d5
                    *(char *)(v83 + v84) = 32;
                }
                int64_t v131 = v83 + 1; // 0x30dc
                *currlen = v131;
                uint32_t v132 = (int32_t)v124 - 1; // 0x30e3
                int64_t v133 = v132; // 0x30e7
                while (v132 != 0) {
                    int64_t v134 = v131;
                    int64_t v135 = v134; // 0x30d3
                    if (v134 < maxlen) {
                        // 0x30d5
                        *(char *)(v134 + v84) = 32;
                        v135 = v83;
                    }
                    // 0x30dc
                    v131 = v135 + 1;
                    *currlen = v131;
                    v132 = (int32_t)v133 - 1;
                    v133 = v132;
                }
                int32_t v136 = v124; // 0x30e9
                v129 = v131;
                v125 = v124 - (v136 >= 0 == (v136 != 0) ? v124 : 1) & 0xffffffff;
            }
            goto lab_0x2f53;
        } else {
            // 0x307e
            v129 = v83;
            v125 = v124;
            if (v123 < 1) {
                goto lab_0x2f53;
            } else {
                // 0x3087
                v130 = v83;
                v126 = v124;
                if (v22 != 0) {
                    // 0x3191
                    v128 = v83;
                    v127 = v124;
                    if (v83 < maxlen) {
                        // 0x319a
                        *(char *)(v83 + v84) = (char)v22;
                        v128 = v83;
                        v127 = v124;
                    }
                    goto lab_0x30a4;
                } else {
                    goto lab_0x3098;
                }
            }
        }
    } else {
        // 0x2f50
        v129 = v83;
        v125 = -v124 & 0xffffffff;
        goto lab_0x2f53;
    }
  lab_0x311b:
    // 0x311b
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) - __frontend_reg_load_fpr(v17));
    fracpart = __asm_movsd(v33);
    float64_t v137 = __frontend_reg_load_fpr(v11); // 0x3123
    v23 = v137;
    int128_t v138 = __asm_movsd_1((int64_t)v137); // 0x3126
    int64_t v139 = __asm_movsd(v138); // 0x312c
    v5[0] = v139;
    iconvert = v5;
    v30 = v31;
    v35 = v36;
    v32 = v33;
    v34 = v138;
    goto lab_0x2de8;
  lab_0x2f53:;
    int64_t v140 = v129; // 0x2f59
    int64_t v141 = v125; // 0x2f59
    if (v22 != 0) {
        int64_t v142 = v129; // 0x2f5e
        if (v129 < maxlen) {
            // 0x2f60
            *(char *)(v129 + v84) = (char)v22;
            v142 = v83;
        }
        int64_t v143 = v142 + 1; // 0x2f66
        *currlen = v143;
        v140 = v143;
        v141 = v125;
    }
    goto lab_0x2f6d;
  lab_0x2f6d:;
    int64_t v144 = v107 + (int64_t)v23 - 1;
    int64_t v145; // 0x2cb0
    if (v140 < maxlen) {
        // 0x2f85
        *(char *)(v145 + v84) = *(char *)v144;
    }
    int64_t v146 = v140 + 1; // 0x2f90
    *currlen = v146;
    int64_t v147 = v146; // 0x2f9e
    int64_t v148 = v144; // 0x2f9e
    while (v87 - (v101 + 0xffffffff & 0xffffffff) + (int64_t)v23 != v144) {
        // 0x2f80
        v144 = v148 - 1;
        if (v147 < maxlen) {
            // 0x2f85
            *(char *)(v145 + v84) = *(char *)v144;
        }
        // 0x2f90
        v146 = v147 + 1;
        *currlen = v146;
        v147 = v146;
        v148 = v144;
    }
    if (v13 != 0) {
        int64_t v149 = v146; // 0x2fa8
        if (v146 < maxlen) {
            // 0x2faa
            *(char *)(v146 + v84) = 46;
            v149 = v83;
        }
        int64_t v150 = v149 + 1; // 0x2fb1
        *currlen = v150;
        int64_t v151 = v150; // 0x2fba
        if ((int32_t)v108 >= 1) {
            int64_t v152 = v151;
            int64_t v153 = v152; // 0x2fc3
            if (v152 < maxlen) {
                // 0x2fc5
                *(char *)(v152 + v84) = 48;
                v153 = v83;
            }
            int64_t v154 = v153 + 1; // 0x2fcc
            *currlen = v154;
            uint32_t v155 = (int32_t)(v108 & 0xffffffff) - 1; // 0x2fd3
            int64_t v156 = v155; // 0x2fd6
            while (v155 != 0) {
                // 0x2fc0
                v152 = v154;
                v153 = v152;
                if (v152 < maxlen) {
                    // 0x2fc5
                    *(char *)(v152 + v84) = 48;
                    v153 = v83;
                }
                // 0x2fcc
                v154 = v153 + 1;
                *currlen = v154;
                v155 = (int32_t)v156 - 1;
                v156 = v155;
            }
        }
        if (v109 != 0) {
            int64_t v157 = v122 - 1;
            if (v83 < maxlen) {
                // 0x2ffd
                *(char *)(v83 + v84) = *(char *)v157;
            }
            int64_t v158 = v83 + 1; // 0x3008
            *currlen = v158;
            int64_t v159 = v157; // 0x3016
            while (367 - (v109 + 0xffffffff & 0xffffffff) + v121 != v157) {
                int64_t v160 = v158;
                v157 = v159 - 1;
                int64_t v161 = v160; // 0x2ffb
                if (v160 < maxlen) {
                    // 0x2ffd
                    *(char *)(v160 + v84) = *(char *)v157;
                    v161 = v83;
                }
                // 0x3008
                v158 = v161 + 1;
                *currlen = v158;
                v159 = v157;
            }
        }
    }
    // 0x3018
    if ((int32_t)v141 == 0) {
        // 0x3039
        return;
    }
    if (v83 < maxlen) {
        // 0x3025
        *(char *)(v83 + v84) = 32;
    }
    int64_t v162 = v83 + 1; // 0x302c
    *currlen = v162;
    uint32_t v163 = (int32_t)v141 + 1; // 0x3033
    int64_t v164 = v163; // 0x3037
    while (v163 != 0) {
        int64_t v165 = v162;
        int64_t v166 = v165; // 0x3023
        if (v165 < maxlen) {
            // 0x3025
            *(char *)(v165 + v84) = 32;
            v166 = v83;
        }
        // 0x302c
        v162 = v166 + 1;
        *currlen = v162;
        v163 = (int32_t)v164 + 1;
        v164 = v163;
    }
  lab_0x3098:;
    int64_t v167 = v126;
    int64_t v168 = v130;
    v128 = v168;
    v127 = v167;
    if (v168 < maxlen) {
        // 0x309d
        *(char *)(v168 + v84) = 48;
        v128 = v83;
        v127 = v167;
    }
    goto lab_0x30a4;
  lab_0x30a4:;
    int64_t v169 = v128 + 1; // 0x30a4
    *currlen = v169;
    uint32_t v170 = (int32_t)v127 - 1; // 0x30ab
    int64_t v171 = v170; // 0x30ab
    v140 = v169;
    v141 = v171;
    v130 = v169;
    v126 = v171;
    if (v170 != 0) {
        goto lab_0x3098;
    } else {
        goto lab_0x2f6d;
    }
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x3230 - 0x3b4d
// Line range:    130 - 290
int64_t dopr(char * buffer, uint64_t maxlen, char * format, int32_t * args) {
    // 0x3230
    int64_t v1; // 0x3230
    uint64_t v2 = v1;
    int64_t v3 = (int64_t)buffer;
    int64_t v4 = (int64_t)format + 1; // 0x3243
    int64_t v5 = v4; // 0x3243
    int64_t result2 = 0; // 0x3259
    int64_t v6; // 0x3230
    int64_t v7; // 0x3230
    int64_t v8; // 0x3230
    int64_t v9; // 0x3230
    char v10; // 0x3230
    int64_t v11; // 0x3230
    int64_t v12; // 0x3230
    if ((char)v2 != 0) {
        int64_t v13 = (int64_t)args;
        int64_t * v14 = (int64_t *)(v13 + 8);
        v6 = v4;
        v7 = v2 % 256;
        v12 = 0;
        while (true) {
          lab_0x32ae:;
            char v15 = v7; // 0x32b5
            int64_t v16 = v6; // 0x32b8
            char v17 = v15; // 0x32b8
            int64_t v18 = v12; // 0x32b8
            int64_t v19 = v6; // 0x32b8
            int64_t v20 = v12; // 0x32b8
            if (v15 != 37) {
                while (true) {
                  lab_0x32ba:;
                    uint64_t v21 = v18;
                    int64_t v22 = v16; // 0x32bd
                    if (v21 < maxlen) {
                        // 0x32bf
                        *(char *)(v21 + v3) = v17;
                        v22 = v5;
                    }
                    char v23 = *(char *)v22; // 0x32c3
                    int64_t v24 = v22 + 1; // 0x32c6
                    v5 = v24;
                    int64_t v25 = v21 + 1; // 0x32ca
                    result2 = v25;
                    v16 = v24;
                    v17 = v23;
                    v18 = v25;
                    v19 = v24;
                    v20 = v25;
                    switch (v23) {
                        case 0: {
                            goto lab_0x3260_3;
                        }
                        case 37: {
                            goto lab_0x32d9;
                        }
                        default: {
                            goto lab_0x32ba;
                        }
                    }
                }
            }
          lab_0x32d9:
            // 0x32d9
            v11 = v20;
            unsigned char v26 = *(char *)v19; // 0x32e3
            result2 = v11;
            if (v26 == 0) {
                // break -> 0x3260
                break;
            }
            int64_t v27 = v26; // 0x32e3
            int64_t result = v27; // 0x32fb
            if (v26 < 49) {
                // 0x3273
                return result;
            }
            int64_t v28 = v19 + 1; // 0x32ee
            int64_t v29 = (int64_t)g22; // 0x330a
            v5 = 0;
            int64_t v30 = v27; // 0x331a
            int64_t v31 = v28; // 0x331a
            int32_t v32 = 0; // 0x331a
            int64_t v33 = v27; // 0x331a
            int64_t v34 = v28; // 0x331a
            if ((*(char *)(2 * v27 + v29) & 4) != 0) {
                int64_t v35 = 0xffffffd0 + (0x100000000000000 * v30 >> 56); // 0x3326
                int64_t v36 = v35 & 0xffffffff; // 0x3326
                v5 = v36;
                unsigned char v37 = *(char *)v31; // 0x332a
                result2 = v11;
                if (v37 == 0) {
                    // break (via goto) -> 0x3260
                    goto lab_0x3260_3;
                }
                int64_t v38 = v31 + 1; // 0x3322
                int64_t v39 = v37; // 0x332a
                v31 = v38;
                while ((*(char *)(2 * v39 + v29) & 4) != 0) {
                    // 0x331c
                    v35 = 10 * v36 + 0xffffffd0 + (0x100000000000000 * v39 >> 56);
                    v36 = v35 & 0xffffffff;
                    v5 = v36;
                    v37 = *(char *)v31;
                    result2 = v11;
                    if (v37 == 0) {
                        // break (via goto) -> 0x3260
                        goto lab_0x3260_3;
                    }
                    // 0x3336
                    v38 = v31 + 1;
                    v39 = v37;
                    v31 = v38;
                }
                // 0x3342
                v32 = v35;
                v33 = v39;
                v34 = v38;
            }
            int64_t v40 = v34;
            int64_t v41 = v33; // 0x3344
            int64_t v42 = v40; // 0x3344
            if (v33 == 42) {
                uint32_t v43 = v32; // 0x3878
                if (v43 < 48) {
                    // 0x387f
                    v5 = *(int64_t *)(v13 + 16) + (int64_t)v43;
                    *args = v43 + 8;
                } else {
                    int64_t v44 = *v14; // 0x38d3
                    v5 = v44;
                    *v14 = v44 + 8;
                }
                unsigned char v45 = *(char *)v40; // 0x388a
                result2 = v11;
                if (v45 == 0) {
                    // break -> 0x3260
                    break;
                }
                // 0x389c
                v41 = v45;
                v42 = v40 + 1;
            }
            int64_t v46 = v42;
            int64_t v47 = v41; // 0x3352
            int64_t v48 = v46; // 0x3352
            if ((char)v41 == 46) {
                char v49 = *(char *)v46; // 0x3408
                result2 = v11;
                if (v49 == 0) {
                    // break -> 0x3260
                    break;
                }
                int64_t v50 = v46;
                unsigned char v51 = v49;
                int64_t v52 = v50 + 1;
                int64_t v53 = v51;
                while ((*(char *)(2 * v53 + v29) & 4) != 0) {
                    char v54 = *(char *)v52; // 0x343c
                    result2 = v11;
                    if (v54 == 0) {
                        // break (via goto) -> 0x3260
                        goto lab_0x3260_3;
                    }
                    v50 = v52;
                    v51 = v54;
                    v52 = v50 + 1;
                    v53 = v51;
                }
                // 0x37c0
                v47 = v53;
                v48 = v52;
                if (v51 == 42) {
                    uint32_t v55 = *(int32_t *)&v5; // 0x37c8
                    if (v55 < 48) {
                        // 0x37d3
                        *args = v55 + 8;
                    } else {
                        // 0x38a4
                        *v14 = *v14 + 8;
                    }
                    unsigned char v56 = *(char *)v52; // 0x37de
                    result2 = v11;
                    if (v56 == 0) {
                        // break -> 0x3260
                        break;
                    }
                    // 0x37f1
                    v47 = v56;
                    v48 = v50 + 2;
                }
            }
            int64_t v57 = v48;
            int64_t v58 = v47;
            switch ((char)v58) {
                case 104: {
                    char v59 = *(char *)v57; // 0x385e
                    v10 = v59;
                    v9 = v57 + 1;
                    if (v59 == 0) {
                        // break -> 0x3260
                        break;
                    }
                    goto lab_0x3816;
                }
                case 108: {
                    char v60 = *(char *)v57; // 0x37f9
                    int64_t v61 = v57 + 1;
                    result2 = v11;
                    v10 = v60;
                    v9 = v61;
                    switch (v60) {
                        case 108: {
                            char v62 = *(char *)v61; // 0x38b5
                            v10 = v62;
                            v9 = v57 + 2;
                            if (v62 == 0) {
                                // break -> 0x3260
                                break;
                            }
                            goto lab_0x3816;
                        }
                        case 0: {
                            goto lab_0x3260_3;
                        }
                        default: {
                            goto lab_0x3816;
                        }
                    }
                }
                case 76: {
                    unsigned char v63 = *(char *)v57; // 0x382f
                    if (v63 == 0) {
                        // break -> 0x3260
                        break;
                    }
                    int64_t v64 = (int64_t)v63 + 0xffffffdb; // 0x383b
                    v8 = v57 + 1;
                    if ((char)v64 < 84) {
                        int32_t v65 = *(int32_t *)((4 * v64 & 1020) + (int64_t)&g14); // 0x3854
                        return (int64_t)v65 + (int64_t)&g14;
                    }
                    goto lab_0x34a3;
                }
                default: {
                    // 0x3370
                    v8 = v57;
                    if ((char)(v58 + 0xffffffdb) < 84) {
                        // 0x337b
                        int64_t v66; // 0x3370
                        int32_t v67 = *(int32_t *)((4 * v66 & 1020) + (int64_t)&g12); // 0x3385
                        return (int64_t)v67 + (int64_t)&g12;
                    }
                    goto lab_0x34a3;
                }
            }
        }
    }
  lab_0x3260_3:
    // 0x3260
    if (maxlen == 0) {
        // 0x3273
        return result2;
    }
    uint64_t v68 = maxlen - 1;
    if (v68 > result2) {
        // 0x326e
        *(char *)(result2 + v3) = 0;
        // 0x3273
        return result2;
    }
    // 0x3288
    *(char *)(v68 + v3) = 0;
    return result2;
  lab_0x34a3:;
    unsigned char v69 = *(char *)v8; // 0x34a3
    int64_t v70 = v8 + 1; // 0x34a7
    v5 = v70;
    result2 = v11;
    v6 = v70;
    v7 = v69;
    v12 = v11;
    if (v69 == 0) {
        // break -> 0x3260
        goto lab_0x3260_3;
    }
    goto lab_0x32ae;
  lab_0x3816:;
    int64_t v71 = (int64_t)v10 + 0xffffffdb; // 0x3816
    v8 = v9;
    if ((char)v71 < 84) {
        int32_t v72 = *(int32_t *)((4 * v71 & 1020) + (int64_t)&g13); // 0x3824
        return (int64_t)v72 + (int64_t)&g13;
    }
    goto lab_0x34a3;
}

// Address range: 0x3b4d - 0x3b58
int64_t function_3b4d(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3b4d
    int64_t v1; // 0x3b4d
    return v1 & 0xffffffff;
}

// Address range: 0x3b58 - 0x3b63
int64_t function_3b58(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3b58
    int64_t v1; // 0x3b58
    return v1 & 0xffffffff;
}

// Address range: 0x3b63 - 0x3b6e
int64_t function_3b63(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3b63
    int64_t v1; // 0x3b63
    return v1 & 0xffffffff;
}

// Address range: 0x3b6e - 0x3b75
int64_t function_3b6e(void) {
    // 0x3b6e
    int64_t v1; // 0x3b6e
    return v1 & 0xffffffff;
}

// Address range: 0x3b75 - 0x3b80
int64_t function_3b75(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3b75
    int64_t v1; // 0x3b75
    return v1 & 0xffffffff;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x3b80 - 0x3c8c
// Line range:    751 - 769
int32_t libmin_printf(char * fmt, ...) {
    // 0x3b80
    int64_t v1; // 0x3b80
    if ((char)v1 != 0) {
        // 0x3bbc
        int128_t v2; // 0x3b80
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
    }
    int64_t v3 = 8; // bp-1248, 0x3c26
    char v4; // bp-1224, 0x3b80
    dopr(&v4, (int64_t)&g4, fmt, (int32_t *)&v3);
    if (v4 == 0) {
        // 0x3c80
        return 0;
    }
    int64_t v5 = &v4;
    libtarg_putc(v4);
    int64_t v6 = v5 + 1; // 0x3c69
    char v7 = *(char *)v6; // 0x3c69
    while (v7 != 0) {
        // 0x3c60
        v5 = v6;
        libtarg_putc(v7);
        v6 = v5 + 1;
        v7 = *(char *)v6;
    }
    // 0x3c76
    int64_t v8; // bp+1225, 0x3b80
    return v5 + (int64_t)&v8;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x3c90 - 0x3d3b
// Line range:    772 - 782
int32_t libmin_snprintf(char * s, int64_t size, char * fmt, ...) {
    // 0x3c90
    int64_t v1; // 0x3c90
    if ((char)v1 != 0) {
        // 0x3cb6
        int128_t v2; // 0x3c90
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
    }
    int64_t v3 = 24; // bp-224, 0x3d0a
    dopr(s, size, fmt, (int32_t *)&v3);
    *(char *)((int64_t)s - 1 + size) = 0;
    return libmin_strlen(s);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_scalbn.c
// Address range: 0x3d40 - 0x3df4
// Line range:    5 - 34
float64_t libmin_scalbn(float64_t x, int32_t n) {
    int64_t v1 = n;
    int128_t v2 = (float32_t)x;
    if (n > (int32_t)&g3) {
        int128_t v3 = __asm_movsd_1(0x7fe0000000000000); // 0x3d4c
        int128_t v4 = __asm_mulsd(v2, v3); // 0x3d54
        int128_t v5 = v4; // 0x3d5e
        int64_t v6 = v1; // 0x3d5e
        if (n >= 2047) {
            // 0x3d60
            v5 = __asm_mulsd(v4, v3);
            int32_t v7 = n - 2046; // 0x3d6f
            int32_t v8 = v7 - (int32_t)&g3; // 0x3d6f
            v6 = v8 < 0 == ((v8 ^ v7) & (v7 ^ (int32_t)&g3)) < 0 == (v8 != 0) ? (int64_t)((int32_t)&g3 + 1023) : v1 + 0xfffffc01 & 0xffffffff;
        }
        // 0x3d7a
        return (int64_t)__asm_mulsd(v5, __asm_movq(0x10000000000000 * v6));
    }
    // 0x3d90
    int128_t v9; // 0x3dd4
    if (n > -1023) {
        // 0x3dc5
        v9 = __asm_mulsd(v2, __asm_movq(0x10000000000000 * v1 + 0x3ff0000000000000));
        return (int64_t)v9;
    }
    int128_t v10 = __asm_movsd_1(0x360000000000000); // 0x3d98
    int128_t v11 = __asm_mulsd(v2, v10); // 0x3da6
    if (n + (int32_t)&g1 > -1023) {
        int128_t v12 = __asm_movq(0x10000000000000 * (v1 + (int64_t)(int32_t)&g17)); // 0x3dea
        return (int64_t)__asm_mulsd(v11, v12);
    }
    int128_t v13 = __asm_mulsd(v11, v10); // 0x3db1
    int64_t v14 = v1 + (int64_t)(int32_t)&g16; // 0x3db5
    int32_t v15 = v14; // 0x3dc0
    int32_t v16 = v15 + 1022; // 0x3dc0
    int64_t v17 = v16 < 0 == ((v16 ^ v15) & (v15 ^ -0x80000000)) < 0 ? v14 & 0xffffffff : 0xfffffc02; // 0x3dc2
    // 0x3dc5
    v9 = __asm_mulsd(v13, __asm_movq(0x10000000000000 * v17 + 0x3ff0000000000000));
    return (int64_t)v9;
}

// Address range: 0x3e00 - 0x3ead
int128_t __sin(int64_t a1) {
    // 0x3e00
    int128_t v1; // 0x3e00
    int128_t v2 = __asm_movapd(v1); // 0x3e04
    int128_t v3 = __asm_movsd_1(0x3de5d93a5acfd57c); // 0x3e08
    int128_t v4 = __asm_movapd(v1); // 0x3e10
    int128_t v5 = __asm_mulsd(v2, v1); // 0x3e14
    int128_t v6 = __asm_mulsd(v3, v5); // 0x3e18
    int128_t v7 = __asm_mulsd(__asm_movapd(v5), v5); // 0x3e20
    int128_t v8 = __asm_subsd_4(v6, 0x3e5ae5e68a2b9ceb); // 0x3e24
    int128_t v9 = __asm_mulsd(v4, v5); // 0x3e2c
    int128_t v10 = __asm_mulsd(__asm_mulsd(v7, v5), v8); // 0x3e34
    int128_t v11 = __asm_mulsd(__asm_subsd_4(__asm_mulsd(__asm_movsd_1(0x3ec71de357b1fe7d), v5), 0x3f2a01a019c161d5), v5); // 0x3e4c
    int128_t v12 = __asm_addsd(v10, __asm_addsd_5(v11, 0x3f8111111110f8a6)); // 0x3e58
    if ((int32_t)a1 == 0) {
        // 0x3e60
        return __asm_addsd(v1, __asm_mulsd(__asm_subsd_4(__asm_mulsd(v12, v5), 0x3fc5555555555549), v9));
    }
    int128_t v13 = __asm_movsd_1((int64_t)g8); // 0x3e78
    int128_t v14 = __asm_mulsd(v12, v9); // 0x3e80
    int128_t v15 = __asm_mulsd_2(v9, 0x3fc5555555555549); // 0x3e84
    int128_t v16 = __asm_movapd(__asm_subsd(__asm_mulsd(v13, v1), v14)); // 0x3e94
    return __asm_subsd(v1, __asm_addsd(__asm_movapd(__asm_subsd(__asm_mulsd(v16, v5), v1)), v15));
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_sincos.c
// Address range: 0x3eb0 - 0x3f51
// Line range:    105 - 115
float64_t __cos(float64_t x, float64_t y) {
    int128_t v1 = (float32_t)x;
    int128_t v2 = __asm_movapd(v1); // 0x3eb4
    int128_t v3 = __asm_movapd(v1); // 0x3eb8
    int128_t v4 = __asm_movsd_1((int64_t)g8); // 0x3ebc
    int128_t v5 = __asm_movsd_1((int64_t)g7); // 0x3ec4
    int128_t v6 = __asm_mulsd(v2, v1); // 0x3ecc
    int128_t v7 = __asm_movsd_1(-0x425705164177c72c); // 0x3ed0
    int128_t v8 = __asm_mulsd(v3, (int128_t)(int32_t)(float32_t)y); // 0x3ed8
    int128_t v9 = __asm_movapd(v5); // 0x3edc
    int128_t v10 = __asm_mulsd(v7, v6); // 0x3ee0
    int128_t v11 = __asm_mulsd(__asm_movapd(v6), v6); // 0x3ee8
    int128_t v12 = __asm_addsd_5(v10, 0x3e21ee9ebdb4b1c4); // 0x3eec
    int128_t v13 = __asm_mulsd(v4, v6); // 0x3ef4
    int128_t v14 = __asm_subsd_4(__asm_mulsd(v12, v6), 0x3e927e4f809c52ad); // 0x3efc
    int128_t v15 = __asm_mulsd(v11, v11); // 0x3f04
    int128_t v16 = __asm_subsd(v9, v13); // 0x3f08
    int128_t v17 = __asm_subsd(v5, v16); // 0x3f0c
    int128_t v18 = __asm_mulsd(v14, v15); // 0x3f10
    int128_t v19 = __asm_mulsd(__asm_movsd_1(0x3efa01a019cb1590), v6); // 0x3f1c
    int128_t v20 = __asm_subsd(v17, v13); // 0x3f20
    int128_t v21 = __asm_mulsd(__asm_subsd_4(v19, 0x3f56c16c16c15177), v6); // 0x3f2c
    int128_t v22 = __asm_mulsd(__asm_addsd(v18, __asm_mulsd(__asm_addsd_5(v21, 0x3fa555555555554c), v6)), v6); // 0x3f40
    return (int64_t)__asm_addsd(__asm_addsd(__asm_subsd(v22, v8), v20), v16);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_sincos.c
// Address range: 0x3f60 - 0x4062
// Line range:    148 - 175
float64_t libmin_cos(float64_t x) {
    // 0x3f60
    int128_t v1; // 0x3f60
    int128_t v2 = v1;
    int128_t v3 = (float32_t)x;
    uint32_t v4 = (int32_t)(__asm_movq_3(v3) / 0x100000000) % 0x80000000;
    int64_t v5; // bp-24, 0x3f60
    if (v4 < 0x3fe921fc) {
        if (v4 >= 0x3e46a09e) {
            // 0x3fc0
            return __cos(x, (float64_t)(int64_t)__asm_pxor(v2, v2));
        }
        int64_t v6 = __asm_movsd(__asm_addsd_5(v3, 0x4770000000000000)); // 0x3f8c
        v5 = v6;
        __asm_movsd_1(v6);
        return (int64_t)__asm_movsd_1((int64_t)g7);
    }
    if (v4 >= 0x7ff00000) {
        // 0x3fb3
        return (int64_t)__asm_subsd(v3, v3);
    }
    uint32_t v7 = __rem_pio2(x, (float64_t *)&v5) % 4; // 0x3fd8
    int64_t v8; // 0x3f60
    switch (v7) {
        case 1: {
            // 0x4040
            __asm_movsd_1(v8);
            __asm_movsd_1(v5);
            int128_t v9 = __sin(1); // 0x4050
            // 0x3fb3
            return (int64_t)__asm_xorpd(v9, g11);
        }
        case 2: {
            int128_t v10 = __asm_movsd_1(v8); // 0x4008
            float64_t v11 = __cos((float64_t)(int64_t)__asm_movsd_1(v5), (float64_t)(int64_t)v10); // 0x4013
            int64_t result = __asm_xorpd((int128_t)(int32_t)(float32_t)v11, g11); // 0x4020
            // 0x3fb3
            return result;
        }
    }
    int128_t v12 = __asm_movsd_1(v8);
    int128_t v13 = __asm_movsd_1(v5);
    if (v7 == 0) {
        // 0x4028
        return __cos((float64_t)(int64_t)v13, (float64_t)(int64_t)v12);
    }
    // 0x3fe9
    return (int64_t)__sin(1);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_sincos.c
// Address range: 0x4070 - 0x41cc
// Line range:    214 - 241
float64_t libmin_sin(float64_t x) {
    int128_t v1 = (float32_t)x;
    uint32_t v2 = (int32_t)(__asm_movq_3(v1) / 0x100000000) % 0x80000000;
    if (v2 <= 0x3fe921fb) {
        if (v2 <= 0x3e4fffff) {
            int32_t v3 = __asm_cvttsd2si(v1); // 0x4094
            int128_t v4 = __asm_movapd(v1); // 0x409e
            if (v3 == 0) {
                // 0x411f
                return (int64_t)__asm_movapd(v4);
            }
        }
        int128_t v5 = __asm_movapd(v1); // 0x40a0
        int128_t v6 = __asm_movsd_1(0x3de5d93a5acfd57c); // 0x40a4
        int128_t v7 = __asm_mulsd(v5, v1); // 0x40ac
        int128_t v8 = __asm_mulsd(v6, v7); // 0x40b0
        int128_t v9 = __asm_mulsd(__asm_movapd(v7), v7); // 0x40b8
        int128_t v10 = __asm_mulsd(__asm_mulsd(v9, v7), __asm_subsd_4(v8, 0x3e5ae5e68a2b9ceb)); // 0x40c8
        int128_t v11 = __asm_subsd_4(__asm_mulsd(__asm_movsd_1(0x3ec71de357b1fe7d), v7), 0x3f2a01a019c161d5); // 0x40d8
        int128_t v12 = __asm_mulsd(__asm_addsd(v10, __asm_addsd_5(__asm_mulsd(v11, v7), 0x3f8111111110f8a6)), v7); // 0x40f0
        int128_t v13 = __asm_addsd(__asm_mulsd(__asm_subsd_4(v12, 0x3fc5555555555549), __asm_mulsd(v7, v1)), v1); // 0x4104
        return (int64_t)__asm_movapd(v13);
    }
    if (v2 >= 0x7ff00000) {
        // 0x411f
        return (int64_t)__asm_movapd(__asm_subsd(__asm_movapd(v1), v1));
    }
    // 0x4128
    int64_t v14; // bp-24, 0x4070
    uint32_t v15 = __rem_pio2(x, (float64_t *)&v14) % 4; // 0x4134
    int64_t v16; // 0x4070
    switch (v15) {
        case 1: {
            int128_t v17 = __asm_movsd_1(v16); // 0x41b8
            return __cos((float64_t)(int64_t)__asm_movsd_1(v14), (float64_t)(int64_t)v17);
        }
        case 2: {
            // 0x4170
            __asm_movsd_1(v16);
            __asm_movsd_1(v14);
            // 0x4161
            return (int64_t)__asm_movapd(__asm_xorpd(__asm_movapd(__sin(1)), g11));
        }
    }
    int128_t v18 = __asm_movsd_1(v16);
    int128_t v19 = __asm_movsd_1(v14);
    if (v15 == 0) {
        // 0x4198
        return (int64_t)__sin(1);
    }
    int128_t v20 = __asm_movapd((int128_t)(int32_t)(float32_t)__cos((float64_t)(int64_t)v19, (float64_t)(int64_t)v18)); // 0x4155
    // 0x4161
    return (int64_t)__asm_movapd(__asm_xorpd(v20, g11));
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_sqrt.c
// Address range: 0x41d0 - 0x43de
// Line range:    74 - 102
float64_t libmin_sqrt(float64_t x) {
    int128_t v1 = (float32_t)x;
    uint64_t v2 = __asm_movq_3(v1); // 0x41d4
    if (v2 % 0x7ff0000000000001 == 0x7ff0000000000000) {
        // 0x43b0
        return (int64_t)__asm_addsd(v1, __asm_mulsd(__asm_movapd(v1), v1));
    }
    int64_t v3 = v2 / 0x100000000; // 0x41d9
    int32_t v4 = __asm_movd(v1); // 0x41f1
    int64_t v5 = v4; // 0x41f1
    int32_t v6 = v3; // 0x41f5
    int64_t v7; // 0x41d0
    int64_t v8; // 0x41d0
    int64_t v9; // 0x41d0
    int64_t v10; // 0x41d0
    int64_t v11; // 0x41d0
    int64_t v12; // 0x41d0
    int64_t v13; // 0x41d0
    int64_t v14; // 0x41d0
    int64_t v15; // 0x41d0
    int64_t v16; // 0x41d0
    if (v6 < 1) {
        // 0x42e0
        if ((v4 || (v6 == 0 ? 0 : v6 ^ -0x80000000)) == 0) {
            // 0x43ac
            return x;
        }
        // 0x42ef
        if (v2 >= 0x100000000) {
            int128_t v17 = __asm_subsd(v1, v1); // 0x43bd
            return (int64_t)__asm_divsd_7(v17, v17);
        }
        int64_t v18 = 0;
        uint64_t v19 = v5;
        int64_t v20 = v18 + 0xffffffeb & 0xffffffff; // 0x4302
        int64_t v21 = 0x200000 * v19 & 0xffe00000; // 0x4305
        int64_t v22 = v19 / 2048 % 0x200000; // 0x4308
        while (v22 == 0) {
            // 0x4300
            v18 = v20;
            v19 = v21;
            v20 = v18 + 0xffffffeb & 0xffffffff;
            v21 = 0x200000 * v19 & 0xffe00000;
            v22 = v19 / 2048 % 0x200000;
        }
        // 0x430f
        v10 = v22;
        v13 = v21;
        v16 = v20;
        if ((int32_t)v19 <= -1) {
            // 0x433c
            v7 = v18 + 0xffffffec & 0xffffffff;
            v8 = v21;
            v14 = v21;
            v11 = v22;
            goto lab_dec_label_pc_unknown;
        } else {
            goto lab_0x431a;
        }
    } else {
        // 0x41fd
        v9 = v3;
        v12 = v5;
        v15 = v2 / 0x10000000000000;
        v10 = v3;
        v13 = v5;
        v16 = 0;
        if (v2 < 0x10000000000000) {
            goto lab_0x431a;
        } else {
            goto lab_0x420a;
        }
    }
  lab_0x4350:;
    // 0x4350
    int32_t v23; // 0x41d0
    int32_t v24 = v23; // 0x435e
    int64_t v25; // 0x41d0
    int64_t v26 = v25; // 0x435e
    int64_t v27; // 0x41d0
    int64_t v28 = v27 + (int64_t)((int32_t)v25 > -1); // 0x435e
    goto lab_0x42d1;
  lab_0x42d1:;
    int64_t v29 = v26; // 0x42d5
    int64_t v30 = v28; // 0x42d5
    int64_t v31; // 0x41d0
    int64_t v32; // 0x41d0
    int64_t v33 = v32 - v27 + (int64_t)(v24 > (int32_t)v31) & 0xffffffff; // 0x42d5
    goto lab_0x42a0;
  lab_0x42a8:;
    // 0x42a8
    int64_t v40; // 0x41d0
    int64_t v42 = v40;
    int64_t v35; // 0x41d0
    int64_t v43 = 2 * v35; // 0x42ac
    int64_t v36; // 0x41d0
    int64_t v44 = 2 * v36; // 0x42b1
    int32_t v45; // 0x41d0
    int32_t v46 = v45 - 1; // 0x42b4
    int64_t v47 = v43 & 0xfffffffe; // 0x42b8
    int64_t v48 = v44 & 0xfffffffe; // 0x42b8
    uint64_t v41; // 0x41d0
    int64_t v49 = v41 / 2; // 0x42b8
    int64_t v37; // 0x41d0
    int64_t v50 = v37; // 0x42b8
    int64_t v38; // 0x41d0
    int64_t v51 = v38; // 0x42b8
    v45 = v46;
    int64_t v52 = v42; // 0x42b8
    if (v46 == 0) {
        // break -> 0x4368
        goto lab_0x4368;
    }
    goto lab_0x42be;
  lab_0x42a0:;
    // 0x42a0
    int64_t v34; // 0x42be
    v35 = v31 - v34 & 0xffffffff;
    v36 = v33;
    v37 = v30 & 0xffffffff;
    v38 = v29;
    int64_t v39; // 0x41d0
    v40 = v39 + v41 & 0xffffffff;
    goto lab_0x42a8;
  lab_0x431a:;
    int64_t v58 = 0;
    int64_t v59 = v10;
    int64_t v60 = 2 * v59 & 0xfffffffe; // 0x4320
    int64_t v61 = v58 + 1; // 0x4324
    while ((v59 & 0x80000) == 0) {
        // 0x4320
        v58 = v61 & 0xffffffff;
        v59 = v60;
        v60 = 2 * v59 & 0xfffffffe;
        v61 = v58 + 1;
    }
    uint32_t v62 = (int32_t)v61 % 32; // 0x4337
    uint32_t v63 = (int32_t)v13;
    int64_t v64 = v62 == 0 ? v13 : (int64_t)(v63 << v62);
    uint32_t v65 = (31 - (int32_t)v58) % 32;
    int64_t v66 = v16 - v58 & 0xffffffff; // 0x433f
    v7 = v66;
    v8 = v13 & 0xffffffff;
    v14 = v64;
    v11 = v60;
    int64_t v67 = v66; // 0x41d0
    int64_t v68 = v64; // 0x41d0
    int64_t v69 = v60; // 0x41d0
    int64_t v70 = v63 >> v65; // 0x41d0
    if (v65 == 0) {
        goto lab_dec_label_pc_unknown;
    } else {
        goto lab_dec_label_pc_unknown_2;
    }
  lab_0x420a:;
    uint64_t v71 = v15;
    int64_t v72 = v12;
    int64_t v73 = v9 % 0x100000 | 0x100000; // 0x4210
    int64_t v74 = v73; // 0x421f
    int64_t v75 = v72; // 0x421f
    if (v71 % 2 == 0) {
        // 0x4221
        v74 = 2 * v73 | (int64_t)(v72 < 0);
        v75 = 2 * v72 & 0xfffffffe;
    }
    int64_t v76 = 0; // 0x4247
    int64_t v77 = 0;
    uint64_t v78 = 0x200000;
    int64_t v79 = 2 * v74 & 0xfffffffe | (int64_t)(v75 < 0);
    int64_t v80 = v76 + v78; // 0x4250
    int64_t v81 = v79; // 0x4255
    int64_t v82 = v77; // 0x4255
    int64_t v83 = v76; // 0x4255
    if (v79 >= (v80 & 0xffffffff)) {
        // 0x4257
        v81 = v79 - v80 & 0xffffffff;
        v82 = v77 + v78 & 0xffffffff;
        v83 = v80 + v78 & 0xffffffff;
    }
    int64_t v84 = v82;
    int64_t v85 = 2 * (2 * v75 & 0xfffffffe) & 0xfffffffc; // 0x4262
    int64_t v86 = 2 * v81 & 0xfffffffe;
    int32_t v87 = 21; // 0x426a
    int64_t v88 = v85; // 0x426e
    int64_t v89 = v78 / 2; // 0x426e
    v76 = v83;
    int32_t v90 = v87; // 0x426e
    v47 = v85;
    v48 = v86;
    v49 = 0x80000000;
    v50 = v83;
    v51 = 0;
    v45 = 32;
    v52 = 0;
    while (v87 != 0) {
        // 0x4250
        v77 = v84;
        v78 = v89;
        v79 = v86;
        v80 = v76 + v78;
        v81 = v79;
        v82 = v77;
        v83 = v76;
        if (v79 >= (v80 & 0xffffffff)) {
            // 0x4257
            v81 = v79 - v80 & 0xffffffff;
            v82 = v77 + v78 & 0xffffffff;
            v83 = v80 + v78 & 0xffffffff;
        }
        // 0x425e
        v84 = v82;
        v85 = 2 * v88 & 0xfffffffc;
        v86 = 2 * v81 & 0xfffffffe;
        v87 = v90 - 1;
        v88 = v85;
        v89 = v78 / 2;
        v76 = v83;
        v90 = v87;
        v47 = v85;
        v48 = v86;
        v49 = 0x80000000;
        v50 = v83;
        v51 = 0;
        v45 = 32;
        v52 = 0;
    }
    while (true) {
      lab_0x42be:
        // 0x42be
        v39 = v52;
        int64_t v53 = v51;
        v27 = v50;
        v41 = v49;
        v32 = v48;
        v31 = v47;
        v34 = v53 + v41;
        if (v32 > v27) {
            int64_t v54 = v34 + v41 & 0xffffffff; // 0x42c6
            int32_t v55 = v34;
            v24 = v55;
            v26 = v54;
            v28 = v27;
            v23 = v55;
            v25 = v54;
            if (v55 < 0) {
                goto lab_0x4350;
            } else {
                goto lab_0x42d1;
            }
        } else {
            // 0x4280
            v35 = v31;
            v36 = v32;
            v37 = v27;
            v38 = v53;
            v40 = v39;
            if ((int32_t)v32 != (int32_t)v27) {
                goto lab_0x42a8;
            } else {
                int32_t v56 = v34;
                if (v56 > (int32_t)v31) {
                    goto lab_0x42a8;
                } else {
                    int64_t v57 = v34 + v41 & 0xffffffff; // 0x4286
                    v29 = v57;
                    v30 = v27;
                    v33 = 0;
                    v23 = v56;
                    v25 = v57;
                    if (v56 < 0) {
                        goto lab_0x4350;
                    } else {
                        goto lab_0x42a0;
                    }
                }
            }
        }
    }
  lab_0x4368:;
    int64_t v91 = v42; // 0x436a
    int64_t v92; // 0x41d0
    int64_t v93; // 0x438c
    int128_t v94; // 0x43a6
    if ((int32_t)(v44 || v43) != 0) {
        if ((int32_t)v42 == -1) {
            // 0x437c
            v92 = 0;
            uint64_t v95 = v84 + 1 & 0xffffffff;
            v93 = v95 % 2 != 0 ? v92 | 0x80000000 : v92;
            v94 = __asm_movq(0x100000000 * ((0x80000 * v71 + 0xe0080000 & 0xfff00000) + 0x3fe00000 + (int64_t)((int32_t)v95 >> 1)) | v93);
            return (int64_t)v94;
        }
        // 0x4372
        v91 = v42 + 1 & 0xffffffff;
    }
    // 0x437c
    v92 = v91 / 2 % 0x80000000;
    v93 = v84 % 2 != 0 ? v92 | 0x80000000 : v92;
    v94 = __asm_movq(0x100000000 * ((0x80000 * v71 + 0xe0080000 & 0xfff00000) + 0x3fe00000 + (int64_t)((int32_t)v84 >> 1)) | v93);
    return (int64_t)v94;
  lab_dec_label_pc_unknown:
    v67 = v7;
    v68 = v14;
    v69 = v11;
    v70 = v8;
    goto lab_dec_label_pc_unknown_2;
  lab_dec_label_pc_unknown_2:
    v9 = v70 | v69;
    v12 = v68;
    v15 = v67;
    goto lab_0x420a;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strcmp.c
// Address range: 0x43e0 - 0x4431
// Line range:    5 - 8
int32_t libmin_strcmp(char * l, char * r) {
    uint64_t v1 = (int64_t)r;
    uint64_t v2 = (int64_t)l;
    int64_t v3 = v2 % 256; // 0x43e4
    int64_t v4 = v1 % 256; // 0x43e7
    if ((char)v2 != (char)v1) {
        // 0x442e
        return (int32_t)v3 - (int32_t)v4;
    }
    int64_t v5 = 1; // 0x43f1
    int64_t v6 = v4;
    int64_t result = v3;
    while (result != 0) {
        if (v6 == 0) {
            // 0x4420
            return result;
        }
        unsigned char v7 = *(char *)(v5 + v2); // 0x43fc
        int64_t v8 = v7; // 0x43fc
        unsigned char v9 = *(char *)(v5 + v1); // 0x4404
        int64_t v10 = v9; // 0x4404
        v5++;
        int64_t v11 = v8; // 0x440b
        int64_t v12 = v10; // 0x440b
        if (v7 != v9) {
            // 0x442e
            return (int32_t)v11 - (int32_t)v12;
        }
        v6 = v10;
        result = v8;
    }
    // 0x4411
    return -(int32_t)v6;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strlen.c
// Address range: 0x4440 - 0x446b
// Line range:    5 - 15
int64_t libmin_strlen(char * str) {
    int64_t v1 = (int64_t)str;
    if (str == NULL || (char)v1 == 0) {
        // 0x4468
        return 0;
    }
    int64_t v2 = v1; // 0x4447
    v2++;
    while (*(char *)v2 != 0) {
        // 0x4458
        v2++;
    }
    // 0x4461
    return v2 - v1;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_success.c
// Address range: 0x4470 - 0x4479
// Line range:    5 - 7
void libmin_success(void) {
    // 0x4470
    libtarg_success();
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_rempio2.c
// Address range: 0x4480 - 0x4e62
// Line range:    264 - 393
int32_t __rem_pio2_large(float64_t * x, float64_t * y, uint32_t e0, int32_t nx, int32_t prec) {
    float64_t fq[20]; // bp-384, 0x4480
    int32_t iq[20]; // bp-624, 0x4480
    int32_t v1[20]; // 0x44b1
    // 0x4480
    int128_t v2; // 0x4480
    int128_t v3 = v2;
    int64_t v4 = e0;
    v1[0] = prec;
    iq = v1;
    int32_t v5 = *(int32_t *)(4 * (int64_t)prec + (int64_t)&init_jk); // 0x44b5
    int32_t v6 = 0; // 0x44bc
    int64_t v7 = 0xffffffe8; // 0x44bc
    if (e0 >= 0xffffffec) {
        int64_t v8 = v4 + 0xfffffffd; // 0x44c2
        v6 = (int32_t)(0x2aaaaaab * (0x100000000 * v8 >> 32) / 0x400000000) - ((int32_t)v8 >> 31);
        v7 = -24 * v6 - 24;
    }
    // 0x44eb
    int32_t v9; // bp-696, 0x4480
    int64_t v10 = &v9; // 0x4498
    uint32_t v11 = nx - 1; // 0x44ad
    int32_t v12 = v5 + v11; // 0x44f9
    int128_t v13; // 0x4480
    if (v12 < 0) {
        // 0x4e49
        v13 = __asm_pxor(v3, v3);
    } else {
        int32_t v14 = v6 - v11; // 0x44f6
        int64_t v15 = v14; // 0x4502
        int128_t v16 = __asm_pxor(v3, v3); // 0x4504
        int64_t v17 = v10 + 160 - (0x100000000 * (int64_t)v14 >> 29); // 0x451d
        int128_t v18 = __asm_movapd(v16); // 0x4528
        int128_t v19 = v18; // 0x452e
        if ((int32_t)v15 >= 0) {
            // 0x4530
            __asm_pxor(v18, v18);
            v19 = __asm_cvtsi2sd(*(int32_t *)(4 * v15 + (int64_t)&ipio2));
        }
        // 0x4539
        *(int64_t *)(v17 + 8 * v15) = __asm_movsd(v19);
        int64_t v20 = v15 + 1; // 0x453e
        v13 = v16;
        while (v20 != (int64_t)v12 + 1 + v15) {
            int64_t v21 = v20;
            v18 = __asm_movapd(v16);
            v19 = v18;
            if ((int32_t)v21 >= 0) {
                // 0x4530
                __asm_pxor(v18, v18);
                v19 = __asm_cvtsi2sd(*(int32_t *)(4 * v21 + (int64_t)&ipio2));
            }
            // 0x4539
            *(int64_t *)(v17 + 8 * v21) = __asm_movsd(v19);
            v20 = v21 + 1;
            v13 = v16;
        }
    }
    int64_t v22 = (int64_t)x;
    int64_t v23 = v11; // 0x44ad
    int64_t v24; // 0x4480
    int64_t v25; // 0x4480
    int64_t v26; // bp-216, 0x4480
    if (v5 < 0) {
        // 0x4547
        v24 = &v26;
        v25 = 8 * v23;
    } else {
        int64_t v27 = &v26;
        int64_t v28 = 8 * v23;
        int64_t v29 = v27; // 0x456f
        int128_t v30 = __asm_movapd(v13); // 0x4577
        int64_t v31; // 0x4480
        int64_t v32; // bp-536, 0x4480
        int128_t v33; // 0x4590
        int64_t v34; // 0x4598
        int128_t v35; // 0x45a0
        if (v11 >= 0) {
            // 0x4579
            v35 = __asm_movapd(v13);
            v34 = v22;
            v31 = (0x100000000 * v23 >> 29) + (int64_t)&v32;
            v33 = __asm_movsd_1(*(int64_t *)v34);
            v34 += 8;
            v35 = __asm_addsd(v35, __asm_mulsd_2(v33, *(int64_t *)v31));
            v31 -= 8;
            v30 = v35;
            while (v34 != v22 + 8 + v28) {
                // 0x4590
                v33 = __asm_movsd_1(*(int64_t *)v34);
                v34 += 8;
                v35 = __asm_addsd(v35, __asm_mulsd_2(v33, *(int64_t *)v31));
                v31 -= 8;
                v30 = v35;
            }
        }
        int64_t v36 = v23 + 1; // 0x45a9
        *(int64_t *)v29 = __asm_movsd(v30);
        v29 += 8;
        v24 = v27;
        v25 = v28;
        while (v5 + nx != (int32_t)v36) {
            int64_t v37 = v36 & 0xffffffff;
            v30 = __asm_movapd(v13);
            if (v11 >= 0) {
                // 0x4579
                v35 = __asm_movapd(v13);
                v34 = v22;
                v31 = (0x100000000 * v37 >> 29) + (int64_t)&v32;
                v33 = __asm_movsd_1(*(int64_t *)v34);
                v34 += 8;
                v35 = __asm_addsd(v35, __asm_mulsd_2(v33, *(int64_t *)v31));
                v31 -= 8;
                v30 = v35;
                while (v34 != v22 + 8 + v28) {
                    // 0x4590
                    v33 = __asm_movsd_1(*(int64_t *)v34);
                    v34 += 8;
                    v35 = __asm_addsd(v35, __asm_mulsd_2(v33, *(int64_t *)v31));
                    v31 -= 8;
                    v30 = v35;
                }
            }
            // 0x45a9
            v36 = v37 + 1;
            *(int64_t *)v29 = __asm_movsd(v30);
            v29 += 8;
            v24 = v27;
            v25 = v28;
        }
    }
    uint64_t v38 = (int64_t)v5; // 0x44b5
    int64_t v39 = v7 + v4; // 0x44eb
    int64_t v40 = v39 & 0xffffffff; // 0x44eb
    int32_t v41; // bp-616, 0x4480
    int64_t v42 = &v41; // 0x45b9
    int64_t v43 = 0x100000000 * v38;
    int128_t v44 = __asm_movsd_1(0x3e70000000000000); // 0x45cb
    int32_t v45 = v39;
    int64_t v46 = v10 + 84;
    int64_t v47 = v10 + 80;
    uint32_t v48 = (24 - v45) % 32;
    uint32_t v49 = (23 - v45) % 32;
    int64_t v50 = g7;
    int128_t v51 = v13; // 0x45f3
    int128_t v52 = __asm_movsd_1(0x4170000000000000); // 0x45f3
    int128_t v53 = v44; // 0x45f3
    int64_t v54 = v38; // 0x45f3
    char v55; // 0x4480
    int64_t v56; // 0x4480
    int64_t v57; // 0x4480
    int64_t v58; // 0x4480
    int64_t v59; // 0x4480
    int64_t v60; // 0x4480
    int64_t v61; // 0x4480
    int64_t v62; // 0x4480
    int64_t v63; // 0x4480
    int32_t v64; // 0x4605
    int128_t v65; // 0x46bb
    int128_t v66; // 0x46cc
    int128_t v67; // 0x46dd
    int128_t v68; // 0x46e1
    int128_t v69; // 0x4480
    bool v70; // 0x4480
    while (true) {
      lab_0x45f8:
        // 0x45f8
        v59 = v54;
        v63 = 0x100000000 * v59;
        int64_t v71 = (v63 >> 29) + v10;
        int128_t v72 = __asm_movsd_1(*(int64_t *)(v71 + 480)); // 0x45fb
        v64 = v59;
        int64_t v73 = v72; // 0x4607
        if (v64 >= 1) {
            int64_t v74 = v71 + 472; // 0x461c
            int64_t v75 = v42 + 4; // 0x4624
            int128_t v76 = __asm_mulsd(__asm_movapd(v72), v53); // 0x462c
            int32_t v77 = __asm_cvttsd2si(v76); // 0x4630
            __asm_pxor(v76, v76);
            int128_t v78 = __asm_cvtsi2sd(v77); // 0x4638
            int128_t v79 = __asm_movapd(v78); // 0x463c
            int128_t v80 = __asm_addsd_5(v78, *(int64_t *)v74); // 0x4640
            int32_t v81 = __asm_cvttsd2si(__asm_subsd(v72, __asm_mulsd(v79, v52))); // 0x464d
            int128_t v82 = __asm_movapd(v80); // 0x4651
            *(int32_t *)v42 = v81;
            int128_t v83 = v82; // 0x465b
            v74 -= 8;
            while (v75 != (4 * v59 + 0x3fffffffc & 0x3fffffffc) + v46) {
                int64_t v84 = v75;
                v75 = v84 + 4;
                v76 = __asm_mulsd(__asm_movapd(v83), v53);
                v77 = __asm_cvttsd2si(v76);
                __asm_pxor(v76, v76);
                v78 = __asm_cvtsi2sd(v77);
                v79 = __asm_movapd(v78);
                v80 = __asm_addsd_5(v78, *(int64_t *)v74);
                v81 = __asm_cvttsd2si(__asm_subsd(v83, __asm_mulsd(v79, v52)));
                v82 = __asm_movapd(v80);
                *(int32_t *)v84 = v81;
                v83 = v82;
                v74 -= 8;
            }
            // 0x465d
            v73 = v82;
        }
        int64_t v85 = __asm_movsd(v51); // 0x466f
        int128_t v86 = __asm_movapd((int128_t)(int32_t)(float32_t)libmin_scalbn((float64_t)v73, v45)); // 0x467a
        int128_t v87 = __asm_movsd_1(0x3fc0000000000000); // 0x467e
        v9 = __asm_movsd(v86);
        float64_t v88 = libmin_floor((float64_t)(int64_t)__asm_mulsd(v87, v86)); // 0x468f
        int128_t v89 = __asm_movsd_1((int64_t)v9); // 0x4694
        int128_t v90 = __asm_mulsd_2((int128_t)(int32_t)(float32_t)v88, 0x4020000000000000); // 0x469e
        v51 = __asm_movsd_1(v85);
        v65 = __asm_movq(0x3e70000000000000);
        v66 = __asm_movq(0x4170000000000000);
        int128_t v91 = __asm_subsd(v89, v90); // 0x46d1
        __asm_pxor(v90, v90);
        int32_t v92 = __asm_cvttsd2si(v91); // 0x46d9
        v67 = __asm_cvtsi2sd(v92);
        v68 = __asm_subsd(v91, v67);
        if (v45 < 1) {
            int64_t v93 = v92; // 0x46d9
            if (v45 != 0) {
                // 0x49bc
                __asm_comisd(v68, g8);
                int64_t v94 = v93 + 1 & 0xffffffff; // 0x49cd
                v62 = v94;
                v58 = 2;
                if (v64 >= 0 == (v64 != 0)) {
                    goto lab_0x486e;
                } else {
                    // 0x49de
                    v55 = llvm_ctpop_i8((char)v59);
                    v70 = v64 == 0;
                    v69 = __asm_movapd(__asm_subsd(__asm_movsd_1(v50), v68));
                    v60 = v94;
                    v56 = 2;
                    goto lab_0x4720_2;
                }
            } else {
                int32_t v95 = *(int32_t *)((v63 - 0x100000000 >> 30) + v47); // 0x4851
                uint32_t v96 = v95 >> 23; // 0x4856
                int64_t v97 = v96; // 0x4856
                v55 = llvm_ctpop_i8((char)v96);
                v70 = v96 == 0;
                v69 = v68;
                v60 = v93;
                v56 = v97;
                v61 = v93;
                v57 = v97;
                if (v95 < 0 || v96 == 0) {
                    goto lab_0x4720_2;
                } else {
                    goto lab_0x4863;
                }
            }
        } else {
            int32_t * v98 = (int32_t *)((v63 - 0x100000000 >> 30) + v47); // 0x46f4
            uint32_t v99 = *v98; // 0x46f4
            int32_t v100 = v99 >> v48;
            int64_t v101 = v100 + v92; // 0x4700
            int64_t v102 = (int64_t)v99 - (int64_t)(v100 << v48); // 0x4709
            int32_t v103 = v102; // 0x470f
            *v98 = v103;
            int64_t v104 = v49 == 0 ? v102 & 0xffffffff : (int64_t)(v103 >> v49);
            int32_t v105 = v104; // 0x4717
            v55 = llvm_ctpop_i8((char)v104);
            v70 = v105 == 0;
            v69 = v68;
            v60 = v101;
            v56 = v104;
            v61 = v101;
            v57 = v104;
            if (v105 >= 0 == (v105 != 0)) {
                goto lab_0x4863;
            } else {
                goto lab_0x4720_2;
            }
        }
    }
  lab_0x4720:;
    // 0x4720
    int128_t v106; // 0x4480
    int128_t v107; // 0x4480
    __asm_ucomisd(v106, v107);
    int64_t v108; // 0x4480
    int64_t v109 = v108; // 0x4480
    int64_t v110; // 0x4480
    int64_t v111 = v110; // 0x4480
    int64_t v112; // 0x4480
    int64_t v113 = v112; // 0x4480
    int128_t v114 = v107; // 0x4480
    int128_t v115 = v106; // 0x4480
    goto lab_0x4cb3_2;
  lab_0x48f7:;
    // 0x48f7
    int64_t v247; // 0x4480
    v108 = v247;
    int64_t v248; // 0x4480
    int64_t v249 = v248;
    if (v45 >= 1) {
        if (v45 == 1) {
            int32_t * v250 = (int32_t *)((v63 - 0x100000000 >> 30) + v47); // 0x4c8d
            *v250 = *v250 % 0x800000;
        } else {
            if (v45 == 2) {
                int32_t * v251 = (int32_t *)((v63 - 0x100000000 >> 30) + v47); // 0x4912
                *v251 = *v251 % 0x400000;
            }
        }
    }
    // 0x491a
    v106 = v68;
    v107 = v51;
    v112 = v249;
    v110 = v40;
    if ((int32_t)v108 != 2) {
        goto lab_0x4720;
    }
    int128_t v252 = __asm_subsd(__asm_movsd_1(v50), v68); // 0x492c
    int128_t v253 = __asm_movapd(v252); // 0x4930
    int32_t v254; // 0x4480
    v55 = llvm_ctpop_i8((char)v254);
    v70 = true;
    v69 = v253;
    v60 = v249;
    v56 = v108;
    if (v254 != 0) {
        int128_t v255 = __asm_movq(v50); // 0x494f
        v9 = v45;
        int64_t v256 = __asm_movsd(v51); // 0x495d
        int64_t v257 = __asm_movsd(v252); // 0x4963
        float64_t v258 = libmin_scalbn((float64_t)(int64_t)v255, v45); // 0x4969
        int128_t v259 = __asm_movsd_1(0x100000000 * v257 >> 32); // 0x4975
        __asm_movq(0x4170000000000000);
        int128_t v260 = __asm_subsd(v259, (int128_t)(int32_t)(float32_t)v258); // 0x4989
        int128_t v261 = __asm_movsd_1(v256); // 0x499d
        __asm_movq(0x3e70000000000000);
        v106 = v260;
        v107 = v261;
        v112 = v249 & 0xffffffff;
        v110 = v9;
        goto lab_0x4720;
    }
    goto lab_0x4720_2;
  lab_0x4863:;
    int64_t v322 = v61 + 1 & 0xffffffff; // 0x4863
    v62 = v322;
    v58 = v57;
    v254 = 0;
    v248 = v322;
    v247 = v57;
    if (v64 < 1) {
        goto lab_0x48f7;
    } else {
        goto lab_0x486e;
    }
  lab_0x4720_2:;
    int64_t v262 = v56;
    int64_t v245 = v60;
    __asm_ucomisd(v69, v51);
    v109 = v262;
    v111 = v40;
    v113 = v245;
    v114 = v51;
    v115 = v69;
    if (v55 % 2 == 0 || !v70) {
        // break -> 0x4cb3
        goto lab_0x4cb3_2;
    }
    int64_t v263 = v59 + 0xffffffff; // 0x4730
    int64_t v264 = v263 & 0xffffffff; // 0x4730
    int64_t v135; // 0x4480
    int64_t v242; // 0x4480
    int64_t v136; // 0x4480
    int64_t v244; // 0x4480
    int64_t v133; // 0x4480
    int64_t v134; // 0x4480
    int64_t v240; // 0x4480
    int64_t v132; // 0x4480
    int64_t v246; // 0x4a05
    int128_t v131; // 0x4480
    if (v264 >= v38) {
        int64_t v265 = v63 >> 30; // 0x473b
        int64_t v266 = v265 + v42;
        int64_t v267 = v266; // 0x475b
        v267 -= 4;
        int32_t v268 = *(int32_t *)v267; // 0x4760
        int32_t v269 = v268; // 0x476a
        while (v267 != v10 + 76 + v265 - (4 * (v59 + (v38 ^ 0xffffffff)) & 0x3fffffffc)) {
            // 0x4760
            v267 -= 4;
            v268 = *(int32_t *)v267 | v269;
            v269 = v268;
        }
        if (v268 != 0) {
            // 0x4a02
            v246 = v262 & 0xffffffff;
            int64_t v270 = v39 + 0xffffffe8 & 0xffffffff; // 0x4a08
            v131 = v51;
            v132 = v245;
            v133 = v270;
            v134 = v42;
            v135 = v246;
            v136 = v264;
            if (*(int32_t *)((0x100000000 * v263 >> 30) + v47) != 0) {
                goto lab_0x4a32;
            } else {
                // 0x4a1a
                v240 = v266 - 4;
                v244 = v270;
                v242 = v264;
                goto lab_0x4a1f;
            }
        }
    }
    // 0x4774
    int64_t v271; // 0x4480
    int64_t v272; // 0x4480
    if (*(int32_t *)((v43 - 0x100000000 >> 30) + v47) != 0) {
        int64_t v273 = v59 + 1; // 0x49f8
        v271 = v273;
        v272 = v273;
    } else {
        int64_t v274 = (v43 >> 30) + v42;
        int64_t v275 = 2; // 0x4797
        int64_t v276 = v274 - 4; // 0x479c
        int64_t v277 = v275; // 0x479c
        while (*(int32_t *)(v274 - 8) == 0) {
            // 0x4790
            v274 = v276;
            v275 = v277 + 1 & 0xffffffff;
            v276 = v274 - 4;
            v277 = v275;
        }
        // 0x479e
        v271 = v59 + 1;
        v272 = v275 + v59;
    }
    int64_t v278 = v63 >> 32; // 0x45f8
    v54 = v272 & 0xffffffff;
    int64_t v279 = 0x100000000 * v271 >> 32; // 0x47a3
    int64_t v280 = v279 + (int64_t)v11; // 0x47b6
    int64_t v281 = (int64_t)(v6 + (int32_t)v271) - v278; // 0x47c1
    int128_t v282 = v67; // 0x47db
    int64_t v283 = v279; // 0x47db
    int64_t v284 = v10 + 160 + 8 * v280; // 0x47db
    while (true) {
      lab_0x47e0:;
        int64_t v285 = v284;
        int64_t v286 = v283;
        int128_t v287 = v282;
        __asm_pxor(v287, v287);
        int32_t v288 = *(int32_t *)(4 * (v281 + v286) + (int64_t)&ipio2 - 4); // 0x47e4
        int128_t v289 = __asm_cvtsi2sd(v288); // 0x47e4
        *(int64_t *)(v285 + 8 * (v280 - (v278 + (int64_t)nx))) = __asm_movsd(v289);
        int128_t v290 = __asm_movapd(v51);
        int128_t v291 = v289; // 0x47f3
        int128_t v292 = v290; // 0x47f3
        if (v11 >= 0) {
            int128_t v293 = __asm_mulsd_2(v289, (int64_t)*x); // 0x4810
            int128_t v294 = __asm_addsd(v290, v293); // 0x4818
            int128_t v295 = v294; // 0x481f
            int64_t v296 = v285; // 0x481f
            v291 = v293;
            v292 = v294;
            if (v11 != 0) {
                int64_t v297 = v296 - 8;
                int128_t v298 = __asm_movsd_1(*(int64_t *)v297); // 0x4808
                int64_t v299 = v22 + 8; // 0x480c
                int128_t v300 = __asm_mulsd_2(v298, *(int64_t *)v299); // 0x4810
                int128_t v301 = __asm_addsd(v295, v300); // 0x4818
                v295 = v301;
                v296 = v297;
                int64_t v302 = v299; // 0x481f
                v291 = v300;
                v292 = v301;
                while (v299 != v25 + v22) {
                    // 0x4808
                    v297 = v296 - 8;
                    v298 = __asm_movsd_1(*(int64_t *)v297);
                    v299 = v302 + 8;
                    v300 = __asm_mulsd_2(v298, *(int64_t *)v299);
                    v301 = __asm_addsd(v295, v300);
                    v295 = v301;
                    v296 = v297;
                    v302 = v299;
                    v291 = v300;
                    v292 = v301;
                }
            }
        }
        // 0x4821
        *(int64_t *)(8 * v286 + v24) = __asm_movsd(v292);
        v52 = v66;
        v53 = v65;
        v282 = v291;
        v283 = v286 + 1;
        v284 = v285 + 8;
        if (v54 > v286) {
            goto lab_0x47e0;
        } else {
            goto lab_0x45f8;
        }
    }
  lab_0x486e:;
    int64_t v303 = v58;
    int64_t v304 = v62;
    int32_t v305 = v41; // 0x4874
    int64_t v306 = 1; // 0x4874
    int64_t v307 = 0; // 0x4874
    if (v41 != 0) {
        goto lab_0x48b0;
    } else {
        // 0x487a
        v254 = v41;
        v248 = v304;
        v247 = v303;
        if (v59 == 1) {
            goto lab_0x48f7;
        } else {
            // 0x487f
            int32_t v308; // bp-612, 0x4480
            v305 = v308;
            v306 = 2;
            v307 = 1;
            if (v308 != 0) {
                goto lab_0x48b0;
            } else {
                // 0x4894
                v254 = v308;
                v248 = v304;
                v247 = v303;
                if (v64 == 2) {
                    goto lab_0x48f7;
                } else {
                    int64_t v309 = (int64_t)&v308 + 4;
                    int32_t v310 = *(int32_t *)v309; // 0x489c
                    int64_t v311 = 0x200000000 >> 32; // 0x489e
                    int64_t v312 = v311 + 1; // 0x48a1
                    int64_t v313 = v312 & 0xffffffff; // 0x48a1
                    v305 = v310;
                    v306 = v313;
                    v307 = v311;
                    while (v310 == 0) {
                        int64_t v314 = v309; // 0x489a
                        int64_t v315 = v313; // 0x489a
                        v254 = 0;
                        v248 = v304;
                        v247 = v303;
                        if (v64 == (int32_t)v312) {
                            goto lab_0x48f7;
                        }
                        v309 = v314 + 4;
                        v310 = *(int32_t *)v309;
                        v311 = 0x100000000 * v315 >> 32;
                        v312 = v311 + 1;
                        v313 = v312 & 0xffffffff;
                        v305 = v310;
                        v306 = v313;
                        v307 = v311;
                    }
                    goto lab_0x48b0;
                }
            }
        }
    }
  lab_0x48b0:;
    uint64_t v316 = v306;
    *(int32_t *)(4 * v307 + v47) = 0x1000000 - v305;
    v254 = 1;
    v248 = v304;
    v247 = v303;
    if (v59 > v316) {
        int64_t v317 = 0x100000000 * v316;
        int64_t v318 = v317 >> 30; // 0x48c7
        int64_t v319 = v318 + v42;
        int64_t v320 = v319 + 4; // 0x48e4
        *(int32_t *)v319 = 0xffffff - *(int32_t *)(v318 + v47);
        int64_t v321 = v320; // 0x48f0
        v254 = 1;
        v248 = v304;
        v247 = v303;
        while (v320 != 4 * (((v316 ^ 0xffffffff) + v59 & 0xffffffff) + (v317 >> 32)) + v46) {
            // 0x48e2
            v319 = v320;
            v320 = v319 + 4;
            *(int32_t *)v319 = 0xffffff - *(int32_t *)v321;
            v321 = v320;
            v254 = 1;
            v248 = v304;
            v247 = v303;
        }
    }
    goto lab_0x48f7;
  lab_0x4cb3_2:;
    int128_t v116 = v115;
    int32_t v117 = v111; // 0x4cb3
    int128_t v118 = __asm_movapd(v116); // 0x4cb6
    v9 = v117;
    int64_t v119 = __asm_movsd(v114); // 0x4cd1
    int128_t v120 = (float32_t)libmin_scalbn((float64_t)(int64_t)v118, -v117); // 0x4cd7
    uint32_t v121 = v9; // 0x4cdc
    int64_t v122 = 0x100000000 * v42 >> 32; // 0x4ce0
    int128_t v123 = __asm_movsd_1(0x4170000000000000); // 0x4ce5
    int64_t v124 = v109 & 0xffffffff; // 0x4ced
    int64_t v125 = v113 & 0xffffffff; // 0x4cf2
    int128_t v126 = __asm_movsd_1(v119); // 0x4cf6
    __asm_comisd(v120, v123);
    if (v117 == 0) {
        int128_t v127 = __asm_movsd_1(0x3e70000000000000); // 0x4d06
        __asm_pxor(v116, v116);
        int64_t v128 = v59 + 1; // 0x4d12
        int32_t v129 = __asm_cvttsd2si(__asm_mulsd(v127, v120)); // 0x4d1e
        int32_t v130 = __asm_cvttsd2si(__asm_subsd(v120, __asm_mulsd(__asm_cvtsi2sd(v129), v123))); // 0x4d2e
        *(int32_t *)((v63 >> 30) + v47) = v130;
        *(int32_t *)((0x100000000 * v128 >> 30) + v47) = v129;
        v131 = v126;
        v132 = v125;
        v133 = v121 + 24;
        v134 = v122;
        v135 = v124;
        v136 = v128 & 0xffffffff;
    } else {
        // 0x4dbc
        *(int32_t *)((v63 >> 30) + v47) = __asm_cvttsd2si(v120);
        v131 = v126;
        v132 = v125;
        v133 = v121;
        v134 = v122;
        v135 = v124;
        v136 = v59;
    }
    goto lab_0x4a32;
  lab_0x4a32:;
    uint64_t v137 = v136;
    int64_t v138 = v132;
    int128_t v139 = __asm_movq(v50); // 0x4a45
    v9 = v135;
    int64_t v140 = __asm_movsd(v131); // 0x4a4e
    int128_t v141 = (float32_t)libmin_scalbn((float64_t)(int64_t)v139, (int32_t)v133); // 0x4a59
    int32_t v142 = v9; // 0x4a63
    int128_t v143 = __asm_movsd_1(v140); // 0x4a6b
    int128_t v144 = __asm_movapd(v141); // 0x4a71
    int32_t v145 = v137; // 0x4a75
    int64_t v146; // bp-376, 0x4480
    int128_t v147; // 0x4480
    int128_t v148; // 0x4480
    int128_t v149; // 0x4480
    if (v145 < 0) {
        int32_t v150 = iq[0]; // 0x4e2d
        if (v150 > 2) {
            // 0x4e52
            v149 = v143;
            if (v150 != 3) {
                // 0x4b7d
                return (int32_t)v138 % 8;
            }
            goto lab_0x4c54;
        } else {
            // 0x4e36
            if (v150 >= 0 == (v150 != 0)) {
                goto lab_0x4d5c;
            } else {
                // 0x4e3e
                v148 = v143;
                if (v150 != 0) {
                    // 0x4b7d
                    return (int32_t)v138 % 8;
                }
                goto lab_0x4b67;
            }
        }
    } else {
        int64_t v151 = 0x100000000 * v137;
        int64_t v152 = v151 >> 32; // 0x4a7e
        int128_t v153 = __asm_movsd_1(0x3e70000000000000); // 0x4a81
        int64_t v154 = 0x100000000 * v134 >> 32; // 0x4a89
        int128_t v155 = v144; // 0x4a99
        int64_t v156 = v152; // 0x4a99
        int128_t v157 = v141;
        __asm_pxor(v157, v157);
        int128_t v158 = __asm_mulsd(__asm_cvtsi2sd(*(int32_t *)(4 * v156 + v154)), v155); // 0x4aaa
        v155 = __asm_mulsd(v155, v153);
        *(int64_t *)(8 * v156 + v24) = __asm_movsd(v158);
        v156--;
        while ((int32_t)v156 >= 0) {
            // 0x4aa0
            v157 = v158;
            __asm_pxor(v157, v157);
            v158 = __asm_mulsd(__asm_cvtsi2sd(*(int32_t *)(4 * v156 + v154)), v155);
            v155 = __asm_mulsd(v155, v153);
            *(int64_t *)(8 * v156 + v24) = __asm_movsd(v158);
            v156--;
        }
        int64_t v159 = v151 >> 29; // 0x4abf
        int128_t v160 = __asm_movsd_1(0x3ff921fb40000000); // 0x4ac7
        int64_t v161 = &v146; // 0x4ad1
        int64_t v162 = 0;
        int64_t v163 = v159 + v24;
        int128_t v164 = __asm_movapd(v160); // 0x4aed
        int128_t v165 = __asm_movapd(v143); // 0x4af1
        int128_t v166 = v165; // 0x4af8
        int128_t v167; // 0x4480
        int64_t v168; // 0x4480
        int64_t v169; // 0x4480
        int64_t v170; // 0x4b0d
        int128_t v171; // 0x4b13
        int128_t v172; // 0x4b04
        int64_t v173; // 0x4b09
        int64_t v174; // 0x4b0d
        int128_t v175; // 0x4b13
        if (v5 >= 0) {
            // 0x4b0d
            v170 = v163 - 8;
            v171 = __asm_addsd(v165, __asm_mulsd_2(v164, *(int64_t *)v163));
            v167 = v171;
            v166 = v171;
            if (v5 != 0 && v162 >= 1) {
                v169 = 1;
                v172 = __asm_movsd_1(*(int64_t *)(8 + (int64_t)&PIo2));
                v173 = v169 + 1;
                v174 = 8 * v173;
                v175 = __asm_addsd(v167, __asm_mulsd_2(v172, *(int64_t *)(v170 + v174)));
                v167 = v175;
                v168 = v174;
                v166 = v175;
                while (v169 < v38 && v169 < v162) {
                    // 0x4b04
                    v169 = v173;
                    v172 = __asm_movsd_1(*(int64_t *)(v168 + (int64_t)&PIo2));
                    v173 = v169 + 1;
                    v174 = 8 * v173;
                    v175 = __asm_addsd(v167, __asm_mulsd_2(v172, *(int64_t *)(v170 + v174)));
                    v167 = v175;
                    v168 = v174;
                    v166 = v175;
                }
            }
        }
        int64_t v176 = __asm_movsd(v166); // 0x4b1c
        int64_t v177 = 8 * v162; // 0x4b1c
        int64_t v178 = v177 + v161; // 0x4b1c
        *(int64_t *)v178 = v176;
        while (v162 != v152) {
            // 0x4b2f
            v162++;
            v163 -= 8;
            v164 = __asm_movapd(v160);
            v165 = __asm_movapd(v143);
            v166 = v165;
            if (v5 >= 0) {
                // 0x4b0d
                v170 = v163 - 8;
                v171 = __asm_addsd(v165, __asm_mulsd_2(v164, *(int64_t *)v163));
                v167 = v171;
                v166 = v171;
                if (v5 != 0 && v162 >= 1) {
                    v169 = 1;
                    v172 = __asm_movsd_1(*(int64_t *)(8 + (int64_t)&PIo2));
                    v173 = v169 + 1;
                    v174 = 8 * v173;
                    v175 = __asm_addsd(v167, __asm_mulsd_2(v172, *(int64_t *)(v170 + v174)));
                    v167 = v175;
                    v168 = v174;
                    v166 = v175;
                    while (v169 < v38 && v169 < v162) {
                        // 0x4b04
                        v169 = v173;
                        v172 = __asm_movsd_1(*(int64_t *)(v168 + (int64_t)&PIo2));
                        v173 = v169 + 1;
                        v174 = 8 * v173;
                        v175 = __asm_addsd(v167, __asm_mulsd_2(v172, *(int64_t *)(v170 + v174)));
                        v167 = v175;
                        v168 = v174;
                        v166 = v175;
                    }
                }
            }
            // 0x4b1c
            v176 = __asm_movsd(v166);
            v177 = 8 * v162;
            v178 = v177 + v161;
            *(int64_t *)v178 = v176;
        }
        int32_t v179 = iq[0]; // 0x4b34
        if (v179 > 2) {
            if (v179 != 3) {
                // 0x4b7d
                return (int32_t)v138 % 8;
            }
            // 0x4b9b
            v149 = v143;
            if (v137 != 0) {
                int64_t * v180 = (int64_t *)(v159 + v10 + 320); // 0x4bb0
                int128_t v181 = __asm_movsd_1(*v180); // 0x4bb0
                int64_t v182 = v159 + v161; // 0x4bc2
                int64_t v183 = 8 * v137; // 0x4bac
                int64_t v184 = v159 + (int64_t)&fq; // 0x4bca
                int128_t v185 = v181; // 0x4bcd
                int64_t v186 = v182 - 8; // 0x4bd0
                int64_t * v187 = (int64_t *)v186; // 0x4bd0
                int128_t v188 = __asm_movsd_1(*v187); // 0x4bd0
                int128_t v189 = __asm_movapd(v185); // 0x4bd5
                v185 = __asm_addsd(v185, v188);
                int128_t v190 = __asm_subsd(v188, v185); // 0x4be1
                *v187 = __asm_movsd(v185);
                *(int64_t *)v182 = __asm_movsd(__asm_addsd(v190, v189));
                while (v186 != v184 - (v183 + 0x7fffffff8 & 0x7fffffff8)) {
                    int64_t v191 = v186;
                    v186 = v191 - 8;
                    v187 = (int64_t *)v186;
                    v188 = __asm_movsd_1(*v187);
                    v189 = __asm_movapd(v185);
                    v185 = __asm_addsd(v185, v188);
                    v190 = __asm_subsd(v188, v185);
                    *v187 = __asm_movsd(v185);
                    *(int64_t *)v191 = __asm_movsd(__asm_addsd(v190, v189));
                }
                // 0x4bf7
                v149 = v143;
                if (v145 >= 2) {
                    int64_t v192 = v184 - (v183 + 0x7fffffff0 & 0x7fffffff8); // 0x4c19
                    int128_t v193 = __asm_movsd_1(*v180); // 0x4c1c
                    int64_t v194 = v182 - 8; // 0x4c1f
                    int64_t * v195 = (int64_t *)v194; // 0x4c1f
                    int128_t v196 = __asm_movsd_1(*v195); // 0x4c1f
                    int128_t v197 = __asm_movapd(v193); // 0x4c24
                    v193 = __asm_addsd(v193, v196);
                    int128_t v198 = __asm_subsd(v196, v193); // 0x4c30
                    *v195 = __asm_movsd(v193);
                    *(int64_t *)v182 = __asm_movsd(__asm_addsd(v198, v197));
                    int128_t v199 = v143; // 0x4c44
                    int64_t v200 = v182; // 0x4c44
                    while (v194 != v192) {
                        int64_t v201 = v194;
                        v194 = v201 - 8;
                        v195 = (int64_t *)v194;
                        v196 = __asm_movsd_1(*v195);
                        v197 = __asm_movapd(v193);
                        v193 = __asm_addsd(v193, v196);
                        v198 = __asm_subsd(v196, v193);
                        *v195 = __asm_movsd(v193);
                        *(int64_t *)v201 = __asm_movsd(__asm_addsd(v198, v197));
                        v199 = v143;
                        v200 = v182;
                    }
                    int128_t v202 = __asm_addsd_5(v199, *(int64_t *)v200); // 0x4c46
                    int64_t v203 = v200 - 8; // 0x4c4b
                    v199 = v202;
                    v200 = v203;
                    v149 = v202;
                    while (v203 != v192) {
                        // 0x4c46
                        v202 = __asm_addsd_5(v199, *(int64_t *)v200);
                        v203 = v200 - 8;
                        v199 = v202;
                        v200 = v203;
                        v149 = v202;
                    }
                }
            }
            goto lab_0x4c54;
        } else {
            if (v179 >= 0 == (v179 != 0)) {
                int64_t v204 = (int64_t)&fq; // 0x4d47
                int128_t v205 = __asm_addsd_5(v143, v176); // 0x4d4f
                int64_t v206 = v178 - 8; // 0x4d53
                int64_t v207 = v206; // 0x4d5a
                int128_t v208 = v205; // 0x4d5a
                v147 = v205;
                if (v206 != v204) {
                    int128_t v209 = __asm_addsd_5(v208, *(int64_t *)v207); // 0x4d4f
                    int64_t v210 = v207 - 8; // 0x4d53
                    v207 = v210;
                    v208 = v209;
                    v147 = v209;
                    while (v210 != v204) {
                        // 0x4d4f
                        v209 = __asm_addsd_5(v208, *(int64_t *)v207);
                        v210 = v207 - 8;
                        v207 = v210;
                        v208 = v209;
                        v147 = v209;
                    }
                }
                goto lab_0x4d5c;
            } else {
                if (v179 != 0) {
                    // 0x4b7d
                    return (int32_t)v138 % 8;
                }
                int128_t v211 = v143; // 0x4b56
                int64_t v212 = v159 + v161; // 0x4b56
                v211 = __asm_addsd_5(v211, *(int64_t *)v212);
                v212 -= 8;
                v148 = v211;
                while (v159 + v10 + 312 - v177 != v212) {
                    // 0x4b59
                    v211 = __asm_addsd_5(v211, *(int64_t *)v212);
                    v212 -= 8;
                    v148 = v211;
                }
                goto lab_0x4b67;
            }
        }
    }
  lab_0x4c54:;
    int128_t v213 = __asm_movsd_1(v146); // 0x4c54
    int64_t v214; // 0x4480
    int128_t v215 = __asm_movsd_1(v214); // 0x4c5d
    if (v142 != 0) {
        int128_t v216 = __asm_movq((int64_t)g11); // 0x4dcd
        int64_t v217 = (int64_t)y; // 0x4dd5
        int128_t v218 = __asm_xorpd(v213, v216); // 0x4dda
        int128_t v219 = __asm_xorpd(v215, v216); // 0x4dde
        int128_t v220 = __asm_xorpd(v149, v216); // 0x4de2
        *y = (float64_t)__asm_movsd(v218);
        *(int64_t *)(v217 + 8) = __asm_movsd(v219);
        *(int64_t *)(v217 + 16) = __asm_movsd(v220);
    } else {
        int64_t v221 = (int64_t)y; // 0x4c6f
        *y = (float64_t)__asm_movsd(v213);
        *(int64_t *)(v221 + 8) = __asm_movsd(v215);
        *(int64_t *)(v221 + 16) = __asm_movsd(v149);
    }
    // 0x4b7d
    return (int32_t)v138 % 8;
  lab_0x4d5c:;
    int128_t v222 = v147;
    int128_t v223; // 0x4df9
    int128_t v224; // 0x4e1b
    if (v142 != 0) {
        // 0x4df9
        v223 = __asm_movq((int64_t)g11);
        *y = (float64_t)__asm_movsd(__asm_xorpd(__asm_movapd(v222), v223));
        v224 = __asm_subsd(__asm_movsd_1(v146), v222);
        if (v145 >= 0 == (v145 != 0)) {
            goto lab_0x4d80;
        } else {
            goto lab_0x4da9;
        }
    } else {
        int128_t v225 = __asm_subsd(__asm_movsd_1(v146), v222); // 0x4d73
        *y = (float64_t)__asm_movsd(v222);
        if (v145 < 1) {
            // 0x4dad
            *(int64_t *)((int64_t)y + 8) = __asm_movsd(v225);
            // 0x4b7d
            return (int32_t)v138 % 8;
        }
        goto lab_0x4d80;
    }
  lab_0x4b67:;
    int128_t v226 = v148; // 0x4b6a
    if (v142 != 0) {
        // 0x4b6c
        v226 = __asm_xorpd(v148, g11);
    }
    // 0x4b74
    *y = (float64_t)__asm_movsd(v226);
    // 0x4b7d
    return (int32_t)v138 % 8;
  lab_0x4d80:;
    // 0x4d80
    int128_t v227; // 0x4d8d
    while (true) {
        // 0x4d8d
        int64_t v228; // 0x4480
        uint64_t v229 = v228;
        int128_t v230; // 0x4480
        int128_t v231 = v230;
        int64_t v232; // 0x4d85
        int64_t v233 = *(int64_t *)(8 * v229 + v232); // 0x4d8d
        v227 = __asm_addsd_5(v231, v233);
        v230 = v227;
        v228 = v229 + 1;
        if (v137 <= v229) {
            // break -> 0x4d9c
            break;
        }
    }
    int128_t v234 = v227; // 0x4d9f
    if (v142 == 0) {
        int128_t v235 = v234;
        int64_t v236 = __asm_movsd(v235); // 0x4db2
        *(int64_t *)((int64_t)y + 8) = v236;
        // 0x4b7d
        return (int32_t)v138 % 8;
    }
    int128_t v237 = g11; // 0x4da1
    int128_t v238 = __asm_movq((int64_t)v237); // 0x4da1
    goto lab_0x4da9;
  lab_0x4da9:
    // 0x4dad
    *(int64_t *)((int64_t)y + 8) = __asm_movsd(__asm_xorpd(v224, v223));
    // 0x4b7d
    return (int32_t)v138 % 8;
  lab_0x4a1f:;
    int64_t v239 = v240 - 4; // 0x4a1f
    int64_t v241 = v242 + 0xffffffff & 0xffffffff; // 0x4a26
    int64_t v243 = v244 + 0xffffffe8 & 0xffffffff; // 0x4a2a
    v240 = v239;
    v244 = v243;
    v242 = v241;
    v131 = v51;
    v132 = v245;
    v133 = v243;
    v134 = v42;
    v135 = v246;
    v136 = v241;
    if (*(int32_t *)v239 == 0) {
        goto lab_0x4a1f;
    } else {
        goto lab_0x4a32;
    }
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_rempio2.c
// Address range: 0x4e70 - 0x536e
// Line range:    475 - 541
int32_t __rem_pio2(float64_t x, float64_t * y) {
    float64_t tx[3]; // bp-64, 0x4e70
    // 0x4e70
    int128_t v1; // 0x4e70
    int128_t v2 = v1;
    int128_t v3 = v1;
    int64_t v4 = (int64_t)y;
    int128_t v5 = (float32_t)x;
    uint64_t v6 = __asm_movq_3(v5) / 0x100000000; // 0x4e80
    int64_t v7 = __asm_movq_3(v5) >> 63; // 0x4e87
    uint64_t v8 = v6 % 0x80000000; // 0x4e8d
    uint32_t v9 = (int32_t)v8; // 0x4e97
    bool v10; // 0x4e70
    int32_t result; // 0x4e70
    bool v11; // 0x4e70
    if (v9 < 0x400f6a7b) {
        uint32_t v12 = (int32_t)v6 % 0x100000; // 0x4e9f
        v10 = v12 < 0x921fb;
        v11 = true;
        if (v12 != 0x921fb) {
            if (v9 >= 0x4002d97d) {
                if (v7 == 0) {
                    int128_t v13 = __asm_subsd_4(v5, 0x400921fb54400000); // 0x5049
                    int128_t v14 = __asm_movsd_1(0x3de0b4611a626331); // 0x5051
                    int128_t v15 = __asm_subsd(__asm_movapd(v13), v14); // 0x5062
                    int128_t v16 = __asm_subsd(v13, v15); // 0x5066
                    *y = (float64_t)__asm_movsd(v15);
                    *(int64_t *)(v4 + 8) = __asm_movsd(__asm_subsd(v16, v14));
                    return 2;
                }
                int128_t v17 = __asm_addsd_5(v5, 0x400921fb54400000); // 0x52a2
                int128_t v18 = __asm_movsd_1(0x3de0b4611a626331); // 0x52aa
                int128_t v19 = __asm_addsd(__asm_movapd(v17), v18); // 0x52bb
                int128_t v20 = __asm_subsd(v17, v19); // 0x52bf
                *y = (float64_t)__asm_movsd(v19);
                *(int64_t *)(v4 + 8) = __asm_movsd(__asm_addsd(v20, v18));
                // 0x4ef4
                return -2;
            }
            if (v7 != 0) {
                int128_t v21 = __asm_addsd_5(v5, 0x3ff921fb54400000); // 0x52d5
                int128_t v22 = __asm_movsd_1(0x3dd0b4611a626331); // 0x52dd
                int128_t v23 = __asm_addsd(__asm_movapd(v21), v22); // 0x52ee
                int128_t v24 = __asm_subsd(v21, v23); // 0x52f2
                *y = (float64_t)__asm_movsd(v23);
                *(int64_t *)(v4 + 8) = __asm_movsd(__asm_addsd(v24, v22));
                result = -1;
            } else {
                int128_t v25 = __asm_subsd_4(v5, 0x3ff921fb54400000); // 0x4ec6
                int128_t v26 = __asm_movsd_1(0x3dd0b4611a626331); // 0x4ece
                int128_t v27 = __asm_subsd(__asm_movapd(v25), v26); // 0x4edf
                int128_t v28 = __asm_subsd(v25, v27); // 0x4ee3
                *y = (float64_t)__asm_movsd(v27);
                *(int64_t *)(v4 + 8) = __asm_movsd(__asm_subsd(v28, v26));
                result = 1;
            }
            // 0x4ef4
            return result;
        }
    } else {
        if (v9 < 0x401c463c) {
            if (v9 < 0x4015fdbd) {
                // 0x4f14
                v10 = v9 < 0x4012d97c;
                v11 = true;
                if (v9 != 0x4012d97c) {
                    if (v7 == 0) {
                        int128_t v29 = __asm_subsd_4(v5, 0x4012d97c7f300000); // 0x4f29
                        int128_t v30 = __asm_movsd_1(0x3de90e91a79394ca); // 0x4f31
                        int128_t v31 = __asm_subsd(__asm_movapd(v29), v30); // 0x4f42
                        int128_t v32 = __asm_subsd(v29, v31); // 0x4f46
                        *y = (float64_t)__asm_movsd(v31);
                        *(int64_t *)(v4 + 8) = __asm_movsd(__asm_subsd(v32, v30));
                        return 3;
                    }
                    int128_t v33 = __asm_addsd_5(v5, 0x4012d97c7f300000); // 0x5308
                    int128_t v34 = __asm_movsd_1(0x3de90e91a79394ca); // 0x5310
                    int128_t v35 = __asm_addsd(__asm_movapd(v33), v34); // 0x5321
                    int128_t v36 = __asm_subsd(v33, v35); // 0x5325
                    *y = (float64_t)__asm_movsd(v35);
                    *(int64_t *)(v4 + 8) = __asm_movsd(__asm_addsd(v36, v34));
                    // 0x4ef4
                    return -3;
                }
            } else {
                // 0x5080
                v10 = v9 < 0x401921fb;
                v11 = true;
                if (v9 != 0x401921fb) {
                    if (v7 == 0) {
                        int128_t v37 = __asm_subsd_4(v5, 0x401921fb54400000); // 0x5091
                        int128_t v38 = __asm_movsd_1(0x3df0b4611a626331); // 0x5099
                        int128_t v39 = __asm_subsd(__asm_movapd(v37), v38); // 0x50aa
                        int128_t v40 = __asm_subsd(v37, v39); // 0x50ae
                        *y = (float64_t)__asm_movsd(v39);
                        *(int64_t *)(v4 + 8) = __asm_movsd(__asm_subsd(v40, v38));
                        return 4;
                    }
                    int128_t v41 = __asm_addsd_5(v5, 0x401921fb54400000); // 0x533b
                    int128_t v42 = __asm_movsd_1(0x3df0b4611a626331); // 0x5343
                    int128_t v43 = __asm_addsd(__asm_movapd(v41), v42); // 0x5354
                    int128_t v44 = __asm_subsd(v41, v43); // 0x5358
                    *y = (float64_t)__asm_movsd(v43);
                    *(int64_t *)(v4 + 8) = __asm_movsd(__asm_addsd(v44, v42));
                    // 0x4ef4
                    return -4;
                }
            }
        } else {
            // 0x4f60
            v10 = v9 < 0x413921fa;
            v11 = v9 == 0x413921fa;
            if (v9 >= 0x413921fb) {
                if (v9 >= 0x7ff00000) {
                    int128_t v45 = __asm_subsd(v5, v5); // 0x5240
                    *(int64_t *)(v4 + 8) = __asm_movsd(v45);
                    *y = (float64_t)__asm_movsd(v45);
                    // 0x4ef4
                    return 0;
                }
                int64_t v46 = __asm_movq_3(v5); // 0x4f78
                __asm_pxor(v3, v3);
                __asm_pxor(v2, v2);
                int128_t v47 = __asm_movq(v46 & 0xfffffffffffff | 0x4160000000000000); // 0x4f9f
                int128_t v48 = __asm_cvtsi2sd(__asm_cvttsd2si(v47)); // 0x4fa8
                int128_t v49 = __asm_subsd(v47, v48); // 0x4fac
                int64_t v50 = __asm_movsd(v48); // bp-56, 0x4fb0
                int128_t v51 = __asm_movsd_1(0x4170000000000000); // 0x4fb6
                int128_t v52 = __asm_mulsd(v49, v51); // 0x4fbe
                int128_t v53 = __asm_cvtsi2sd(__asm_cvttsd2si(v52)); // 0x4fc6
                int128_t v54 = __asm_subsd(v52, v53); // 0x4fca
                __asm_movsd(v53);
                int128_t v55 = __asm_mulsd(v54, v51); // 0x4fd4
                __asm_ucomisd_6(v55, 0);
                __asm_movsd(v55);
                int64_t v56; // bp-72, 0x4e70
                int32_t v57 = __rem_pio2_large((float64_t *)&v50, (float64_t *)&v56, v9 / 0x100000 - 1046, 3, 1); // 0x5014
                if (v7 != 0) {
                    int128_t v58 = __asm_movq((int64_t)g11); // 0x5268
                    *y = (float64_t)__asm_movsd(__asm_xorpd(__asm_movsd_1(v56), v58));
                    int128_t v59 = __asm_movsd_1(*(int64_t *)&tx); // 0x527f
                    *(int64_t *)(v4 + 8) = __asm_movsd(__asm_xorpd(v59, v58));
                    result = -v57;
                } else {
                    // 0x5022
                    *y = (float64_t)__asm_movsd(__asm_movsd_1(v56));
                    *(int64_t *)(v4 + 8) = __asm_movsd(__asm_movsd_1(*(int64_t *)&tx));
                    result = v57;
                }
                // 0x4ef4
                return result;
            }
        }
    }
    int128_t v60 = __asm_movsd_1(0x3fe45f306dc9c883); // 0x50d0
    int128_t v61 = __asm_movsd_1(0x4338000000000000); // 0x50d8
    int128_t v62 = __asm_movsd_1(0x3ff921fb54400000); // 0x50e0
    int128_t v63 = __asm_movsd_1(0x3dd0b4611a626331); // 0x50e8
    int128_t v64 = __asm_mulsd(v60, v5); // 0x50f0
    int128_t v65 = __asm_movsd_1(-0x4016de04abbbd2e8); // 0x50f4
    int128_t v66 = __asm_subsd(__asm_addsd(v64, v61), v61); // 0x5100
    int128_t v67 = __asm_movapd(v5); // 0x5104
    int128_t v68 = __asm_movapd(v66); // 0x5108
    int32_t v69 = __asm_cvttsd2si(v66); // 0x510c
    int128_t v70 = __asm_movapd(v66); // 0x5110
    int128_t v71 = __asm_mulsd(v68, v62); // 0x5114
    int128_t v72 = __asm_mulsd(v70, v63); // 0x5118
    int128_t v73 = __asm_subsd(v67, v71); // 0x511c
    int128_t v74 = __asm_subsd(__asm_movapd(v73), v72); // 0x5124
    __asm_comisd(v65, v74);
    int32_t result2; // 0x4e70
    int128_t v75; // 0x4e70
    int128_t v76; // 0x4e70
    int128_t v77; // 0x4e70
    int128_t v78; // 0x4e70
    if (v10 || v11) {
        // 0x5218
        __asm_comisd(v74, g15);
        v75 = v66;
        v76 = v73;
        v77 = v74;
        v78 = v72;
        result2 = v69;
    } else {
        int128_t v79 = __asm_subsd_4(v66, (int64_t)g7); // 0x5132
        int128_t v80 = __asm_mulsd(v62, v79); // 0x513d
        int128_t v81 = __asm_movapd(v5); // 0x5141
        int128_t v82 = __asm_mulsd(v63, v79); // 0x5145
        int128_t v83 = __asm_subsd(v81, v80); // 0x5149
        int128_t v84 = __asm_movapd(v82); // 0x514d
        int128_t v85 = __asm_movapd(v83); // 0x5151
        v75 = v79;
        v76 = v83;
        v77 = __asm_subsd(v85, v82);
        v78 = v84;
        result2 = v69 - 1;
    }
    uint64_t v86 = __asm_movq_3(v77); // 0x5159
    uint64_t v87 = v8 / 0x100000; // 0x515e
    int128_t v88 = v76; // 0x5172
    int128_t v89 = v77; // 0x5172
    int128_t v90 = v78; // 0x5172
    int128_t v91; // 0x4e70
    int128_t v92; // 0x4e70
    int128_t v93; // 0x4e70
    if ((int32_t)(v87 - v86 / 0x10000000000000 % 2048) < 17) {
        goto lab_0x51fa;
    } else {
        int128_t v94 = __asm_movsd_1(0x3dd0b4611a600000); // 0x5178
        int128_t v95 = __asm_movapd(v76); // 0x5180
        int128_t v96 = __asm_movsd_1(0x3ba3198a2e037073); // 0x5184
        int128_t v97 = __asm_mulsd(v94, v75); // 0x518c
        int128_t v98 = __asm_mulsd(v96, v75); // 0x5190
        int128_t v99 = __asm_subsd(v95, v97); // 0x5194
        int128_t v100 = __asm_subsd(__asm_subsd(v76, v99), v97); // 0x519c
        int128_t v101 = __asm_movapd(v99); // 0x51a0
        int128_t v102 = __asm_subsd(v98, v100); // 0x51a4
        int128_t v103 = __asm_subsd(v101, v102); // 0x51a8
        if ((int32_t)v87 - (int32_t)(__asm_movq_3(v103) / 0x10000000000000) % 2048 < 50) {
            // 0x5258
            *y = (float64_t)__asm_movsd(v103);
            v91 = __asm_movapd(v99);
            v92 = v103;
            v93 = v102;
            goto lab_0x51fe;
        } else {
            int128_t v104 = __asm_movsd_1(0x3ba3198a2e000000); // 0x51c6
            int128_t v105 = __asm_movapd(v99); // 0x51ce
            int128_t v106 = __asm_mulsd(v104, v75); // 0x51d2
            int128_t v107 = __asm_mulsd_2(v75, 0x397b839a252049c1); // 0x51d6
            v88 = __asm_subsd(v105, v106);
            int128_t v108 = __asm_movapd(v107); // 0x51e2
            int128_t v109 = __asm_subsd(__asm_subsd(v99, v88), v106); // 0x51ea
            int128_t v110 = __asm_movapd(v88); // 0x51ee
            v90 = __asm_subsd(v108, v109);
            v89 = __asm_subsd(v110, v90);
            goto lab_0x51fa;
        }
    }
  lab_0x51fa:
    // 0x51fa
    *y = (float64_t)__asm_movsd(v89);
    v91 = v88;
    v92 = v89;
    v93 = v90;
    goto lab_0x51fe;
  lab_0x51fe:;
    int64_t v111 = __asm_movsd(__asm_subsd(__asm_subsd(v91, v92), v93)); // 0x5206
    *(int64_t *)(v4 + 8) = v111;
    return result2;
}

// Address range: 0x5370 - 0x537d
int64_t _fini(void) {
    // 0x5370
    int64_t result; // 0x5370
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 53

