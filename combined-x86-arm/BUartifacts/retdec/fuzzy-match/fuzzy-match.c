//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;
typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int32_t _isctype(uint32_t c, int32_t mask);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t dopr(char * buffer, uint64_t maxlen, char * format, int32_t * args);
void fmtfp(char * buffer, int64_t * currlen, uint64_t maxlen, float128_t fvalue, int32_t min, uint32_t max, int32_t flags);
void fmtint(char * buffer, int64_t * currlen, uint64_t maxlen, int64_t value, int32_t base, int32_t min, int32_t max, uint32_t flags);
int64_t frame_dummy(void);
void function_2070(int64_t * d);
void function_2080(void);
int32_t function_2090(int32_t c, struct _IO_FILE * stream);
int64_t * function_20a0(int64_t delta);
void function_20b0(int32_t status);
int64_t function_374d(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3758(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_3763(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_376e(void);
int64_t function_3775(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int32_t fuzzy_match(char * pattern, char * str);
int32_t fuzzy_match_recurse(char * pattern, char * str, uint32_t score, int32_t first_char);
int32_t libmin_printf(char * fmt, ...);
int32_t libmin_snprintf(char * s, int64_t size, char * fmt, ...);
char * libmin_strcasestr(char * h, char * n);
int64_t libmin_strlen(char * str);
int32_t libmin_strncasecmp(char * _l, char * _r, int64_t n);
void libmin_success(void);
void libtarg_fail(int32_t code);
void libtarg_putc(char c);
char * libtarg_sbrk(int64_t inc);
void libtarg_success(void);
int64_t my_modf_isra_0(int64_t a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

char * entries[154] = {
    "Abomination",
    "Abusive Sergeant",
    "Acidic Swamp Ooze",
    "Acidmaw",
    "Acolyte of Pain",
    "Al'Akir the Windlord",
    "Alarm-o-Bot",
    "Aldor Peacekeeper",
    "Alexstrasza",
    "Alexstrasza's Champion",
    "Amani Berserker",
    "Ancestor's Call",
    "Ancestral Healing",
    "Ancestral Knowledge",
    "Ancestral Spirit",
    "Ancient Brewmaster",
    "Ancient Mage",
    "Ancient of Lore",
    "Ancient of War",
    "Ancient Shade",
    "Ancient Watcher",
    "Angry Chicken",
    "Anima Golem",
    "Animal Companion",
    "Animated Armor",
    "Annoy-o-Tron",
    "Anodized Robo Cub",
    "Antique Healbot",
    "Anub'ar Ambusher",
    "Anub'arak",
    "Anubisath Sentinel",
    "Anyfin Can Happen",
    "Arathi Weaponsmith",
    "Arcane Blast",
    "Arcane Explosion",
    "Arcane Golem",
    "Arcane Intellect",
    "Arcane Missiles",
    "Arcane Nullifier X-21",
    "Arcane Shot",
    "Arcanite Reaper",
    "Arch-Thief Rafaam",
    "Archmage",
    "Archmage Antonidas",
    "Argent Commander",
    "Argent Horserider",
    "Argent Lance",
    "Argent Protector",
    "Argent Squire",
    "Argent Watchman",
    "Armored Warhorse",
    "Armorsmith",
    "Assassin's Blade",
    "Assassinate",
    "Astral Communion",
    "Auchenai Soulpriest",
    "Avenge",
    "Avenging Wrath",
    "Aviana",
    "Axe Flinger",
    "Azure Drake",
    "Backstab",
    "Ball of Spiders",
    "Bane of Doom",
    "Baron Geddon",
    "Baron Rivendare",
    "Bash",
    "Battle Rage",
    "Bear Trap",
    "Beneath the Grounds",
    "Bestial Wrath",
    "Betrayal",
    "Big Game Hunter",
    "Bite",
    "Blackwing Corruptor",
    "Blackwing Technician",
    "Blade Flurry",
    "Blessed Champion",
    "Blessing of Kings",
    "Blessing of Might",
    "Blessing of Wisdom",
    "Blingtron 3000",
    "Blizzard",
    "Blood Imp",
    "Blood Knight",
    "Bloodfen Raptor",
    "Bloodlust",
    "Bloodmage Thalnos",
    "Bloodsail Corsair",
    "Bloodsail Raider",
    "Bluegill Warrior",
    "Bolf Ramshield",
    "Bolster",
    "Bolvar Fordragon",
    "Bomb Lobber",
    "Boneguard Lieutenant",
    "Booty Bay Bodyguard",
    "Boulderfist Ogre",
    "Bouncing Blade",
    "Brann Bronzebeard",
    "Brave Archer",
    "Brawl",
    "Buccaneer",
    "Burgle",
    "Burly Rockjaw Trogg",
    "Cabal Shadow Priest",
    "Cairne Bloodhoof",
    "Call Pet",
    "Captain Greenskin",
    "Captain's Parrot",
    "Captured Jormungar",
    "Cenarius",
    "Charge",
    "Charged Hammer",
    "Chillmaw",
    "Chillwind Yeti",
    "Chromaggus",
    "Circle of Healing",
    "Claw",
    "Cleave",
    "Clockwork Giant",
    "Clockwork Gnome",
    "Clockwork Knight",
    "Cobalt Guardian",
    "Cobra Shot",
    "Coghammer",
    "Cogmaster",
    "Cogmaster's Wrench",
    "Cold Blood",
    "Coldarra Drake",
    "Coldlight Oracle",
    "Coldlight Seer",
    "Coliseum Manager",
    "Commanding Shout",
    "Competitive Spirit",
    "Conceal",
    "Cone of Cold",
    "Confessor Paletress",
    "Confuse",
    "Consecration",
    "Convert",
    "Core Hound",
    "Core Rager",
    "Corruption",
    "Counterspell",
    "Crackle",
    "Crazed Alchemist",
    "Crowd Favorite",
    "Cruel Taskmaster",
    "Crush",
    "Cult Master",
    "Curse of Rafaam",
    "Cursed Blade",
    "Cutpurse"
}; // 0x7020
int32_t g1 = 0; // 0x400
int64_t g2 = -0x18a0000016fd; // 0x4944
int64_t g3 = -0x19f00000184d; // 0x4a94
int64_t g4 = -0x1b400000199d; // 0x4be4
int64_t g5 = 0x20002000200020; // 0x7502
struct _IO_FILE * g7 = NULL; // 0x7710
char g8 = 0; // 0x7718
int32_t g9;
int64_t * g6 = &g5; // 0x7708

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x2000 - 0x201b
int64_t _init(void) {
    int64_t result = 0; // 0x2012
    if (*(int64_t *)0x6fe8 != 0) {
        // 0x2014
        __gmon_start__();
        result = &g9;
    }
    // 0x2016
    return result;
}

// Address range: 0x2070 - 0x207b
void function_2070(int64_t * d) {
    // 0x2070
    __cxa_finalize(d);
}

// Address range: 0x2080 - 0x208b
void function_2080(void) {
    // 0x2080
    __stack_chk_fail();
}

// Address range: 0x2090 - 0x209b
int32_t function_2090(int32_t c, struct _IO_FILE * stream) {
    // 0x2090
    return fputc(c, stream);
}

// Address range: 0x20a0 - 0x20ab
int64_t * function_20a0(int64_t delta) {
    // 0x20a0
    return sbrk(delta);
}

// Address range: 0x20b0 - 0x20bb
void function_20b0(int32_t status) {
    // 0x20b0
    exit(status);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/fuzzy-match/fuzzy-match.c
// Address range: 0x20c0 - 0x2225
// Line range:    310 - 353
int main() {
    // 0x20c0
    libmin_printf("Matches for `%s':\n", "core");
    int64_t v1 = *(int64_t *)&entries; // 0x20e7
    if (v1 != 0) {
        int64_t v2 = (int64_t)&entries;
        uint32_t v3 = fuzzy_match("core", (char *)v1); // 0x210b
        if (v3 != -0x80000000) {
            // 0x2119
            libmin_printf("  %3d|%s\n", (int64_t)v3, (char *)*(int64_t *)v2);
        }
        int64_t v4 = v2 + 8; // 0x2126
        int64_t v5 = *(int64_t *)v4; // 0x2126
        while (v5 != 0) {
            // 0x2108
            v2 = v4;
            v3 = fuzzy_match("core", (char *)v5);
            if (v3 != -0x80000000) {
                // 0x2119
                libmin_printf("  %3d|%s\n", (int64_t)v3, (char *)*(int64_t *)v2);
            }
            // 0x2126
            v4 = v2 + 8;
            v5 = *(int64_t *)v4;
        }
    }
    // 0x2133
    libmin_printf("\n");
    libmin_printf("Matches for `%s':\n", "work");
    int64_t v6 = *(int64_t *)&entries; // 0x2158
    if (v6 != 0) {
        int64_t v7 = (int64_t)&entries;
        uint32_t v8 = fuzzy_match("work", (char *)v6); // 0x217b
        if (v8 != -0x80000000) {
            // 0x2189
            libmin_printf("  %3d|%s\n", (int64_t)v8, (char *)*(int64_t *)v7);
        }
        int64_t v9 = v7 + 8; // 0x2196
        int64_t v10 = *(int64_t *)v9; // 0x2196
        while (v10 != 0) {
            // 0x2178
            v7 = v9;
            v8 = fuzzy_match("work", (char *)v10);
            if (v8 != -0x80000000) {
                // 0x2189
                libmin_printf("  %3d|%s\n", (int64_t)v8, (char *)*(int64_t *)v7);
            }
            // 0x2196
            v9 = v7 + 8;
            v10 = *(int64_t *)v9;
        }
    }
    // 0x21a3
    libmin_printf("\n");
    libmin_printf("Matches for `%s':\n", "sam");
    int64_t v11 = *(int64_t *)&entries; // 0x21c1
    if (v11 == 0) {
        // 0x220b
        libmin_printf("\n");
        libmin_success();
        // UNREACHABLE
    }
    int64_t v12 = (int64_t)&entries;
    uint32_t v13 = fuzzy_match("sam", (char *)v11); // 0x21e3
    if (v13 != -0x80000000) {
        // 0x21f1
        libmin_printf("  %3d|%s\n", (int64_t)v13, (char *)*(int64_t *)v12);
    }
    int64_t v14 = v12 + 8; // 0x21fe
    int64_t v15 = *(int64_t *)v14; // 0x21fe
    while (v15 != 0) {
        // 0x21e0
        v12 = v14;
        v13 = fuzzy_match("sam", (char *)v15);
        if (v13 != -0x80000000) {
            // 0x21f1
            libmin_printf("  %3d|%s\n", (int64_t)v13, (char *)*(int64_t *)v12);
        }
        // 0x21fe
        v14 = v12 + 8;
        v15 = *(int64_t *)v14;
    }
    // 0x220b
    libmin_printf("\n");
    libmin_success();
    // UNREACHABLE
}

// Address range: 0x2230 - 0x2256
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x2230
    int64_t v1; // 0x2230
    __libc_start_main(0x20c0, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x2260 - 0x2289
int64_t deregister_tm_clones(void) {
    // 0x2260
    return (int64_t)&g7;
}

// Address range: 0x2290 - 0x22c9
int64_t register_tm_clones(void) {
    // 0x2290
    return 0;
}

// Address range: 0x22d0 - 0x2309
int64_t __do_global_dtors_aux(void) {
    // 0x22d0
    if (g8 != 0) {
        // 0x2308
        int64_t result; // 0x22d0
        return result;
    }
    // 0x22dd
    if (*(int64_t *)0x6ff8 != 0) {
        // 0x22eb
        __cxa_finalize((int64_t *)*(int64_t *)0x7008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x22f7
    g8 = 1;
    return result2;
}

// Address range: 0x2310 - 0x2319
int64_t frame_dummy(void) {
    // 0x2310
    return register_tm_clones();
}

// From module:   /home/jad/asm-to-asm/bringup-bench/fuzzy-match/fuzzy-match.c
// Address range: 0x2320 - 0x24ae
// Line range:    58 - 139
int32_t fuzzy_match_recurse(char * pattern, char * str, uint32_t score, int32_t first_char) {
    int64_t v1 = first_char;
    int64_t v2 = (int64_t)pattern;
    int64_t v3 = __readfsqword(40); // 0x2335
    int64_t v4 = v2; // 0x234a
    int64_t v5 = v1; // 0x234a
    int64_t v6 = score; // 0x234a
    int64_t v7; // 0x2320
    int64_t v8; // 0x2320
    int64_t v9; // 0x2320
    int64_t v10; // 0x2320
    int64_t v11; // 0x2320
    int64_t v12; // 0x2320
    int64_t v13; // 0x2320
    char * v14; // 0x2320
    int64_t v15; // 0x2320
    int64_t v16; // 0x2320
    int64_t v17; // 0x2320
    int64_t v18; // 0x2320
    int64_t v19; // 0x2320
    int64_t v20; // bp-66, 0x2320
    if ((char)v2 == 0) {
        goto lab_0x240f;
    } else {
        int64_t v21 = (int64_t)str;
        v20 = 0x100000000000000 * v2 >> 56;
        int64_t v22 = v1 & 0xffffffff; // 0x236b
        int64_t v23 = v22 ^ 1; // 0x236b
        char * v24 = libmin_strcasestr(str, (char *)&v20); // 0x237c
        v14 = v24;
        v17 = v22;
        v15 = v21;
        v8 = 0x80000000;
        v10 = v2;
        v12 = v23;
        v7 = v21;
        v19 = v1;
        v18 = v22;
        v16 = v21;
        v9 = 0x80000000;
        v11 = v2;
        v13 = v23;
        if (v24 == NULL) {
            goto lab_0x2401;
        } else {
            goto lab_0x2386;
        }
    }
  lab_0x240f:;
    int64_t result = v6;
    if (v3 == __readfsqword(40)) {
        // 0x241f
        return result;
    }
    // 0x249d
    __stack_chk_fail();
    int64_t v25 = v4; // 0x249d
    int64_t v26 = &g9; // 0x249d
    int64_t v27 = v5; // 0x249d
    int64_t v28; // 0x2320
    int64_t v29 = v28; // 0x249d
    int64_t v30; // 0x2320
    int64_t v31 = v30; // 0x249d
    int64_t v32 = result; // 0x249d
    int64_t v33; // 0x2320
    int64_t v34 = v33; // 0x249d
    int64_t v35; // 0x2320
    int64_t v36 = v35; // 0x249d
    goto lab_0x24a2;
  lab_0x24a2:;
    int64_t v37 = v25; // 0x24a4
    int64_t v38 = v26; // 0x24a4
    int64_t v39 = v27; // 0x24a4
    int64_t v40 = 0; // 0x24a4
    int64_t v41 = v29; // 0x24a4
    int64_t v42 = v31; // 0x24a4
    int64_t v43 = v32; // 0x24a4
    int64_t v44 = v34; // 0x24a4
    int64_t v45 = v36; // 0x24a4
    goto lab_0x2446;
  lab_0x2401:;
    int64_t v89 = v13;
    int64_t v90 = v11;
    int64_t v91 = v16;
    int64_t v92 = v18;
    int64_t v93 = v19;
    int64_t v94 = v7;
    int32_t v95 = v9; // 0x2401
    v4 = v94;
    v5 = v93;
    v28 = v92;
    v30 = v91;
    v6 = v9;
    v33 = v90;
    v35 = v89;
    if (v95 != -0x80000000) {
        // 0x240a
        v4 = v94;
        v5 = v93;
        v28 = v92;
        v30 = v91;
        v6 = v95 + score;
        v33 = v90;
        v35 = v89;
    }
    goto lab_0x240f;
  lab_0x2386:;
    int64_t v96 = v12;
    int64_t v97 = v10;
    int64_t v98 = v8;
    int64_t v99 = v15;
    int64_t v100 = v17;
    int64_t v101 = (int64_t)v14;
    int64_t v102 = v101 - v99; // 0x238c
    int64_t v103 = (int32_t)v101 == (int32_t)v99; // 0x2391
    int32_t v104 = v102; // 0x2398
    int64_t v68; // 0x2320
    int64_t v69; // 0x2320
    int64_t v70; // 0x2320
    int64_t v63; // 0x2320
    int64_t v67; // 0x2320
    int64_t v66; // 0x2320
    int64_t v64; // 0x2320
    int64_t v65; // 0x2320
    if ((int32_t)(v102 || v100) == 0) {
        // 0x2438
        v63 = v101;
        v64 = v102;
        v65 = 15;
        v66 = v100;
        v67 = v99;
        v68 = v98;
        v69 = v97;
        v70 = v96;
        v37 = v103;
        v38 = v101;
        v39 = v102;
        v40 = 15;
        v41 = v100;
        v42 = v99;
        v43 = v98;
        v44 = v97;
        v45 = v96;
        if ((v96 % 2 || (int64_t)(v104 >= 0 == (v104 != 0))) == 0) {
            goto lab_0x23bf;
        } else {
            goto lab_0x2446;
        }
    } else {
        // 0x23a9
        v25 = v103;
        v26 = v101;
        v27 = v102;
        v29 = v100;
        v31 = v99;
        v32 = v98;
        v34 = v97;
        v36 = v96;
        if ((v96 % 2 || (int64_t)(v104 >= 0 == (v104 != 0))) != 0) {
            goto lab_0x24a2;
        } else {
            // 0x23b6
            v63 = v101;
            v64 = v102;
            v65 = (int64_t)((0x80000000 * (int32_t)(v100 & v103) >> 31) % 16);
            v66 = v100;
            v67 = v99;
            v68 = v98;
            v69 = v97;
            v70 = v96;
            goto lab_0x23bf;
        }
    }
  lab_0x2446:;
    int64_t v46 = v45;
    int64_t v47 = v44;
    int64_t v48 = v43;
    int64_t v49 = v42;
    int64_t v50 = v41;
    int64_t v51 = v40;
    int64_t v52 = v39;
    int64_t v53 = v38;
    int64_t v54 = v37;
    int64_t v55 = (int64_t)g6; // 0x2446
    uint16_t v56 = *(int16_t *)(2 * (int64_t)*(char *)v53 + v55); // 0x2451
    int64_t v57 = v51; // 0x245a
    if (v56 % 2 != 0) {
        char v58 = *(char *)(2 * (int64_t)*(char *)(v53 - 1) + v55); // 0x2465
        v57 = (v58 & 2) != 0 ? v51 + 30 : v51;
    }
    int64_t v59 = v57;
    int64_t v60 = v59; // 0x2472
    if (v56 % 8 != 0) {
        unsigned char v61 = *(char *)(2 * (int64_t)*(char *)(v53 - 1) + v55); // 0x247d
        v60 = (v61 % 8 == 0 ? v59 + 30 : v59) & 0xffffffff;
    }
    int64_t v62 = v60;
    if (v50 % 2 == 0) {
        goto lab_0x2490;
    } else {
        if ((char)v54 != 0) {
            // 0x24a6
            v63 = v53;
            v64 = v52;
            v65 = v62 + 15 & 0xffffffff;
            v66 = v50;
            v67 = v49;
            v68 = v48;
            v69 = v47;
            v70 = v46;
            goto lab_0x23bf;
        } else {
            goto lab_0x2490;
        }
    }
  lab_0x2490:
    // 0x2490
    v63 = v53;
    v64 = v52;
    v65 = v62;
    v66 = v50;
    v67 = v49;
    v68 = v48;
    v69 = v47;
    v70 = v46;
    int64_t v71 = v53; // 0x2492
    int64_t v72 = v62; // 0x2492
    int64_t v73 = v50; // 0x2492
    int64_t v74 = v49; // 0x2492
    int64_t v75 = v48; // 0x2492
    int64_t v76 = v47; // 0x2492
    int64_t v77 = v46; // 0x2492
    if ((int32_t)v50 == 0) {
        goto lab_0x23d0;
    } else {
        goto lab_0x23bf;
    }
  lab_0x23bf:;
    int64_t v78 = 0xfffffffb * v64;
    int32_t v79 = v78; // 0x23c9
    int32_t v80 = v79 + 15; // 0x23c9
    int64_t v81 = v80 < 0 == ((v80 ^ v79) & (v79 ^ -0x80000000)) < 0 ? v78 : 0xfffffff1; // 0x23cb
    v71 = v63;
    v72 = v81 + v65 & 0xffffffff;
    v73 = v66;
    v74 = v67;
    v75 = v68;
    v76 = v69;
    v77 = v70;
    goto lab_0x23d0;
  lab_0x23d0:;
    int64_t v82 = v71 + 1; // 0x23d0
    char * v83 = (char *)v82; // 0x23dd
    int32_t v84 = fuzzy_match_recurse((char *)(v76 + 1), v83, (int32_t)v72, 0); // 0x23e1
    int32_t v85 = v75; // 0x23ed
    int32_t v86 = v85 - v84; // 0x23ed
    int64_t v87 = v86 < 0 == ((v86 ^ v85) & (v84 ^ v85)) < 0 ? v85 : v84; // 0x23f3
    char * v88 = libmin_strcasestr(v83, (char *)&v20); // 0x23f7
    v14 = v88;
    v17 = v73;
    v15 = v74;
    v8 = v87;
    v10 = v76;
    v12 = v77;
    v7 = v82;
    v19 = 0;
    v18 = v73;
    v16 = v74;
    v9 = v87;
    v11 = v76;
    v13 = v77;
    if (v88 != NULL) {
        goto lab_0x2386;
    } else {
        goto lab_0x2401;
    }
}

// From module:   /home/jad/asm-to-asm/bringup-bench/fuzzy-match/fuzzy-match.c
// Address range: 0x24b0 - 0x250f
// Line range:    26 - 37
int32_t fuzzy_match(char * pattern, char * str) {
    uint64_t v1 = libmin_strlen(str); // 0x24c1
    uint64_t v2 = libmin_strlen(pattern); // 0x24cc
    int64_t v3; // 0x24b0
    if ((char)v3 == 0) {
        // 0x24fd
        return 100;
    }
    // 0x24d7
    if (v2 > v1) {
        // 0x24fd
        return -0x80000000;
    }
    // 0x24dc
    return fuzzy_match_recurse(pattern, str, (int32_t)(v2 - v1) + 100, 1);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x2510 - 0x2521
// Line range:    124 - 127
void libtarg_success(void) {
    // 0x2510
    exit(0);
    // UNREACHABLE
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x2530 - 0x253f
// Line range:    162 - 165
void libtarg_fail(int32_t code) {
    // 0x2530
    exit(code);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x2540 - 0x2554
// Line range:    188 - 191
void libtarg_putc(char c) {
    // 0x2540
    fputc((int32_t)c, g7);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x2560 - 0x2569
// Line range:    230 - 236
char * libtarg_sbrk(int64_t inc) {
    // 0x2560
    return (char *)sbrk(inc);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_ctype.c
// Address range: 0x2570 - 0x2592
// Line range:    140 - 146
int32_t _isctype(uint32_t c, int32_t mask) {
    int32_t result = 0; // 0x257f
    if (c < 256) {
        uint16_t v1 = *(int16_t *)((0x100000000 * (int64_t)c >> 31) + (int64_t)g6); // 0x258b
        result = (int32_t)v1 & mask;
    }
    // 0x2591
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x25a0 - 0x27e8
// Line range:    426 - 483
void fmtint(char * buffer, int64_t * currlen, uint64_t maxlen, int64_t value, int32_t base, int32_t min, int32_t max, uint32_t flags) {
    int64_t v1 = flags; // 0x25af
    int64_t v2 = value; // 0x25cf
    int64_t v3 = 0; // 0x25cf
    int32_t v4 = 0; // 0x25cf
    if ((flags & 64) == 0) {
        if (value < 0) {
            // 0x27b0
            v2 = -value;
            v3 = 45;
            v4 = -1;
        } else {
            // 0x25da
            v2 = value;
            v3 = 43;
            v4 = -1;
            if ((v1 & 2) == 0) {
                uint32_t v5 = 8 * flags & 32; // 0x27d3
                v2 = value;
                v3 = v5;
                v4 = v5 != 0;
            }
        }
    }
    int64_t v6 = (int64_t)currlen;
    int64_t v7 = (int64_t)buffer;
    uint32_t v8 = max > 0 ? max : 0; // 0x25c7
    uint64_t v9 = (int64_t)base; // 0x2602
    int64_t v10; // bp-89, 0x25a0
    int64_t v11 = &v10; // 0x2605
    int64_t v12 = (v1 & 32) == 0 ? (int64_t)"0123456789abcdef" : (int64_t)"0123456789ABCDEF"; // 0x261d
    uint64_t v13 = v2; // 0x2621
    int64_t v14 = 1;
    *(char *)(v14 + v11) = *(char *)(v13 % v9 + v12);
    int32_t v15 = v14;
    int32_t v16 = v15 - 19; // 0x2648
    int64_t v17 = v14 + 1; // 0x2654
    while (v13 >= v9 == (v16 == 0 || v16 < 0 != (18 - v15 & v15) < 0)) {
        // 0x2628
        v13 /= v9;
        v14 = v17;
        *(char *)(v14 + v11) = *(char *)(v13 % v9 + v12);
        v15 = v14;
        v16 = v15 - 19;
        v17 = v14 + 1;
    }
    int64_t v18 = v15 == 20 ? 19 : v14 & 0xffffffff; // 0x2666
    int32_t v19 = v18; // 0x266a
    int32_t v20 = v8 - v19; // 0x266a
    int64_t v21 = 0x100000000 * v18 >> 32; // 0x2670
    int64_t v22; // bp-48, 0x25a0
    int64_t v23 = (int64_t)&v22 - 40 + v21; // 0x2677
    *(char *)v23 = 0;
    uint32_t v24 = min - (int32_t)(v20 < 0 == (v20 & v19) < 0 ? (int64_t)v8 : v18) + v4; // 0x2683
    uint32_t v25 = v20 > 0 ? v20 : 0; // 0x2689
    int64_t v26 = v25; // 0x2689
    int64_t v27 = v24 >= 0 ? (int64_t)v24 : 0; // 0x2695
    int64_t v28; // 0x25a0
    int64_t v29; // 0x25a0
    int64_t v30; // 0x25a0
    if ((v1 & 16) == 0) {
        if (flags % 2 != 0) {
            // 0x2790
            v29 = v6;
            v30 = -v27 & 0xffffffff;
            v28 = v26;
        } else {
            // 0x2754
            v29 = v6;
            v30 = v27;
            v28 = v26;
            if (v24 >= 1) {
                if (v6 < maxlen) {
                    // 0x2765
                    *(char *)(v6 + v7) = 32;
                }
                int64_t v31 = v6 + 1; // 0x276c
                *currlen = v31;
                uint32_t v32 = (int32_t)v27 - 1; // 0x2773
                int64_t v33 = v32; // 0x2776
                while (v32 != 0) {
                    int64_t v34 = v31;
                    int64_t v35 = v34; // 0x2763
                    if (v34 < maxlen) {
                        // 0x2765
                        *(char *)(v34 + v7) = 32;
                        v35 = v6;
                    }
                    // 0x276c
                    v31 = v35 + 1;
                    *currlen = v31;
                    v32 = (int32_t)v33 - 1;
                    v33 = v32;
                }
                int32_t v36 = v27; // 0x2778
                v29 = v31;
                v30 = v27 - (v36 >= 0 == (v36 != 0) ? v27 : 1) & 0xffffffff;
                v28 = v26;
            }
        }
    } else {
        int32_t v37 = v27; // 0x26a6
        int32_t v38 = v25 - v37; // 0x26a6
        v29 = v6;
        v30 = 0;
        v28 = v38 < 0 == (v38 & v37) < 0 ? v26 : v27;
    }
    int64_t v39 = v29; // 0x26b2
    if (v3 != 0) {
        int64_t v40 = v29; // 0x26b7
        if (v29 < maxlen) {
            // 0x27a0
            *(char *)(v29 + v7) = (char)v3;
            v40 = v6;
        }
        // 0x26bd
        v39 = v40 + 1;
        *currlen = v39;
    }
    int64_t v41 = v39; // 0x26c7
    uint32_t v42 = v28; // 0x26c7
    if ((int32_t)v28 != 0) {
        int64_t v43 = v39; // 0x2733
        if (v39 < maxlen) {
            // 0x2735
            *(char *)(v39 + v7) = 48;
            v43 = v6;
        }
        int64_t v44 = v43 + 1; // 0x273c
        *currlen = v44;
        v41 = v44;
        while (v42 != 0) {
            // 0x2730
            v42 = (int64_t)v42;
            int64_t v45 = v44;
            v43 = v45;
            if (v45 < maxlen) {
                // 0x2735
                *(char *)(v45 + v7) = 48;
                v43 = v6;
            }
            // 0x273c
            v44 = v43 + 1;
            *currlen = v44;
            v41 = v44;
        }
    }
    int64_t v46 = v23; // 0x26d8
    v46--;
    int64_t v47 = v41; // 0x26e3
    if (v41 < maxlen) {
        // 0x26e5
        *(char *)(v41 + v7) = *(char *)v46;
        v47 = v6;
    }
    int64_t v48 = v47 + 1; // 0x26f0
    *currlen = v48;
    while (v21 + v11 - (v18 + 0xffffffff & 0xffffffff) != v46) {
        int64_t v49 = v48;
        v46--;
        v47 = v49;
        if (v49 < maxlen) {
            // 0x26e5
            *(char *)(v49 + v7) = *(char *)v46;
            v47 = v6;
        }
        // 0x26f0
        v48 = v47 + 1;
        *currlen = v48;
    }
    // 0x2700
    if (v30 == 0) {
        // 0x2720
        return;
    }
    uint32_t v50 = v30; // 0x2702
    int64_t v51 = v48; // 0x270b
    if (v48 < maxlen) {
        // 0x270d
        *(char *)(v48 + v7) = 32;
        v51 = v6;
    }
    int64_t v52 = v51 + 1; // 0x2714
    *currlen = v52;
    while (v50 != 0) {
        // 0x2708
        v50 = (int64_t)v50;
        int64_t v53 = v52;
        v51 = v53;
        if (v53 < maxlen) {
            // 0x270d
            *(char *)(v53 + v7) = 32;
            v51 = v6;
        }
        // 0x2714
        v52 = v51 + 1;
        *currlen = v52;
    }
}

// Address range: 0x27f0 - 0x28a3
int64_t my_modf_isra_0(int64_t a1) {
    // 0x27f0
    int128_t v1; // 0x27f0
    int128_t v2 = __asm_movapd(v1); // 0x27f1
    int128_t v3 = __asm_movsd(0x3ff0000000000000); // 0x27fe
    int128_t v4 = __asm_movsd(0x3fb999999999999a); // 0x2806
    int128_t v5 = __asm_movsd(0x4024000000000000); // 0x280e
    int128_t v6 = __asm_movapd(v3); // 0x2816
    int64_t v7; // bp-8, 0x27f0
    bool v8 = &v7 < (int64_t *)32; // 0x281a
    int64_t result2 = 0;
    int128_t v9 = v6;
    int128_t v10; // 0x27f0
    int128_t v11 = v10;
    int128_t v12 = v2;
    int64_t v13 = __asm_cvttsd2si_3(v12); // 0x2830
    __asm_pxor(v11, v11);
    int128_t v14 = __asm_addsd(__asm_movapd(v12), v3); // 0x283d
    int128_t v15 = __asm_cvtsi2sd(v13); // 0x2841
    __asm_comisd(v14, v15);
    while (v8) {
        int64_t v16 = result2 + 1; // 0x2824
        int64_t result = v16 & 0xffffffff; // 0x2824
        uint32_t v17 = (int32_t)v16; // 0x282b
        v8 = v17 < 100;
        int128_t v18 = __asm_mulsd(v12, v4); // 0x282e
        int128_t v19 = __asm_mulsd(v9, v5); // 0x282e
        if (v17 == 100) {
            // 0x2868
            *(int64_t *)a1 = 0;
            return result;
        }
        result2 = result;
        v9 = v19;
        v11 = v15;
        v12 = v18;
        v13 = __asm_cvttsd2si_3(v12);
        __asm_pxor(v11, v11);
        v14 = __asm_addsd(__asm_movapd(v12), v3);
        v15 = __asm_cvtsi2sd(v13);
        __asm_comisd(v14, v15);
    }
    // 0x284c
    __asm_comisd(v15, __asm_subsd(__asm_movapd(v12), v3));
    if (result2 == 0) {
        // 0x285e
        *(int64_t *)a1 = __asm_movsd_1(v15);
        return result2;
    }
    int128_t v20 = __asm_mulsd(v15, v9); // 0x2875
    __asm_subsd(v1, v20);
    int64_t v21 = __asm_movsd_1(v20); // 0x2882
    int64_t v22; // bp-16, 0x27f0
    int64_t result3 = my_modf_isra_0((int64_t)&v22); // 0x2888
    *(int64_t *)a1 = __asm_movsd_1(__asm_addsd_2(__asm_movsd(v21), v22));
    return result3;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x28b0 - 0x2e30
// Line range:    586 - 525
void fmtfp(char * buffer, int64_t * currlen, uint64_t maxlen, float128_t fvalue, int32_t min, uint32_t max, int32_t flags) {
    char iconvert[311]; // bp-704, 0x28b0
    char v1[311]; // 0x28b0
    char v2[311]; // 0x2e18
    char v3[311]; // 0x2d52
    char v4[311]; // 0x29b3
    char v5[311]; // 0x2d2c
    // 0x28b0
    int128_t v6; // 0x28b0
    int128_t v7 = v6;
    int128_t v8 = v6;
    int128_t v9 = v6;
    int3_t v10; // 0x28b0
    int3_t v11 = v10 - 1;
    float80_t v12; // 0x28b0
    __frontend_reg_store_fpr(v11, v12);
    int32_t v13 = 6; // 0x28d5
    int64_t v14 = 6; // 0x28d5
    if (max >= 0) {
        int32_t v15 = max - 16; // 0x28e1
        v14 = v15 == 0 | v15 < 0 != (15 - max & max) < 0 ? (int64_t)max : 16;
        v13 = max;
    }
    uint64_t v16 = (int64_t)flags;
    int3_t v17 = v10 - 2; // 0x28e8
    __frontend_reg_store_fpr(v17, 0.0L);
    float80_t v18 = __frontend_reg_load_fpr(v17); // 0x28ea
    float80_t v19 = __frontend_reg_load_fpr(v11); // 0x28ea
    float80_t v20 = __frontend_reg_load_fpr(v11);
    int32_t v21; // 0x28b0
    int32_t v22; // 0x28b0
    float64_t v23; // bp-744, 0x28b0
    int128_t v24; // 0x28b0
    if (v18 > v19) {
        // 0x2d60
        __frontend_reg_store_fpr(v11, -v20);
        float64_t v25 = __frontend_reg_load_fpr(v11); // 0x2d6a
        v23 = v25;
        v22 = 45;
        v21 = 1;
        v24 = __asm_movsd((int64_t)v25);
    } else {
        float64_t v26 = v20; // 0x28f2
        v23 = v26;
        int128_t v27 = __asm_movsd((int64_t)v26); // 0x28f5
        v22 = 43;
        v21 = 1;
        v24 = v27;
        if ((v16 & 2) == 0) {
            int32_t v28 = 8 * flags & 32; // 0x290d
            v22 = v28;
            v21 = v28 != 0;
            v24 = v27;
        }
    }
    // 0x291e
    __asm_movapd(v24);
    float64_t fracpart; // bp-712, 0x28b0
    int64_t v29 = &fracpart; // 0x2928
    my_modf_isra_0(v29);
    bool v30; // 0x28b0
    bool v31; // 0x28b0
    int128_t v32; // 0x28b0
    int128_t v33; // 0x28b0
    int128_t v34; // 0x28b0
    bool v35; // 0x28b0
    bool v36; // 0x28b0
    if (v13 == 0) {
        int128_t v37 = __asm_movsd((int64_t)fracpart); // 0x2dc4
        int128_t v38 = __asm_subsd(v24, v37); // 0x2dca
        int64_t v39 = __asm_cvttsd2si_3(v38); // 0x2dcf
        v23 = __asm_movsd_1(v38);
        __frontend_reg_store_fpr(v11, (float80_t)v39);
        __frontend_reg_store_fpr(v11, (float80_t)v23 - __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v17, 0.5L);
        float80_t v40 = __frontend_reg_load_fpr(v17); // 0x2dec
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v11, v40);
        float80_t v41 = __frontend_reg_load_fpr(v17); // 0x2dee
        float80_t v42 = __frontend_reg_load_fpr(v11); // 0x2dee
        bool v43 = false; // 0x2dee
        bool v44 = false; // 0x2dee
        bool v45 = false; // 0x2dee
        if (v41 <= v42) {
            v43 = true;
            v44 = false;
            v45 = false;
            if (v41 >= v42) {
                v43 = v41 != v42;
                v44 = v41 != v42;
                v45 = true;
            }
        }
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
        bool v46 = true; // 0x2df2
        bool v47 = v44; // 0x2df2
        bool v48 = v45; // 0x2df2
        int64_t v49 = v39; // 0x2df2
        if (!v43) {
            // 0x2df4
            v49 = v39 + 1;
            v46 = v39 == -1;
            v47 = llvm_ctpop_i8((char)v49) % 2 == 0;
            v48 = v49 == 0;
        }
        // 0x2df8
        __asm_pxor(v7, v7);
        int128_t v50 = __asm_movsd(0x3ff0000000000000); // 0x2dfd
        int128_t v51 = __asm_cvtsi2sd(v49); // 0x2e05
        v23 = __asm_movsd_1(v51);
        __asm_comisd(v51, v50);
        __frontend_reg_store_fpr(v11, (float80_t)v23);
        int64_t v52 = __asm_movsd_1(v51); // 0x2e18
        v2[0] = v52;
        iconvert = v2;
        if (v46) {
            // 0x29e0
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
            v30 = v47;
            v35 = v48;
            v32 = v37;
            v34 = v51;
            goto lab_0x29e8;
        } else {
            int128_t v53 = __asm_addsd(v37, v50); // 0x2e25
            __frontend_reg_store_fpr(v17, 1.0L);
            v31 = v47;
            v36 = v48;
            v33 = v53;
            goto lab_0x2d1b;
        }
    } else {
        // 0x2939
        __frontend_reg_store_fpr(v11, 1.0L);
        __frontend_reg_store_fpr(v17, 10.0L);
        int64_t v54 = v14 & 0xffffffff; // 0x2941
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v17));
        uint32_t v55 = (int32_t)v54 - 1; // 0x294a
        int64_t v56 = v55; // 0x294d
        while (v55 != 0) {
            // 0x2948
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v17));
            v55 = (int32_t)v56 - 1;
            v56 = v55;
        }
        float80_t v57 = __frontend_reg_load_fpr(v17); // 0x294f
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v11, v57);
        int128_t v58 = __asm_movsd((int64_t)fracpart); // 0x2955
        v23 = __asm_movsd_1(__asm_subsd(v24, v58));
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17) * (float80_t)v23);
        int3_t v59 = v10 - 3;
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        float80_t v60 = __frontend_reg_load_fpr(v59); // 0x297c
        v23 = v60;
        __frontend_reg_store_fpr(v59, v60);
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17) - __frontend_reg_load_fpr(v59));
        __frontend_reg_store_fpr(v59, (float80_t)*(float32_t *)0x4d5c);
        float80_t v61 = __frontend_reg_load_fpr(v59); // 0x298e
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        __frontend_reg_store_fpr(v17, v61);
        float80_t v62 = __frontend_reg_load_fpr(v59); // 0x2990
        float80_t v63 = __frontend_reg_load_fpr(v17); // 0x2990
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17));
        if (v62 < v63) {
            // 0x2d40
            __asm_pxor(v9, v9);
            int128_t v64 = __asm_cvtsi2sd((int64_t)v23); // 0x2d44
            int64_t v65 = __asm_movsd_1(v64); // 0x2d4a
            v23 = v65;
            __frontend_reg_store_fpr(v17, (float80_t)(float64_t)v65);
            int64_t v66 = __asm_movsd_1(v64); // 0x2d52
            v3[0] = v66;
            v1 = v3;
        } else {
            // 0x299a
            __asm_pxor(v9, v9);
            int128_t v67 = __asm_cvtsi2sd((int64_t)v23 + 1); // 0x29a6
            int64_t v68 = __asm_movsd_1(v67); // 0x29ab
            v23 = v68;
            __frontend_reg_store_fpr(v17, (float80_t)(float64_t)v68);
            int64_t v69 = __asm_movsd_1(v67); // 0x29b3
            v4[0] = v69;
            v1 = v4;
        }
        // 0x29b9
        iconvert = v1;
        __frontend_reg_store_fpr(v59, 1.0L);
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
        uint32_t v70 = (int32_t)v54 - 1; // 0x29c2
        int64_t v71 = v70; // 0x29c5
        while (v70 != 0) {
            // 0x29c0
            __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
            v70 = (int32_t)v71 - 1;
            v71 = v70;
        }
        float80_t v72 = __frontend_reg_load_fpr(v59); // 0x29c7
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        __frontend_reg_store_fpr(v17, v72);
        float80_t v73 = __frontend_reg_load_fpr(v59); // 0x29c9
        float80_t v74 = __frontend_reg_load_fpr(v17); // 0x29c9
        bool v75 = false; // 0x29c9
        bool v76 = false; // 0x29c9
        bool v77 = false; // 0x29c9
        if (v73 <= v74) {
            v75 = true;
            v76 = false;
            v77 = false;
            if (v73 >= v74) {
                v75 = v73 != v74;
                v76 = v73 != v74;
                v77 = true;
            }
        }
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v59));
        if (!v75) {
            int128_t v78 = __asm_addsd_2(v58, 0x3ff0000000000000); // 0x2d00
            __frontend_reg_store_fpr(v59, 1.0L);
            __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
            uint32_t v79 = (int32_t)v54 - 1; // 0x2d12
            int64_t v80 = v79; // 0x2d15
            while (v79 != 0) {
                // 0x2d10
                __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
                v79 = (int32_t)v80 - 1;
                v80 = v79;
            }
            unsigned char v81 = llvm_ctpop_i8((char)v79); // 0x2d12
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v59));
            float80_t v82 = __frontend_reg_load_fpr(v17); // 0x2d19
            __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
            __frontend_reg_store_fpr(v11, v82);
            v31 = v81 % 2 == 0;
            v36 = true;
            v33 = v78;
            goto lab_0x2d1b;
        } else {
            // 0x29d3
            __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17));
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
            v30 = v76;
            v35 = v77;
            v32 = v58;
            v34 = __asm_movsd(*(int64_t *)&iconvert);
            goto lab_0x29e8;
        }
    }
  lab_0x29e8:;
    int64_t v83 = (int64_t)currlen;
    int64_t v84 = (int64_t)buffer;
    int64_t v85 = &v23; // 0x28c0
    int64_t v86; // bp-697, 0x28b0
    int64_t v87 = &v86; // 0x29ed
    int128_t v88 = __asm_pxor(v8, v8); // 0x29f2
    int128_t v89 = __asm_movsd(0x3fb999999999999a); // 0x29f7
    int128_t v90 = __asm_movsd(0x3fa999999999999a); // 0x2a00
    int128_t v91 = __asm_movsd(0x4024000000000000); // 0x2a10
    bool v92 = v30; // 0x2a19
    bool v93 = v35; // 0x2a19
    int64_t v94 = 1;
    int128_t v95 = __asm_movapd(__asm_mulsd(v32, v89)); // 0x2a3c
    my_modf_isra_0(v29);
    int128_t v96 = __asm_movsd((int64_t)fracpart); // 0x2a46
    int128_t v97 = __asm_subsd(v95, v96); // 0x2a4c
    __asm_ucomisd(v96, v88);
    int32_t v98 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v97, v90), v91)); // 0x2a60
    char v99 = *(char *)((int64_t)v98 + (int64_t)"0123456789abcdef"); // 0x2a67
    *(char *)(v94 + v87) = v99;
    bool v100; // 0x28b0
    int64_t v101; // 0x28b0
    bool v102; // 0x28b0
    while (v92 || !v93) {
        int64_t v103 = v94 - 311; // 0x2a24
        unsigned char v104 = llvm_ctpop_i8((char)v103); // 0x2a24
        v92 = v104 % 2 == 0;
        v93 = false;
        v100 = v104 % 2 == 0;
        v102 = true;
        v101 = 310;
        if (v103 == 0) {
            goto lab_0x2a83;
        }
        v94++;
        v95 = __asm_movapd(__asm_mulsd(v96, v89));
        my_modf_isra_0(v29);
        v96 = __asm_movsd((int64_t)fracpart);
        v97 = __asm_subsd(v95, v96);
        __asm_ucomisd(v96, v88);
        v98 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v97, v90), v91));
        v99 = *(char *)((int64_t)v98 + (int64_t)"0123456789abcdef");
        *(char *)(v94 + v87) = v99;
    }
    int32_t v105 = (int32_t)v94 - 311; // 0x2a74
    v100 = llvm_ctpop_i8((char)v105) % 2 == 0;
    v102 = v105 == 0;
    v101 = v105 == 0 ? 310 : v94 & 0xffffffff;
  lab_0x2a83:
    // 0x2a83
    __asm_ucomisd(v34, v88);
    int64_t v106 = 0x100000000 * v101 >> 32; // 0x2a88
    v23 = v106;
    int64_t v107 = v85 + 48; // 0x2a8f
    *(char *)(v106 + v107) = 0;
    int64_t v108 = v14; // 0x2a94
    int64_t v109 = 0; // 0x2a94
    if (v100 || !v102) {
        bool v110 = v100; // 0x2aae
        bool v111 = v102; // 0x2aae
        int64_t v112 = 1;
        int128_t v113 = __asm_mulsd(v34, v89); // 0x2ac1
        __asm_movapd(v113);
        int128_t v114 = __asm_movapd(v113); // 0x2ace
        my_modf_isra_0((int64_t)&iconvert);
        int128_t v115 = __asm_movsd(*(int64_t *)&iconvert); // 0x2ad8
        int128_t v116 = __asm_subsd(v114, v115); // 0x2ae1
        __asm_ucomisd(v115, v88);
        int32_t v117 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v116, v90), v91)); // 0x2af5
        char v118 = *(char *)((int64_t)v117 + (int64_t)"0123456789abcdef"); // 0x2afc
        int64_t v119; // bp-377, 0x28b0
        *(char *)(v112 + (int64_t)&v119) = v118;
        while (v110 || !v111) {
            int64_t v120 = v112 - 311; // 0x2ab4
            v110 = llvm_ctpop_i8((char)v120) % 2 == 0;
            v111 = false;
            if (v120 == 0) {
                goto lab_0x2da8;
            }
            v112++;
            v113 = __asm_mulsd(v115, v89);
            __asm_movapd(v113);
            v114 = __asm_movapd(v113);
            my_modf_isra_0((int64_t)&iconvert);
            v115 = __asm_movsd(*(int64_t *)&iconvert);
            v116 = __asm_subsd(v114, v115);
            __asm_ucomisd(v115, v88);
            v117 = __asm_cvttsd2si(__asm_mulsd(__asm_addsd(v116, v90), v91));
            v118 = *(char *)((int64_t)v117 + (int64_t)"0123456789abcdef");
            *(char *)(v112 + (int64_t)&v119) = v118;
        }
        if ((int32_t)v112 == 311) {
          lab_0x2da8:
            // 0x2da8
            v108 = v14 + 0xfffffeca;
            v109 = 310;
        } else {
            // 0x2b15
            v108 = v14 - v112;
            v109 = v112 & 0xffffffff;
        }
    }
    int64_t v121 = (0x100000000 * v109 >> 32) + v85;
    int64_t v122 = v121 + 368; // 0x2b25
    *(char *)v122 = 0;
    int32_t v123 = -1 - (int32_t)v14 + (int32_t)(float32_t)(float64_t)(int64_t)min - v21 - (int32_t)v101; // 0x2b3d
    int64_t v124 = v123 >= 0 ? (int64_t)v123 : 0; // 0x2b42
    int64_t v125; // 0x28b0
    int64_t v126; // 0x28b0
    int64_t v127; // 0x28b0
    int64_t v128; // 0x28b0
    int64_t v129; // 0x28b0
    int64_t v130; // 0x28b0
    if (v16 % 2 == 0) {
        if ((v16 & 16) == 0) {
            // 0x2cc0
            v129 = v83;
            v125 = v124;
            if (v123 >= 1) {
                if (v83 < maxlen) {
                    // 0x2cd5
                    *(char *)(v83 + v84) = 32;
                }
                int64_t v131 = v83 + 1; // 0x2cdc
                *currlen = v131;
                uint32_t v132 = (int32_t)v124 - 1; // 0x2ce3
                int64_t v133 = v132; // 0x2ce7
                while (v132 != 0) {
                    int64_t v134 = v131;
                    int64_t v135 = v134; // 0x2cd3
                    if (v134 < maxlen) {
                        // 0x2cd5
                        *(char *)(v134 + v84) = 32;
                        v135 = v83;
                    }
                    // 0x2cdc
                    v131 = v135 + 1;
                    *currlen = v131;
                    v132 = (int32_t)v133 - 1;
                    v133 = v132;
                }
                int32_t v136 = v124; // 0x2ce9
                v129 = v131;
                v125 = v124 - (v136 >= 0 == (v136 != 0) ? v124 : 1) & 0xffffffff;
            }
            goto lab_0x2b53;
        } else {
            // 0x2c7e
            v129 = v83;
            v125 = v124;
            if (v123 < 1) {
                goto lab_0x2b53;
            } else {
                // 0x2c87
                v130 = v83;
                v126 = v124;
                if (v22 != 0) {
                    // 0x2d91
                    v128 = v83;
                    v127 = v124;
                    if (v83 < maxlen) {
                        // 0x2d9a
                        *(char *)(v83 + v84) = (char)v22;
                        v128 = v83;
                        v127 = v124;
                    }
                    goto lab_0x2ca4;
                } else {
                    goto lab_0x2c98;
                }
            }
        }
    } else {
        // 0x2b50
        v129 = v83;
        v125 = -v124 & 0xffffffff;
        goto lab_0x2b53;
    }
  lab_0x2d1b:
    // 0x2d1b
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) - __frontend_reg_load_fpr(v17));
    fracpart = __asm_movsd_1(v33);
    float64_t v137 = __frontend_reg_load_fpr(v11); // 0x2d23
    v23 = v137;
    int128_t v138 = __asm_movsd((int64_t)v137); // 0x2d26
    int64_t v139 = __asm_movsd_1(v138); // 0x2d2c
    v5[0] = v139;
    iconvert = v5;
    v30 = v31;
    v35 = v36;
    v32 = v33;
    v34 = v138;
    goto lab_0x29e8;
  lab_0x2b53:;
    int64_t v140 = v129; // 0x2b59
    int64_t v141 = v125; // 0x2b59
    if (v22 != 0) {
        int64_t v142 = v129; // 0x2b5e
        if (v129 < maxlen) {
            // 0x2b60
            *(char *)(v129 + v84) = (char)v22;
            v142 = v83;
        }
        int64_t v143 = v142 + 1; // 0x2b66
        *currlen = v143;
        v140 = v143;
        v141 = v125;
    }
    goto lab_0x2b6d;
  lab_0x2b6d:;
    int64_t v144 = v107 + (int64_t)v23 - 1;
    int64_t v145; // 0x28b0
    if (v140 < maxlen) {
        // 0x2b85
        *(char *)(v145 + v84) = *(char *)v144;
    }
    int64_t v146 = v140 + 1; // 0x2b90
    *currlen = v146;
    int64_t v147 = v146; // 0x2b9e
    int64_t v148 = v144; // 0x2b9e
    while (v87 - (v101 + 0xffffffff & 0xffffffff) + (int64_t)v23 != v144) {
        // 0x2b80
        v144 = v148 - 1;
        if (v147 < maxlen) {
            // 0x2b85
            *(char *)(v145 + v84) = *(char *)v144;
        }
        // 0x2b90
        v146 = v147 + 1;
        *currlen = v146;
        v147 = v146;
        v148 = v144;
    }
    if (v13 != 0) {
        int64_t v149 = v146; // 0x2ba8
        if (v146 < maxlen) {
            // 0x2baa
            *(char *)(v146 + v84) = 46;
            v149 = v83;
        }
        int64_t v150 = v149 + 1; // 0x2bb1
        *currlen = v150;
        int64_t v151 = v150; // 0x2bba
        if ((int32_t)v108 >= 1) {
            int64_t v152 = v151;
            int64_t v153 = v152; // 0x2bc3
            if (v152 < maxlen) {
                // 0x2bc5
                *(char *)(v152 + v84) = 48;
                v153 = v83;
            }
            int64_t v154 = v153 + 1; // 0x2bcc
            *currlen = v154;
            uint32_t v155 = (int32_t)(v108 & 0xffffffff) - 1; // 0x2bd3
            int64_t v156 = v155; // 0x2bd6
            while (v155 != 0) {
                // 0x2bc0
                v152 = v154;
                v153 = v152;
                if (v152 < maxlen) {
                    // 0x2bc5
                    *(char *)(v152 + v84) = 48;
                    v153 = v83;
                }
                // 0x2bcc
                v154 = v153 + 1;
                *currlen = v154;
                v155 = (int32_t)v156 - 1;
                v156 = v155;
            }
        }
        if (v109 != 0) {
            int64_t v157 = v122 - 1;
            if (v83 < maxlen) {
                // 0x2bfd
                *(char *)(v83 + v84) = *(char *)v157;
            }
            int64_t v158 = v83 + 1; // 0x2c08
            *currlen = v158;
            int64_t v159 = v157; // 0x2c16
            while (367 - (v109 + 0xffffffff & 0xffffffff) + v121 != v157) {
                int64_t v160 = v158;
                v157 = v159 - 1;
                int64_t v161 = v160; // 0x2bfb
                if (v160 < maxlen) {
                    // 0x2bfd
                    *(char *)(v160 + v84) = *(char *)v157;
                    v161 = v83;
                }
                // 0x2c08
                v158 = v161 + 1;
                *currlen = v158;
                v159 = v157;
            }
        }
    }
    // 0x2c18
    if ((int32_t)v141 == 0) {
        // 0x2c39
        return;
    }
    if (v83 < maxlen) {
        // 0x2c25
        *(char *)(v83 + v84) = 32;
    }
    int64_t v162 = v83 + 1; // 0x2c2c
    *currlen = v162;
    uint32_t v163 = (int32_t)v141 + 1; // 0x2c33
    int64_t v164 = v163; // 0x2c37
    while (v163 != 0) {
        int64_t v165 = v162;
        int64_t v166 = v165; // 0x2c23
        if (v165 < maxlen) {
            // 0x2c25
            *(char *)(v165 + v84) = 32;
            v166 = v83;
        }
        // 0x2c2c
        v162 = v166 + 1;
        *currlen = v162;
        v163 = (int32_t)v164 + 1;
        v164 = v163;
    }
  lab_0x2c98:;
    int64_t v167 = v126;
    int64_t v168 = v130;
    v128 = v168;
    v127 = v167;
    if (v168 < maxlen) {
        // 0x2c9d
        *(char *)(v168 + v84) = 48;
        v128 = v83;
        v127 = v167;
    }
    goto lab_0x2ca4;
  lab_0x2ca4:;
    int64_t v169 = v128 + 1; // 0x2ca4
    *currlen = v169;
    uint32_t v170 = (int32_t)v127 - 1; // 0x2cab
    int64_t v171 = v170; // 0x2cab
    v140 = v169;
    v141 = v171;
    v130 = v169;
    v126 = v171;
    if (v170 != 0) {
        goto lab_0x2c98;
    } else {
        goto lab_0x2b6d;
    }
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x2e30 - 0x374d
// Line range:    130 - 290
int64_t dopr(char * buffer, uint64_t maxlen, char * format, int32_t * args) {
    // 0x2e30
    int64_t v1; // 0x2e30
    uint64_t v2 = v1;
    int64_t v3 = (int64_t)buffer;
    int64_t v4 = (int64_t)format + 1; // 0x2e43
    int64_t v5 = v4; // 0x2e43
    int64_t result2 = 0; // 0x2e59
    int64_t v6; // 0x2e30
    int64_t v7; // 0x2e30
    int64_t v8; // 0x2e30
    int64_t v9; // 0x2e30
    char v10; // 0x2e30
    int64_t v11; // 0x2e30
    int64_t v12; // 0x2e30
    if ((char)v2 != 0) {
        int64_t v13 = (int64_t)args;
        int64_t * v14 = (int64_t *)(v13 + 8);
        v6 = v4;
        v7 = v2 % 256;
        v12 = 0;
        while (true) {
          lab_0x2eae:;
            char v15 = v7; // 0x2eb5
            int64_t v16 = v6; // 0x2eb8
            char v17 = v15; // 0x2eb8
            int64_t v18 = v12; // 0x2eb8
            int64_t v19 = v6; // 0x2eb8
            int64_t v20 = v12; // 0x2eb8
            if (v15 != 37) {
                while (true) {
                  lab_0x2eba:;
                    uint64_t v21 = v18;
                    int64_t v22 = v16; // 0x2ebd
                    if (v21 < maxlen) {
                        // 0x2ebf
                        *(char *)(v21 + v3) = v17;
                        v22 = v5;
                    }
                    char v23 = *(char *)v22; // 0x2ec3
                    int64_t v24 = v22 + 1; // 0x2ec6
                    v5 = v24;
                    int64_t v25 = v21 + 1; // 0x2eca
                    result2 = v25;
                    v16 = v24;
                    v17 = v23;
                    v18 = v25;
                    v19 = v24;
                    v20 = v25;
                    switch (v23) {
                        case 0: {
                            goto lab_0x2e60_3;
                        }
                        case 37: {
                            goto lab_0x2ed9;
                        }
                        default: {
                            goto lab_0x2eba;
                        }
                    }
                }
            }
          lab_0x2ed9:
            // 0x2ed9
            v11 = v20;
            unsigned char v26 = *(char *)v19; // 0x2ee3
            result2 = v11;
            if (v26 == 0) {
                // break -> 0x2e60
                break;
            }
            int64_t v27 = v26; // 0x2ee3
            int64_t result = v27; // 0x2efb
            if (v26 < 49) {
                // 0x2e73
                return result;
            }
            int64_t v28 = v19 + 1; // 0x2eee
            int64_t v29 = (int64_t)g6; // 0x2f0a
            v5 = 0;
            int64_t v30 = v27; // 0x2f1a
            int64_t v31 = v28; // 0x2f1a
            int32_t v32 = 0; // 0x2f1a
            int64_t v33 = v27; // 0x2f1a
            int64_t v34 = v28; // 0x2f1a
            if ((*(char *)(2 * v27 + v29) & 4) != 0) {
                int64_t v35 = 0xffffffd0 + (0x100000000000000 * v30 >> 56); // 0x2f26
                int64_t v36 = v35 & 0xffffffff; // 0x2f26
                v5 = v36;
                unsigned char v37 = *(char *)v31; // 0x2f2a
                result2 = v11;
                if (v37 == 0) {
                    // break (via goto) -> 0x2e60
                    goto lab_0x2e60_3;
                }
                int64_t v38 = v31 + 1; // 0x2f22
                int64_t v39 = v37; // 0x2f2a
                v31 = v38;
                while ((*(char *)(2 * v39 + v29) & 4) != 0) {
                    // 0x2f1c
                    v35 = 10 * v36 + 0xffffffd0 + (0x100000000000000 * v39 >> 56);
                    v36 = v35 & 0xffffffff;
                    v5 = v36;
                    v37 = *(char *)v31;
                    result2 = v11;
                    if (v37 == 0) {
                        // break (via goto) -> 0x2e60
                        goto lab_0x2e60_3;
                    }
                    // 0x2f36
                    v38 = v31 + 1;
                    v39 = v37;
                    v31 = v38;
                }
                // 0x2f42
                v32 = v35;
                v33 = v39;
                v34 = v38;
            }
            int64_t v40 = v34;
            int64_t v41 = v33; // 0x2f44
            int64_t v42 = v40; // 0x2f44
            if (v33 == 42) {
                uint32_t v43 = v32; // 0x3478
                if (v43 < 48) {
                    // 0x347f
                    v5 = *(int64_t *)(v13 + 16) + (int64_t)v43;
                    *args = v43 + 8;
                } else {
                    int64_t v44 = *v14; // 0x34d3
                    v5 = v44;
                    *v14 = v44 + 8;
                }
                unsigned char v45 = *(char *)v40; // 0x348a
                result2 = v11;
                if (v45 == 0) {
                    // break -> 0x2e60
                    break;
                }
                // 0x349c
                v41 = v45;
                v42 = v40 + 1;
            }
            int64_t v46 = v42;
            int64_t v47 = v41; // 0x2f52
            int64_t v48 = v46; // 0x2f52
            if ((char)v41 == 46) {
                char v49 = *(char *)v46; // 0x3008
                result2 = v11;
                if (v49 == 0) {
                    // break -> 0x2e60
                    break;
                }
                int64_t v50 = v46;
                unsigned char v51 = v49;
                int64_t v52 = v50 + 1;
                int64_t v53 = v51;
                while ((*(char *)(2 * v53 + v29) & 4) != 0) {
                    char v54 = *(char *)v52; // 0x303c
                    result2 = v11;
                    if (v54 == 0) {
                        // break (via goto) -> 0x2e60
                        goto lab_0x2e60_3;
                    }
                    v50 = v52;
                    v51 = v54;
                    v52 = v50 + 1;
                    v53 = v51;
                }
                // 0x33c0
                v47 = v53;
                v48 = v52;
                if (v51 == 42) {
                    uint32_t v55 = *(int32_t *)&v5; // 0x33c8
                    if (v55 < 48) {
                        // 0x33d3
                        *args = v55 + 8;
                    } else {
                        // 0x34a4
                        *v14 = *v14 + 8;
                    }
                    unsigned char v56 = *(char *)v52; // 0x33de
                    result2 = v11;
                    if (v56 == 0) {
                        // break -> 0x2e60
                        break;
                    }
                    // 0x33f1
                    v47 = v56;
                    v48 = v50 + 2;
                }
            }
            int64_t v57 = v48;
            int64_t v58 = v47;
            switch ((char)v58) {
                case 104: {
                    char v59 = *(char *)v57; // 0x345e
                    v10 = v59;
                    v9 = v57 + 1;
                    if (v59 == 0) {
                        // break -> 0x2e60
                        break;
                    }
                    goto lab_0x3416;
                }
                case 108: {
                    char v60 = *(char *)v57; // 0x33f9
                    int64_t v61 = v57 + 1;
                    result2 = v11;
                    v10 = v60;
                    v9 = v61;
                    switch (v60) {
                        case 108: {
                            char v62 = *(char *)v61; // 0x34b5
                            v10 = v62;
                            v9 = v57 + 2;
                            if (v62 == 0) {
                                // break -> 0x2e60
                                break;
                            }
                            goto lab_0x3416;
                        }
                        case 0: {
                            goto lab_0x2e60_3;
                        }
                        default: {
                            goto lab_0x3416;
                        }
                    }
                }
                case 76: {
                    unsigned char v63 = *(char *)v57; // 0x342f
                    if (v63 == 0) {
                        // break -> 0x2e60
                        break;
                    }
                    int64_t v64 = (int64_t)v63 + 0xffffffdb; // 0x343b
                    v8 = v57 + 1;
                    if ((char)v64 < 84) {
                        int32_t v65 = *(int32_t *)((4 * v64 & 1020) + (int64_t)&g4); // 0x3454
                        return (int64_t)v65 + (int64_t)&g4;
                    }
                    goto lab_0x30a3;
                }
                default: {
                    // 0x2f70
                    v8 = v57;
                    if ((char)(v58 + 0xffffffdb) < 84) {
                        // 0x2f7b
                        int64_t v66; // 0x2f70
                        int32_t v67 = *(int32_t *)((4 * v66 & 1020) + (int64_t)&g2); // 0x2f85
                        return (int64_t)v67 + (int64_t)&g2;
                    }
                    goto lab_0x30a3;
                }
            }
        }
    }
  lab_0x2e60_3:
    // 0x2e60
    if (maxlen == 0) {
        // 0x2e73
        return result2;
    }
    uint64_t v68 = maxlen - 1;
    if (v68 > result2) {
        // 0x2e6e
        *(char *)(result2 + v3) = 0;
        // 0x2e73
        return result2;
    }
    // 0x2e88
    *(char *)(v68 + v3) = 0;
    return result2;
  lab_0x30a3:;
    unsigned char v69 = *(char *)v8; // 0x30a3
    int64_t v70 = v8 + 1; // 0x30a7
    v5 = v70;
    result2 = v11;
    v6 = v70;
    v7 = v69;
    v12 = v11;
    if (v69 == 0) {
        // break -> 0x2e60
        goto lab_0x2e60_3;
    }
    goto lab_0x2eae;
  lab_0x3416:;
    int64_t v71 = (int64_t)v10 + 0xffffffdb; // 0x3416
    v8 = v9;
    if ((char)v71 < 84) {
        int32_t v72 = *(int32_t *)((4 * v71 & 1020) + (int64_t)&g3); // 0x3424
        return (int64_t)v72 + (int64_t)&g3;
    }
    goto lab_0x30a3;
}

// Address range: 0x374d - 0x3758
int64_t function_374d(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x374d
    int64_t v1; // 0x374d
    return v1 & 0xffffffff;
}

// Address range: 0x3758 - 0x3763
int64_t function_3758(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3758
    int64_t v1; // 0x3758
    return v1 & 0xffffffff;
}

// Address range: 0x3763 - 0x376e
int64_t function_3763(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3763
    int64_t v1; // 0x3763
    return v1 & 0xffffffff;
}

// Address range: 0x376e - 0x3775
int64_t function_376e(void) {
    // 0x376e
    int64_t v1; // 0x376e
    return v1 & 0xffffffff;
}

// Address range: 0x3775 - 0x3780
int64_t function_3775(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x3775
    int64_t v1; // 0x3775
    return v1 & 0xffffffff;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x3780 - 0x388c
// Line range:    751 - 769
int32_t libmin_printf(char * fmt, ...) {
    // 0x3780
    int64_t v1; // 0x3780
    if ((char)v1 != 0) {
        // 0x37bc
        int128_t v2; // 0x3780
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
    }
    int64_t v3 = 8; // bp-1248, 0x3826
    char v4; // bp-1224, 0x3780
    dopr(&v4, (int64_t)&g1, fmt, (int32_t *)&v3);
    if (v4 == 0) {
        // 0x3880
        return 0;
    }
    int64_t v5 = &v4;
    libtarg_putc(v4);
    int64_t v6 = v5 + 1; // 0x3869
    char v7 = *(char *)v6; // 0x3869
    while (v7 != 0) {
        // 0x3860
        v5 = v6;
        libtarg_putc(v7);
        v6 = v5 + 1;
        v7 = *(char *)v6;
    }
    // 0x3876
    int64_t v8; // bp+1225, 0x3780
    return v5 + (int64_t)&v8;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x3890 - 0x393b
// Line range:    772 - 782
int32_t libmin_snprintf(char * s, int64_t size, char * fmt, ...) {
    // 0x3890
    int64_t v1; // 0x3890
    if ((char)v1 != 0) {
        // 0x38b6
        int128_t v2; // 0x3890
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
    }
    int64_t v3 = 24; // bp-224, 0x390a
    dopr(s, size, fmt, (int32_t *)&v3);
    *(char *)((int64_t)s - 1 + size) = 0;
    return libmin_strlen(s);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strlen.c
// Address range: 0x3940 - 0x396b
// Line range:    5 - 15
int64_t libmin_strlen(char * str) {
    int64_t v1 = (int64_t)str;
    if (str == NULL || (char)v1 == 0) {
        // 0x3968
        return 0;
    }
    int64_t v2 = v1; // 0x3947
    v2++;
    while (*(char *)v2 != 0) {
        // 0x3958
        v2++;
    }
    // 0x3961
    return v2 - v1;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strcasestr.c
// Address range: 0x3970 - 0x39bf
// Line range:    4 - 9
char * libmin_strcasestr(char * h, char * n) {
    int64_t v1 = libmin_strlen(n); // 0x3981
    int64_t v2; // 0x3970
    if ((char)v2 == 0) {
        // 0x39ab
        return NULL;
    }
    int64_t v3 = (int64_t)h; // 0x398e
    char * v4 = (char *)v3;
    int32_t v5 = libmin_strncasecmp(v4, n, v1); // 0x39a2
    char * result = v4; // 0x39a9
    while (v5 != 0) {
        // 0x3990
        v3++;
        result = NULL;
        if (*(char *)v3 == 0) {
            // break -> 0x39ab
            break;
        }
        v4 = (char *)v3;
        v5 = libmin_strncasecmp(v4, n, v1);
        result = v4;
    }
    // 0x39ab
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_success.c
// Address range: 0x39c0 - 0x39c9
// Line range:    5 - 7
void libmin_success(void) {
    // 0x39c0
    libtarg_success();
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strncasecmp.c
// Address range: 0x39d0 - 0x3aae
// Line range:    4 - 9
int32_t libmin_strncasecmp(char * _l, char * _r, int64_t n) {
    if (n == 0) {
        // 0x3aa0
        return 0;
    }
    uint64_t v1 = (int64_t)_r;
    uint64_t v2 = (int64_t)_l;
    int64_t v3 = (int64_t)g6;
    int64_t v4 = v1 % 256; // 0x39f2
    if ((char)v2 == 0) {
        goto lab_0x3a5d;
    } else {
        // 0x39f9
        if (n != 1 == ((char)v1 != 0)) {
            // 0x3a1c
        } else {
            goto lab_0x3a70;
        }
    }
  lab_0x3a70:;
    int64_t v5 = v2 % 256;
    int16_t v6 = *(int16_t *)(2 * v5 + v3) % 2; // 0x3a78
    int64_t v7 = v5; // 0x3a78
    int64_t v8 = v4; // 0x3a78
    goto lab_0x3a7b;
  lab_0x3a5d:
    // 0x3a5d
    v6 = (int16_t)v3 % 2;
    v7 = 0;
    v8 = v4;
    goto lab_0x3a7b;
  lab_0x3a7b:;
    int32_t v9 = v7;
    unsigned char v10 = *(char *)(2 * v8 + v3); // 0x3a89
    uint32_t v11 = (int32_t)v8 % 256;
    return (v6 != 0 ? v9 + 32 : v9) - (v10 % 2 != 0 ? v11 + 32 : v11);
}

// Address range: 0x3ab0 - 0x3abd
int64_t _fini(void) {
    // 0x3ab0
    int64_t result; // 0x3ab0
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 35

