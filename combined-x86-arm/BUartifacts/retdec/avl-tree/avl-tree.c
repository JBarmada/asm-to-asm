//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;
typedef int64_t int128_t;
typedef uint64_t uint128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int32_t _isctype(uint32_t c, int32_t mask);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t breadth(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t * CheckTreeNodeRotation(int32_t * tnode, int32_t * subtree, int16_t * finished);
int16_t Compare(int32_t * Data1, int32_t * Data2);
int32_t * DeleteByElement(int32_t * rootNode, int32_t * Item);
int32_t * DeleteByElementRecursive(int32_t * rootNode, int32_t * Item, int16_t * finished);
int32_t * DeleteLeftMost(int32_t ** deletedNode, int32_t * rootNode, int16_t * finished);
int64_t deregister_tm_clones(void);
int64_t dopr(char * buffer, uint64_t maxlen, char * format, int32_t * args);
int64_t DoubleLeftRotation(int64_t a1);
int64_t DoubleRightRotation(int64_t a1);
int32_t * FindByElement(int32_t * rootNode, int32_t * Data);
void fmtfp(char * buffer, int64_t * currlen, uint64_t maxlen, float128_t fvalue, int32_t min, uint32_t max, int32_t flags);
void fmtint(char * buffer, int64_t * currlen, uint64_t maxlen, int64_t value, int32_t base, int32_t min, int32_t max, uint32_t flags);
int64_t frame_dummy(void);
void FreeElement(int32_t * Data);
void function_1080(int64_t * d);
void function_1090(void);
int64_t * function_10a0(int64_t * s, int32_t c, int32_t n);
int32_t function_10b0(int32_t c, struct _IO_FILE * stream);
int64_t * function_10c0(int64_t delta);
void function_10d0(int32_t status);
int64_t function_458d(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_4598(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_45a3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_45ae(void);
int64_t function_45b5(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t Height(int64_t a1);
int32_t * Insert(int32_t * tnode, int32_t * Item, char * Name);
int32_t * InsertNode(int32_t * tnode, int32_t * Item, char * Name, int16_t * finished);
int16_t IsEmpty(int32_t * rootNode);
char * libmin_calloc(uint64_t num, uint64_t nsize);
void libmin_fail(uint32_t code);
int64_t libmin_free(int64_t a1);
int64_t libmin_free_part_0(int64_t a1);
int64_t libmin_malloc(uint64_t a1);
char * libmin_memcpy(char * dest, int32_t * src, int64_t n);
char * libmin_memset(char * dest, uint32_t c, uint64_t n);
int32_t libmin_printf(char * fmt, ...);
int32_t libmin_rand(void);
char * libmin_realloc(char * block, uint64_t size);
int32_t libmin_snprintf(char * s, int64_t size, char * fmt, ...);
int64_t libmin_srand(void);
int64_t libmin_strlen(char * str);
void libmin_success(void);
void libtarg_fail(int32_t code);
void libtarg_putc(char c);
char * libtarg_sbrk(int64_t inc);
void libtarg_success(void);
int64_t MakeEmpty(int64_t a1);
int64_t my_modf_isra_0(int64_t a1);
int64_t printTree(int64_t a1);
int64_t printTree_part_0(int64_t a1, int32_t a2);
int64_t register_tm_clones(void);
int64_t SingleLeftRotation(int64_t a1);
int64_t SingleRightRotation(int64_t result);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x1000000004; // 0x38c
int32_t * g2 = (int32_t *)0x100000010; // 0x390
int32_t g3 = 0; // 0x400
int64_t g4 = -0x1394000011f1; // 0x5278
int64_t g5 = -0x14e400001341; // 0x53c8
int64_t g6 = -0x163400001491; // 0x5518
int64_t g7 = -0x66f74f2100000000; // 0x56c0
int64_t g8 = 0x20002000200020; // 0x8022
struct _IO_FILE * g10 = NULL; // 0x8240
char g11 = 0; // 0x8248
int64_t g12 = 0; // 0x85ec
int32_t g13 = 0; // 0x8890
int32_t g14 = 0; // 0x8c1c
int64_t g15 = 0; // 0x8c20
int32_t * head = NULL; // 0x8258
int32_t mt[625]; // 0x8260
int32_t mt_initialized = 0; // 0x8c24
int32_t mti = 625; // 0x8010
int32_t * tail = NULL; // 0x8250
int32_t g16;
int64_t * g9 = &g8; // 0x8228

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x7fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g16;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int64_t * function_10a0(int64_t * s, int32_t c, int32_t n) {
    // 0x10a0
    return memset(s, c, n);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(int32_t c, struct _IO_FILE * stream) {
    // 0x10b0
    return fputc(c, stream);
}

// Address range: 0x10c0 - 0x10cb
int64_t * function_10c0(int64_t delta) {
    // 0x10c0
    return sbrk(delta);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(int32_t status) {
    // 0x10d0
    exit(status);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avl-tree.c
// Address range: 0x10e0 - 0x14b4
// Line range:    40 - 95
int main(int argc, char ** argv) {
    // 0x10e0
    libmin_srand();
    libmin_printf("Start  -->  Finished\n");
    int64_t v1 = 0; // 0x1113
    int64_t v2 = 0; // 0x1113
    int64_t v3 = 0; // 0x1113
    int64_t v4; // 0x10e0
    int64_t v5; // 0x1149
    int32_t * v6; // 0x1180
    while (true) {
      lab_0x1137:
        // 0x1137
        v4 = v3;
        int64_t v7 = libmin_malloc(8); // 0x113c
        v5 = libmin_malloc(11);
        char * v8 = (char *)v5; // 0x1165
        libmin_snprintf(v8, 11, "Name%ld", (int32_t)v4);
        int32_t * v9 = (int32_t *)v7;
        *v9 = libmin_rand();
        v6 = Insert((int32_t *)v1, v9, v8);
        while (v6 == NULL) {
            int64_t v10 = (int64_t)*v9; // 0x118d
            if (v2 == v10) {
                // 0x11a0
                libmin_free(v5);
                libmin_free(v7);
                libmin_printf("going to try and skip: %ld\n", *v9);
                goto lab_0x1118;
            }
            v2 = v10;
            *v9 = libmin_rand();
            v6 = Insert((int32_t *)v1, v9, v8);
        }
        goto lab_0x1118;
    }
  lab_0x11c5:
    // 0x11c5
    libmin_printf("\n");
    int64_t v11; // 0x10e0
    int64_t * v12 = (int64_t *)(v11 + 16); // 0x11d6
    libmin_printf("\nGoing to delete the rootNode: %ld\n", *(int32_t *)*v12);
    int32_t * v13 = DeleteByElement(v6, (int32_t *)*v12); // 0x11f1
    int64_t v14; // 0x10e0
    if (v13 == NULL) {
        // 0x1472
        libmin_printf("failure!\n");
        v14 = v11;
    } else {
        int64_t v15 = (int64_t)v13; // 0x11f1
        libmin_printf("success! new root is %ld\n", *(int32_t *)*(int64_t *)(v15 + 16));
        v14 = v15;
    }
    int64_t v16 = v14;
    libmin_printf("\nGoing to delete leftMost child... ");
    int64_t v17 = v16;
    int64_t v18 = *(int64_t *)v17; // 0x1233
    while (v18 != 0) {
        // 0x1230
        v17 = v18;
        v18 = *(int64_t *)v17;
    }
    int64_t * v19 = (int64_t *)(v17 + 16); // 0x123b
    libmin_printf("found item: %ld\n", *(int32_t *)*v19);
    int32_t * v20 = DeleteByElement((int32_t *)v16, (int32_t *)*v19); // 0x125b
    int64_t v21; // 0x10e0
    if (v20 == NULL) {
        // 0x149e
        libmin_printf("failure!\n");
        v21 = v16;
    } else {
        int64_t v22 = (int64_t)v20; // 0x125b
        libmin_printf("success! new root: %ld\n", *(int32_t *)*(int64_t *)(v22 + 16));
        v21 = v22;
    }
    int64_t v23 = v21;
    libmin_printf("\nGoing to delete rightMost child... ");
    int64_t v24 = v23;
    int64_t v25 = *(int64_t *)(v24 + 8); // 0x129b
    while (v25 != 0) {
        // 0x1298
        v24 = v25;
        v25 = *(int64_t *)(v24 + 8);
    }
    int64_t * v26 = (int64_t *)(v24 + 16); // 0x12a4
    libmin_printf("found item: %ld\n", *(int32_t *)*v26);
    int32_t * v27 = DeleteByElement((int32_t *)v23, (int32_t *)*v26); // 0x12bb
    int64_t v28; // 0x10e0
    if (v27 == NULL) {
        // 0x1488
        libmin_printf("failure!\n");
        v28 = v23;
    } else {
        int64_t v29 = (int64_t)v27; // 0x12bb
        libmin_printf("success! new root: %ld\n", *(int32_t *)*(int64_t *)(v29 + 16));
        v28 = v29;
    }
    // 0x12e0
    libmin_printf("\n");
    printTree_part_0(v28, 0);
    int64_t * v30 = (int64_t *)(v28 + 8); // 0x12fb
    int64_t v31; // 0x10e0
    int64_t v32 = breadth(*v30, 0, v5, 24, v31); // 0x12ff
    int64_t * v33 = (int64_t *)v28; // 0x1304
    int64_t v34 = *v33; // 0x1304
    libmin_printf("breadth of left tree: %ld right subtree: %ld\n", (int32_t)breadth(v34, 0, v5, 24, v31), (int32_t)v32);
    int64_t v35 = Height(*v33); // 0x1328
    int64_t v36 = *v30; // 0x132d
    libmin_printf("height of left subtree: %ld right subtree: %ld\n", (int32_t)v35, (int32_t)Height(v36));
    int64_t v37 = v35; // 0x134d
    int64_t v38 = v28; // 0x134d
    int64_t v39 = 3; // 0x134d
    int64_t v40; // 0x10e0
    int64_t v41; // 0x10e0
    int64_t v42; // 0x10e0
    int64_t v43; // 0x10e0
    int64_t v44; // 0x10e0
    int64_t v45; // 0x10e0
    int64_t v46; // 0x10e0
    while (true) {
        int64_t v47 = v39;
        int64_t v48 = v38;
        uint64_t v49 = v37;
        int128_t v50; // 0x10e0
        int128_t v51 = v50;
        libmin_printf("\n");
        int64_t v52 = (int64_t)libmin_rand() % v49; // 0x1371
        libmin_printf("Going to delete a node at depth (max depth %ld): %ld\n", (int32_t)v49, (int32_t)v52);
        v40 = v48;
        v42 = v52;
        while (true) {
          lab_0x13a5_2:
            // 0x13a5
            v43 = v42;
            int64_t v53 = v40;
            int64_t v54 = *(int64_t *)v53; // 0x13a5
            int64_t * v55 = (int64_t *)(v53 + 8); // 0x13a9
            int64_t v56 = *v55; // 0x13a9
            if (v54 != 0) {
                // 0x1380
                v44 = v54;
                if (v56 == 0) {
                    goto lab_0x1399;
                } else {
                    // 0x1385
                    if (libmin_rand() < 0x3fffffff) {
                        // 0x1395
                        int64_t * v57; // 0x13a5
                        int64_t v58 = *v57; // 0x1395
                        v44 = v58;
                        goto lab_0x1399;
                    } else {
                        // 0x1458
                        v46 = *v55;
                        goto lab_0x13b8;
                    }
                }
            } else {
                // 0x13b3
                v46 = v56;
                v41 = v53;
                if (v56 == 0) {
                    // break -> 0x13c4
                    break;
                }
                goto lab_0x13b8;
            }
        }
      lab_0x13c4_2:;
        int64_t * v59 = (int64_t *)(v41 + 16); // 0x13c4
        int64_t v60 = *(int64_t *)(v41 + 24); // 0x13c9
        int32_t v61 = *(int32_t *)*v59; // 0x13d5
        libmin_printf("Found a node to delete with Name '%s' and Item %ld\n", (char *)v60, v61);
        int32_t * v62 = DeleteByElement((int32_t *)v48, (int32_t *)*v59); // 0x13e6
        int64_t v63; // 0x10e0
        if (v62 == NULL) {
            // 0x1462
            libmin_printf("failure!\n");
            v63 = v48;
        } else {
            int64_t v64 = (int64_t)v62; // 0x13e6
            libmin_printf("success! new root: %ld\n", *(int32_t *)*(int64_t *)(v64 + 16));
            v63 = v64;
        }
        // 0x1411
        v45 = v63;
        __asm_pxor(v51, v51);
        int64_t v65 = v47 - 1; // 0x1415
        int128_t v66 = __asm_mulsd(__asm_cvtsi2sd(v49), 0x3fe3333333333333); // 0x141f
        int32_t v67 = __asm_cvttsd2si(v66); // 0x1427
        v50 = v66;
        v37 = v67;
        v38 = v45;
        v39 = v65;
        if (v65 == 0) {
            // break -> 0x1434
            break;
        }
    }
    // 0x1434
    MakeEmpty(v45);
    libmin_success();
    // UNREACHABLE
  lab_0x1399:;
    int64_t v68 = v43 - 1; // 0x1399
    int64_t v69 = v44; // 0x13a3
    int64_t v70 = v68; // 0x13a3
    if (v68 < 1) {
        // break -> 0x13c4
        goto lab_0x13c4_2;
    }
    goto lab_0x13a5;
  lab_0x13b8:;
    int64_t v71 = v43 - 1; // 0x13b8
    v69 = v46;
    v70 = v71;
    v41 = v46;
    if (v71 >= 0 != v71 != 0) {
        // break -> 0x13c4
        goto lab_0x13c4_2;
    }
    goto lab_0x13a5;
  lab_0x13a5:
    // 0x13a5
    v40 = v69;
    v42 = v70;
    goto lab_0x13a5_2;
  lab_0x1118:
    // 0x1118
    v11 = (int64_t)v6;
    libmin_printf(".");
    v1 = v11;
    v3 = v4 + 1;
    if (v4 == 24) {
        // break -> 0x11c5
        goto lab_0x11c5;
    }
    goto lab_0x1137;
}

// Address range: 0x14c0 - 0x14e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x14c0
    int64_t v1; // 0x14c0
    __libc_start_main(0x10e0, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x14f0 - 0x1519
int64_t deregister_tm_clones(void) {
    // 0x14f0
    return 0x8230;
}

// Address range: 0x1520 - 0x1559
int64_t register_tm_clones(void) {
    // 0x1520
    return 0;
}

// Address range: 0x1560 - 0x1599
int64_t __do_global_dtors_aux(void) {
    // 0x1560
    if (g11 != 0) {
        // 0x1598
        int64_t result; // 0x1560
        return result;
    }
    // 0x156d
    if (*(int64_t *)0x7ff8 != 0) {
        // 0x157b
        __cxa_finalize((int64_t *)*(int64_t *)0x8008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1587
    g11 = 1;
    return result2;
}

// Address range: 0x15a0 - 0x15a9
int64_t frame_dummy(void) {
    // 0x15a0
    return register_tm_clones();
}

// Address range: 0x15b0 - 0x1700
int64_t printTree_part_0(int64_t a1, int32_t a2) {
    int64_t v1 = a2;
    int64_t v2 = v1 + 1; // 0x15c0
    int16_t v3 = *(int16_t *)(a1 + 32); // 0x15cc
    int64_t v4 = *(int64_t *)(a1 + 24); // 0x15d0
    int32_t v5 = *(int32_t *)*(int64_t *)(a1 + 16); // 0x15db
    libmin_printf("%s -> %ld, Balance %d\n", (char *)v4, v5, (int64_t)v3);
    int64_t v6 = 0; // 0x15e7
    int32_t v7; // 0x15b0
    int64_t result2; // 0x15b0
    int64_t v8; // 0x15b0
    if (a2 < 1) {
        // 0x16b0
        libmin_printf("Left: ");
        int32_t v9 = v2;
        printTree_part_0((int64_t)"Left: ", v9);
        libmin_printf("\n");
        int32_t v10 = libmin_printf("Right: "); // 0x16e9
        int64_t v11 = *(int64_t *)(a1 + 8); // 0x16ee
        v7 = v9;
        v8 = v11;
        result2 = v10;
        if (v11 != 0) {
            goto lab_0x1672;
        } else {
            goto lab_0x167a;
        }
    } else {
        v6++;
        libmin_printf(" ");
        while (v6 != v1) {
            // 0x1600
            v6++;
            libmin_printf(" ");
        }
        // 0x1613
        libmin_printf("Left: ");
        int32_t v12 = v2;
        printTree_part_0((int64_t)"Left: ", v12);
        libmin_printf("\n");
        int64_t v13 = 0; // 0x1645
        v13++;
        libmin_printf(" ");
        while (v13 != v1) {
            // 0x1648
            v13++;
            libmin_printf(" ");
        }
        int32_t result = libmin_printf("Right: "); // 0x1664
        int64_t v14 = *(int64_t *)(a1 + 8); // 0x1669
        v7 = v12;
        v8 = v14;
        if (v14 == 0) {
            // 0x167f
            return result;
        }
        goto lab_0x1672;
    }
  lab_0x1672:
    // 0x1672
    result2 = printTree_part_0(v8, v7);
    goto lab_0x167a;
  lab_0x167a:
    // 0x167a
    if (a2 == 0) {
        // 0x1690
        return libmin_printf("\n");
    }
    // 0x167f
    return result2;
}

// Address range: 0x1700 - 0x1711
int64_t printTree(int64_t a1) {
    // 0x1700
    int64_t result; // 0x1700
    if (a1 == 0) {
        // 0x1710
        return result;
    }
    // 0x1709
    return printTree_part_0(a1, (int32_t)result);
}

// Address range: 0x1720 - 0x1a89
int64_t breadth(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = 0; // 0x1727
    if (a1 == 0) {
        // 0x18f2
        return 0;
    }
    int64_t v2 = a1; // 0x1727
    int64_t v3; // 0x1720
    int64_t v4; // 0x1720
    while (true) {
      lab_0x1746_2:
        // 0x1746
        v4 = v1;
        int64_t v5 = v2; // 0x1a6b
        while (true) {
            // 0x1746
            v3 = v5;
            if (*(int64_t *)v3 != 0) {
                goto lab_0x1762_2;
            }
            // 0x1a6b
            v5 = *(int64_t *)(v3 + 8);
            if (v5 == 0) {
                return v4 + 1;
            }
        }
        goto lab_0x1a41;
    }
  lab_0x1a78:
    // 0x18f2
    return v4 + 1;
  lab_0x1762:
    // 0x1762
    goto lab_0x1762_2;
  lab_0x1a41:
    // 0x1a41
    v2 = *(int64_t *)(v3 + 8);
    v1 = 1 + v4;
    int64_t result = v1; // 0x1a60
    if (v2 == 0) {
        // 0x18f2
        return result;
    }
    // 0x1746
    goto lab_0x1746_2;
  lab_0x1762_2:;
    // 0x1762
    int64_t v6; // 0x1720
    int64_t v7 = v6;
    int64_t v8 = *(int64_t *)v7; // 0x1762
    int32_t v9 = 0; // 0x176b
    int64_t v10 = v8; // 0x176b
    if (v8 == 0) {
        int64_t v11 = *(int64_t *)(v7 + 8); // 0x1a34
        v6 = v11;
        if (v11 != 0) {
            goto lab_0x1762_2;
        } else {
            goto lab_0x1a41;
        }
    } else {
        goto lab_0x177e;
    }
  lab_0x177e:;
    int32_t v12 = v9;
    int64_t v13 = v10; // 0x1720
    goto lab_0x177e_2;
  lab_0x177e_2:;
    int64_t v14 = v13;
    int64_t v15 = *(int64_t *)v14; // 0x177e
    int64_t v16 = v15; // 0x1787
    int64_t v17 = 0; // 0x1787
    if (v15 == 0) {
        int64_t v18 = *(int64_t *)(v14 + 8); // 0x19fe
        v13 = v18;
        if (v18 != 0) {
            goto lab_0x177e_2;
        } else {
            // 0x1a0b
            if (*(int64_t *)(v7 + 8) != 0) {
                goto lab_0x1762_3;
            } else {
                goto lab_0x18d2;
            }
        }
    } else {
        goto lab_0x1795;
    }
  lab_0x1795:;
    int64_t v19 = v17;
    int64_t v20 = v16; // 0x1720
    goto lab_0x1795_2;
  lab_0x1795_2:;
    int64_t v21 = v20;
    int64_t v22 = *(int64_t *)v21; // 0x1795
    int64_t v23 = 0; // 0x179d
    int64_t v24 = v22; // 0x179d
    int32_t v25; // 0x1720
    if (v22 == 0) {
        int64_t v26 = *(int64_t *)(v21 + 8); // 0x1904
        v20 = v26;
        if (v26 != 0) {
            goto lab_0x1795_2;
        } else {
            // 0x1911
            v25 = (int32_t)v19 + 1;
            goto lab_0x18ae;
        }
    } else {
        goto lab_0x18d2;
    }
  lab_0x1762_3:
    // 0x1762
    goto lab_0x1762;
  lab_0x18d2:;
    int64_t v27 = v23;
    int64_t v28 = v24; // 0x1720
    goto lab_0x17b0_2;
  lab_0x17b0_2:;
    int64_t v29 = v28;
    int64_t v30 = *(int64_t *)v29; // 0x17b0
    int64_t v31 = 0; // 0x17ba
    int64_t v32 = v30; // 0x17ba
    int64_t v33; // 0x1720
    if (v30 == 0) {
        int64_t v34 = *(int64_t *)(v29 + 8); // 0x1994
        v28 = v34;
        if (v34 != 0) {
            goto lab_0x17b0_2;
        } else {
            // 0x19a1
            v33 = v27 + 1;
            goto lab_0x1894;
        }
    } else {
        goto lab_0x17cd;
    }
  lab_0x18ae:;
    int64_t v35 = *(int64_t *)(v14 + 8);
    v9 = v25 + v12;
    v10 = v35;
    if (v35 != 0) {
        goto lab_0x177e;
    } else {
        // 0x18b7
        if (*(int64_t *)(v7 + 8) != 0) {
            goto lab_0x1762_3;
        } else {
            goto lab_0x18d2;
        }
    }
  lab_0x17cd:;
    int64_t v36 = v31;
    int64_t v37 = v32; // 0x1720
    goto lab_0x17cd_2;
  lab_0x17cd_2:;
    int64_t v38 = v37;
    int64_t v39 = *(int64_t *)v38; // 0x17cd
    int64_t v40 = 0; // 0x17d7
    int64_t v41 = v39; // 0x17d7
    int64_t v42; // 0x1720
    if (v39 == 0) {
        int64_t v43 = *(int64_t *)(v38 + 8); // 0x196b
        v37 = v43;
        if (v43 != 0) {
            goto lab_0x17cd_2;
        } else {
            // 0x1979
            v42 = v27 + 1 + v36;
            goto lab_0x1877;
        }
    } else {
        goto lab_0x17f0;
    }
  lab_0x1894:;
    int64_t v44 = v33 + v19;
    int64_t v45 = *(int64_t *)(v21 + 8);
    v16 = v45;
    v17 = v44;
    if (v45 != 0) {
        goto lab_0x1795;
    } else {
        // 0x189d
        v25 = v44;
        goto lab_0x18ae;
    }
  lab_0x17f0:;
    int64_t v46 = v40;
    int64_t v47 = v41; // 0x1720
    goto lab_0x17f0_2;
  lab_0x17f0_2:;
    int64_t v48 = v47;
    int64_t v49 = *(int64_t *)v48; // 0x17f0
    int64_t v50 = v49; // 0x17f9
    int64_t v51 = 0; // 0x17f9
    int64_t v52; // 0x1720
    if (v49 == 0) {
        int64_t v53 = *(int64_t *)(v48 + 8); // 0x19c0
        v47 = v53;
        if (v53 != 0) {
            goto lab_0x17f0_2;
        } else {
            // 0x19cd
            v52 = v36 + 1 + v46;
            goto lab_0x185a;
        }
    } else {
        goto lab_0x1800;
    }
  lab_0x1877:;
    int64_t v54 = *(int64_t *)(v29 + 8);
    v23 = v42;
    v24 = v54;
    v33 = v42;
    if (v54 != 0) {
        goto lab_0x18d2;
    } else {
        goto lab_0x1894;
    }
  lab_0x1800:;
    int64_t v55 = v51;
    int64_t v56 = v50; // 0x1720
    goto lab_0x1800_2;
  lab_0x1800_2:;
    int64_t v57 = v56;
    int64_t v58 = *(int64_t *)v57; // 0x1800
    int64_t v59 = v58; // 0x1809
    int64_t v60 = 0; // 0x1809
    int64_t v61; // 0x1720
    if (v58 == 0) {
        int64_t v62 = *(int64_t *)(v57 + 8); // 0x1950
        v56 = v62;
        if (v62 != 0) {
            goto lab_0x1800_2;
        } else {
            // 0x195d
            v61 = v46 + 1 + v55;
            goto lab_0x1840;
        }
    } else {
        goto lab_0x1810;
    }
  lab_0x185a:;
    int64_t v63 = v52;
    int64_t v64 = *(int64_t *)(v38 + 8);
    v31 = v63;
    v32 = v64;
    if (v64 != 0) {
        goto lab_0x17cd;
    } else {
        // 0x1863
        v42 = v63 + v27;
        goto lab_0x1877;
    }
  lab_0x1810:;
    int64_t v65 = v60;
    int64_t v66 = v59;
    int64_t v67 = *(int64_t *)v66; // 0x1810
    int64_t v68; // 0x1720
    int64_t v69; // 0x1720
    int64_t v70; // 0x1720
    int64_t v71; // 0x1720
    int64_t v72; // 0x1746
    if (v67 == 0) {
        int64_t v73 = *(int64_t *)(v66 + 8); // 0x1930
        if (v73 == 0) {
            // 0x19f0
            v71 = v55 + 1 + v65;
            goto lab_0x1834;
        } else {
            // 0x193d
            v68 = v73;
            v69 = breadth(0, v72, v70, 0, 0) + v65;
            goto lab_0x1810_2;
        }
    } else {
        int64_t v74 = breadth(v67, v72, v70, 0, 0); // 0x181c
        int64_t v75 = *(int64_t *)(v66 + 8); // 0x1821
        int64_t v76 = v74 + v65; // 0x1825
        v68 = v75;
        v69 = v76;
        if (v75 != 0) {
            goto lab_0x1810_2;
        } else {
            // 0x182d
            v71 = v76 + v55;
            goto lab_0x1834;
        }
    }
  lab_0x1840:;
    int64_t v77 = v61;
    int64_t v78 = *(int64_t *)(v48 + 8);
    v40 = v77;
    v41 = v78;
    if (v78 != 0) {
        goto lab_0x17f0;
    } else {
        // 0x1845
        v52 = v77 + v36;
        goto lab_0x185a;
    }
  lab_0x1810_2:
    // 0x1810
    v59 = v68;
    v60 = v69;
    goto lab_0x1810;
  lab_0x1834:;
    int64_t v79 = v71;
    int64_t v80 = *(int64_t *)(v57 + 8);
    v50 = v80;
    v51 = v79;
    if (v80 != 0) {
        goto lab_0x1800;
    } else {
        // 0x1839
        v61 = v79 + v46;
        goto lab_0x1840;
    }
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/element.c
// Address range: 0x1a90 - 0x1aa8
// Line range:    4 - 11
int16_t Compare(int32_t * Data1, int32_t * Data2) {
    int16_t result = 1; // 0x1a9d
    int64_t v1; // 0x1a90
    if (0x100000000 * v1 >> 32 <= (v1 & 0xffffffff)) {
        int32_t v2 = v1;
        int32_t v3 = v2 - (int32_t)v1; // 0x1a9b
        result = v3 < 0 != ((v3 ^ v2) & (int32_t)(v1 ^ v1)) < 0;
    }
    // 0x1aa7
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/element.c
// Address range: 0x1ab0 - 0x1ab9
// Line range:    13 - 15
void FreeElement(int32_t * Data) {
    // 0x1ab0
    libmin_free((int64_t)Data);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avlcore.c
// Address range: 0x1ac0 - 0x1b3e
// Line range:    8 - 31
int32_t * FindByElement(int32_t * rootNode, int32_t * Data) {
    if (rootNode == NULL || Data == NULL) {
        // 0x1b30
        return NULL;
    }
    int64_t v1 = (int64_t)rootNode;
    int64_t v2 = *(int64_t *)(v1 + 16); // 0x1ad8
    if (v2 == 0) {
        // 0x1b30
        return NULL;
    }
    uint16_t v3 = Compare((int32_t *)v2, Data); // 0x1aeb
    int64_t v4 = v1; // 0x1af3
    if (v3 >= 0) {
        // 0x1af5
        if (v3 == 0) {
            // break -> 0x1af7
            break;
        }
        // 0x1b20
        v4 = v1 + 8;
    }
    int64_t v5 = *(int64_t *)v4;
    int64_t v6 = v5; // 0x1b0f
    while (v3 != 0 && v5 != 0) {
        int64_t v7 = v5;
        v3 = Compare((int32_t *)*(int64_t *)(v5 + 16), Data);
        v4 = v7;
        if (v3 >= 0) {
            // 0x1af5
            v6 = v7;
            if (v3 == 0) {
                // break -> 0x1af7
                break;
            }
            // 0x1b20
            v4 = v7 + 8;
        }
        // 0x1b0c
        v5 = *(int64_t *)v4;
        v6 = v5;
    }
    // 0x1af7
    return (int32_t *)v6;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avlcore.c
// Address range: 0x1b40 - 0x1b4d
// Line range:    33 - 36
int16_t IsEmpty(int32_t * rootNode) {
    // 0x1b40
    return (bool)(rootNode == NULL);
}

// Address range: 0x1b50 - 0x1b63
int64_t SingleRightRotation(int64_t result) {
    int64_t * v1 = (int64_t *)(result + 8); // 0x1b57
    *(int64_t *)result = *v1;
    *v1 = result;
    return result;
}

// Address range: 0x1b70 - 0x1b83
int64_t SingleLeftRotation(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1b74
    int64_t result = *v1; // 0x1b74
    int64_t * v2 = (int64_t *)result; // 0x1b78
    *v1 = *v2;
    *v2 = a1;
    return result;
}

// Address range: 0x1b90 - 0x1bb1
int64_t DoubleRightRotation(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1b97
    int64_t result = *v1; // 0x1b97
    int64_t * v2 = (int64_t *)result; // 0x1b9b
    *v1 = *v2;
    *v2 = a1;
    int64_t * v3 = (int64_t *)(result + 8); // 0x1ba5
    *(int64_t *)a1 = *v3;
    *v3 = a1;
    return result;
}

// Address range: 0x1bc0 - 0x1be1
int64_t DoubleLeftRotation(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1bc4
    int64_t v2 = *v1; // 0x1bc4
    int64_t * v3 = (int64_t *)v2; // 0x1bc8
    int64_t result = *v3; // 0x1bc8
    int64_t * v4 = (int64_t *)(result + 8); // 0x1bcb
    *v3 = *v4;
    *v4 = v2;
    int64_t * v5 = (int64_t *)result; // 0x1bd6
    *v1 = *v5;
    *v5 = a1;
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avlcore.c
// Address range: 0x1bf0 - 0x1db0
// Line range:    72 - 90
int32_t * CheckTreeNodeRotation(int32_t * tnode, int32_t * subtree, int16_t * finished) {
    int64_t v1 = (int64_t)subtree;
    int64_t v2 = (int64_t)tnode;
    int16_t * v3 = (int16_t *)(v2 + 32); // 0x1bf4
    int16_t * v4; // 0x1c20
    int16_t v5; // 0x1c20
    switch (*v3) {
        case 0: {
            // 0x1c98
            *finished = 1;
            return tnode;
        }
        case 2: {
            // 0x1c58
            *finished = 1;
            int16_t * v6 = (int16_t *)(v1 + 32); // 0x1c62
            int16_t v7 = *v6; // 0x1c62
            if (v7 != -1) {
                if (v7 != 1) {
                    // 0x1c10
                    return tnode;
                }
                int64_t * v8 = (int64_t *)(v2 + 8); // 0x1c72
                int64_t v9 = *v8; // 0x1c72
                *v3 = 0;
                int64_t * v10 = (int64_t *)v9; // 0x1c81
                *v6 = 0;
                *v8 = *v10;
                *v10 = v2;
                return (int32_t *)v9;
            }
            // 0x1cd1
            *v6 = 1;
            *v3 = 0;
            int64_t * v11 = (int64_t *)(v2 + 8); // 0x1cd1
            int64_t v12 = *v11; // 0x1cd1
            *v6 = 0;
            int64_t * v13 = (int64_t *)v12; // 0x1cdd
            int64_t v14 = *v13; // 0x1cdd
            int64_t * v15 = (int64_t *)(v14 + 8); // 0x1ce0
            *v13 = *v15;
            *v15 = v12;
            int64_t * v16 = (int64_t *)v14; // 0x1ceb
            *v11 = *v16;
            *v16 = v2;
            return (int32_t *)v14;
        }
        case -2: {
            // 0x1c18
            *finished = 1;
            v4 = (int16_t *)(v1 + 32);
            v5 = *v4;
            if (v5 == 1) {
                int16_t * v17 = (int16_t *)(*(int64_t *)(v1 + 8) + 32); // 0x1d04
                int64_t v18; // 0x1bf0
                switch (*v17) {
                    case -1: {
                        // 0x1d80
                        *v4 = 0;
                        *v3 = 1;
                        v18 = 1;
                        // break -> 0x1d22
                        break;
                    }
                    case 1: {
                        // 0x1d50
                        *v4 = -1;
                        *v3 = 0;
                        v18 = 1;
                        // break -> 0x1d22
                        break;
                    }
                    default: {
                        // 0x1d14
                        *v3 = 0;
                        *v4 = 0;
                        v18 = 0;
                        // break -> 0x1d22
                        break;
                    }
                }
                // 0x1d22
                *v17 = 0;
                int64_t * v19 = (int64_t *)(v18 | 8); // 0x1d2b
                int64_t v20 = *v19; // 0x1d2b
                int64_t * v21 = (int64_t *)v20; // 0x1d2f
                *v19 = *v21;
                *v21 = v18;
                int64_t * v22 = (int64_t *)(v20 + 8); // 0x1d39
                *(int64_t *)tnode = *v22;
                *v22 = v2;
                return (int32_t *)v20;
            }
            // break -> 0x1c2e
            break;
        }
        default: {
            // 0x1c10
            return tnode;
        }
    }
    if (v5 != -1) {
        // 0x1c10
        return tnode;
    }
    // 0x1c34
    *v3 = 0;
    *v4 = 0;
    *(int64_t *)tnode = *(int64_t *)9;
    *(int64_t *)9 = v2;
    return (int32_t *)1;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avlcore.c
// Address range: 0x1db0 - 0x1ee4
// Line range:    128 - 177
int32_t * InsertNode(int32_t * tnode, int32_t * Item, char * Name, int16_t * finished) {
    int64_t v1 = (int64_t)finished;
    int64_t v2 = v1;
    if (tnode == NULL) {
        int64_t v3 = libmin_malloc(40); // 0x1e45
        if (v3 == 0) {
            // 0x1e1b
            return (int32_t *)0;
        }
        // 0x1e4f
        *(int64_t *)v3 = 0;
        *(int64_t *)(v3 + 8) = 0;
        *(int64_t *)(v3 + 16) = (int64_t)Item;
        *(int64_t *)(v3 + 24) = (int64_t)Name;
        *(int16_t *)(v3 + 32) = 0;
        return (int32_t *)v3;
    }
    int64_t v4 = (int64_t)tnode;
    int16_t v5 = v1;
    int16_t v6 = Compare(Item, (int32_t *)*(int64_t *)(v4 + 16)); // 0x1dd7
    if (v6 < 0) {
        int32_t * v7 = InsertNode(Item, Item, Name, finished); // 0x1e9d
        if (v7 == NULL) {
            // 0x1e30
            return NULL;
        }
        int16_t v8 = v5; // 0x1eb2
        if (v5 == 0) {
            int16_t * v9 = (int16_t *)(v4 + 32); // 0x1eb4
            *v9 = *v9 - 1;
            v8 = *(int16_t *)&v2;
        }
        int64_t v10 = (int64_t)v7; // 0x1e9d
        *(int64_t *)tnode = v10;
        if (v8 != 0) {
            // 0x1e1b
            return (int32_t *)v4;
        }
        // 0x1ece
        return CheckTreeNodeRotation(tnode, (int32_t *)v10, finished);
    }
    if (v6 == 0) {
        // 0x1e30
        return NULL;
    }
    int64_t * v11 = (int64_t *)(v4 + 8); // 0x1de7
    int32_t * v12 = InsertNode((int32_t *)*v11, Item, Name, finished); // 0x1df4
    if (v12 == NULL) {
        // 0x1e30
        return NULL;
    }
    int64_t v13 = (int64_t)v12; // 0x1df4
    if (v5 != 0) {
        // 0x1e0b
        *v11 = v13;
        // 0x1e1b
        return (int32_t *)v4;
    }
    int16_t * v14 = (int16_t *)(v4 + 32); // 0x1e80
    *v14 = *v14 + 1;
    *v11 = v13;
    if (*(int16_t *)&v2 == 0) {
        // 0x1ece
        return CheckTreeNodeRotation(tnode, (int32_t *)v13, finished);
    }
    // 0x1e1b
    return (int32_t *)v4;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avlcore.c
// Address range: 0x1ef0 - 0x1f40
// Line range:    183 - 189
int32_t * Insert(int32_t * tnode, int32_t * Item, char * Name) {
    int64_t v1 = __readfsqword(40); // 0x1ef8
    int64_t v2 = 0; // bp-18, 0x1f0f
    int32_t * result = InsertNode(tnode, Item, Name, (int16_t *)&v2); // 0x1f14
    if (v1 == __readfsqword(40)) {
        // 0x1f29
        return result;
    }
    // 0x1f2e
    __stack_chk_fail();
    return &g16;
}

// Address range: 0x1f40 - 0x25c9
int64_t MakeEmpty(int64_t a1) {
    // 0x1f40
    if (a1 == 0) {
        // 0x25c8
        int64_t result; // 0x1f40
        return result;
    }
    // 0x1f8c
    MakeEmpty(a1);
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1f94
    MakeEmpty(*v1);
    int64_t * v2 = (int64_t *)(a1 + 16); // 0x1f9d
    FreeElement((int32_t *)*v2);
    int64_t * v3 = (int64_t *)(a1 + 24); // 0x1fa6
    libmin_free(*v3);
    libmin_free(a1);
    int64_t v4 = *v1; // 0x1fb7
    if (v4 != 0) {
        // 0x1fc0
        MakeEmpty(*(int64_t *)v4);
        MakeEmpty(*(int64_t *)(v4 + 8));
        FreeElement((int32_t *)*(int64_t *)(v4 + 16));
        libmin_free(*(int64_t *)(v4 + 24));
        libmin_free(v4);
    }
    // 0x1feb
    FreeElement((int32_t *)*v2);
    libmin_free(*v3);
    libmin_free(a1);
    int64_t v5 = *v1; // 0x2005
    if (v5 != 0) {
        int64_t v6 = *(int64_t *)v5; // 0x2012
        if (v6 != 0) {
            // 0x201a
            MakeEmpty(*(int64_t *)v6);
            MakeEmpty(*(int64_t *)(v6 + 8));
            FreeElement((int32_t *)*(int64_t *)(v6 + 16));
            libmin_free(*(int64_t *)(v6 + 24));
            libmin_free(v6);
        }
        int64_t v7 = *(int64_t *)(v5 + 8); // 0x2045
        if (v7 != 0) {
            // 0x204e
            MakeEmpty(*(int64_t *)v7);
            MakeEmpty(*(int64_t *)(v7 + 8));
            FreeElement((int32_t *)*(int64_t *)(v7 + 16));
            libmin_free(*(int64_t *)(v7 + 24));
            libmin_free(v7);
        }
        // 0x2079
        FreeElement((int32_t *)*(int64_t *)(v5 + 16));
        libmin_free(*(int64_t *)(v5 + 24));
        libmin_free(v5);
    }
    // 0x2093
    FreeElement((int32_t *)*v2);
    libmin_free(*v3);
    libmin_free(a1);
    int64_t v8 = *v1; // 0x20ad
    if (v8 != 0) {
        int64_t v9 = *(int64_t *)v8; // 0x20bb
        if (v9 != 0) {
            int64_t v10 = *(int64_t *)v9; // 0x20c8
            if (v10 != 0) {
                // 0x20d0
                MakeEmpty(*(int64_t *)v10);
                MakeEmpty(*(int64_t *)(v10 + 8));
                FreeElement((int32_t *)*(int64_t *)(v10 + 16));
                libmin_free(*(int64_t *)(v10 + 24));
                libmin_free(v10);
            }
            int64_t v11 = *(int64_t *)(v9 + 8); // 0x20fb
            if (v11 != 0) {
                // 0x2104
                MakeEmpty(*(int64_t *)v11);
                MakeEmpty(*(int64_t *)(v11 + 8));
                FreeElement((int32_t *)*(int64_t *)(v11 + 16));
                libmin_free(*(int64_t *)(v11 + 24));
                libmin_free(v11);
            }
            // 0x212f
            FreeElement((int32_t *)*(int64_t *)(v9 + 16));
            libmin_free(*(int64_t *)(v9 + 24));
            libmin_free(v9);
        }
        int64_t v12 = *(int64_t *)(v8 + 8); // 0x2149
        if (v12 != 0) {
            int64_t v13 = *(int64_t *)v12; // 0x2156
            if (v13 != 0) {
                // 0x215e
                MakeEmpty(*(int64_t *)v13);
                MakeEmpty(*(int64_t *)(v13 + 8));
                FreeElement((int32_t *)*(int64_t *)(v13 + 16));
                libmin_free(*(int64_t *)(v13 + 24));
                libmin_free(v13);
            }
            int64_t v14 = *(int64_t *)(v12 + 8); // 0x2189
            if (v14 != 0) {
                // 0x2192
                MakeEmpty(*(int64_t *)v14);
                MakeEmpty(*(int64_t *)(v14 + 8));
                FreeElement((int32_t *)*(int64_t *)(v14 + 16));
                libmin_free(*(int64_t *)(v14 + 24));
                libmin_free(v14);
            }
            // 0x21bd
            FreeElement((int32_t *)*(int64_t *)(v12 + 16));
            libmin_free(*(int64_t *)(v12 + 24));
            libmin_free(v12);
        }
        // 0x21d7
        FreeElement((int32_t *)*(int64_t *)(v8 + 16));
        libmin_free(*(int64_t *)(v8 + 24));
        libmin_free(v8);
    }
    // 0x21f1
    FreeElement((int32_t *)*v2);
    libmin_free(*v3);
    libmin_free(a1);
    int64_t v15 = *v1; // 0x220d
    if (v15 != 0) {
        int64_t v16 = *(int64_t *)v15; // 0x221a
        if (v16 != 0) {
            int64_t v17 = *(int64_t *)v16; // 0x2227
            if (v17 != 0) {
                int64_t v18 = *(int64_t *)v17; // 0x2234
                if (v18 != 0) {
                    // 0x223c
                    MakeEmpty(*(int64_t *)v18);
                    MakeEmpty(*(int64_t *)(v18 + 8));
                    FreeElement((int32_t *)*(int64_t *)(v18 + 16));
                    libmin_free(*(int64_t *)(v18 + 24));
                    libmin_free(v18);
                }
                int64_t v19 = *(int64_t *)(v17 + 8); // 0x2267
                if (v19 != 0) {
                    // 0x2270
                    MakeEmpty(*(int64_t *)v19);
                    MakeEmpty(*(int64_t *)(v19 + 8));
                    FreeElement((int32_t *)*(int64_t *)(v19 + 16));
                    libmin_free(*(int64_t *)(v19 + 24));
                    libmin_free(v19);
                }
                // 0x229b
                FreeElement((int32_t *)*(int64_t *)(v17 + 16));
                libmin_free(*(int64_t *)(v17 + 24));
                libmin_free(v17);
            }
            int64_t v20 = *(int64_t *)(v16 + 8); // 0x22b5
            if (v20 != 0) {
                int64_t v21 = *(int64_t *)v20; // 0x22c2
                if (v21 != 0) {
                    int64_t v22 = *(int64_t *)v21; // 0x22ce
                    if (v22 != 0) {
                        // 0x22d6
                        MakeEmpty(*(int64_t *)v22);
                        MakeEmpty(*(int64_t *)(v22 + 8));
                        FreeElement((int32_t *)*(int64_t *)(v22 + 16));
                        libmin_free(*(int64_t *)(v22 + 24));
                        libmin_free(v22);
                    }
                    int64_t v23 = *(int64_t *)(v21 + 8); // 0x2301
                    if (v23 != 0) {
                        // 0x230a
                        MakeEmpty(*(int64_t *)v23);
                        MakeEmpty(*(int64_t *)(v23 + 8));
                        FreeElement((int32_t *)*(int64_t *)(v23 + 16));
                        libmin_free(*(int64_t *)(v23 + 24));
                        libmin_free(v23);
                    }
                    // 0x2335
                    FreeElement((int32_t *)*(int64_t *)(v21 + 16));
                    libmin_free(*(int64_t *)(v21 + 24));
                    libmin_free(v21);
                }
                int64_t v24 = *(int64_t *)(v20 + 8); // 0x234f
                if (v24 != 0) {
                    int64_t v25 = *(int64_t *)v24; // 0x235c
                    if (v25 != 0) {
                        // 0x2364
                        MakeEmpty(*(int64_t *)v25);
                        MakeEmpty(*(int64_t *)(v25 + 8));
                        FreeElement((int32_t *)*(int64_t *)(v25 + 16));
                        libmin_free(*(int64_t *)(v25 + 24));
                        libmin_free(v25);
                    }
                    int64_t v26 = *(int64_t *)(v24 + 8); // 0x238f
                    if (v26 != 0) {
                        // 0x2398
                        MakeEmpty(*(int64_t *)v26);
                        MakeEmpty(*(int64_t *)(v26 + 8));
                        FreeElement((int32_t *)*(int64_t *)(v26 + 16));
                        libmin_free(*(int64_t *)(v26 + 24));
                        libmin_free(v26);
                    }
                    // 0x23c3
                    FreeElement((int32_t *)*(int64_t *)(v24 + 16));
                    libmin_free(*(int64_t *)(v24 + 24));
                    libmin_free(v24);
                }
                // 0x23dd
                FreeElement((int32_t *)*(int64_t *)(v20 + 16));
                libmin_free(*(int64_t *)(v20 + 24));
                libmin_free(v20);
            }
            // 0x23f7
            FreeElement((int32_t *)*(int64_t *)(v16 + 16));
            libmin_free(*(int64_t *)(v16 + 24));
            libmin_free(v16);
        }
        int64_t v27 = *(int64_t *)(v15 + 8); // 0x2411
        if (v27 != 0) {
            int64_t v28 = *(int64_t *)v27; // 0x241f
            if (v28 != 0) {
                int64_t v29 = *(int64_t *)v28; // 0x242c
                if (v29 != 0) {
                    int64_t v30 = *(int64_t *)v29; // 0x2434
                    if (v30 != 0) {
                        // 0x243c
                        MakeEmpty(*(int64_t *)v30);
                        MakeEmpty(*(int64_t *)(v30 + 8));
                        FreeElement((int32_t *)*(int64_t *)(v30 + 16));
                        libmin_free(*(int64_t *)(v30 + 24));
                        libmin_free(v30);
                    }
                    // 0x2467
                    MakeEmpty(*(int64_t *)(v29 + 8));
                    FreeElement((int32_t *)*(int64_t *)(v29 + 16));
                    libmin_free(*(int64_t *)(v29 + 24));
                    libmin_free(v29);
                }
                int64_t v31 = *(int64_t *)(v28 + 8); // 0x248a
                if (v31 != 0) {
                    // 0x2493
                    MakeEmpty(*(int64_t *)v31);
                    MakeEmpty(*(int64_t *)(v31 + 8));
                    FreeElement((int32_t *)*(int64_t *)(v31 + 16));
                    libmin_free(*(int64_t *)(v31 + 24));
                    libmin_free(v31);
                }
                // 0x24be
                FreeElement((int32_t *)*(int64_t *)(v28 + 16));
                libmin_free(*(int64_t *)(v28 + 24));
                libmin_free(v28);
            }
            int64_t v32 = *(int64_t *)(v27 + 8); // 0x24d8
            if (v32 != 0) {
                int64_t v33 = *(int64_t *)v32; // 0x24e5
                if (v33 != 0) {
                    // 0x24ed
                    MakeEmpty(*(int64_t *)v33);
                    MakeEmpty(*(int64_t *)(v33 + 8));
                    FreeElement((int32_t *)*(int64_t *)(v33 + 16));
                    libmin_free(*(int64_t *)(v33 + 24));
                    libmin_free(v33);
                }
                int64_t v34 = *(int64_t *)(v32 + 8); // 0x2518
                if (v34 != 0) {
                    // 0x2521
                    MakeEmpty(*(int64_t *)v34);
                    MakeEmpty(*(int64_t *)(v34 + 8));
                    FreeElement((int32_t *)*(int64_t *)(v34 + 16));
                    libmin_free(*(int64_t *)(v34 + 24));
                    libmin_free(v34);
                }
                // 0x254c
                FreeElement((int32_t *)*(int64_t *)(v32 + 16));
                libmin_free(*(int64_t *)(v32 + 24));
                libmin_free(v32);
            }
            // 0x2566
            FreeElement((int32_t *)*(int64_t *)(v27 + 16));
            libmin_free(*(int64_t *)(v27 + 24));
            libmin_free(v27);
        }
        // 0x2580
        FreeElement((int32_t *)*(int64_t *)(v15 + 16));
        libmin_free(*(int64_t *)(v15 + 24));
        libmin_free(v15);
    }
    // 0x259c
    FreeElement((int32_t *)*v2);
    libmin_free(*v3);
    return libmin_free(a1);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avlcore.c
// Address range: 0x25d0 - 0x268c
// Line range:    204 - 229
int32_t * DeleteLeftMost(int32_t ** deletedNode, int32_t * rootNode, int16_t * finished) {
    int64_t v1 = (int64_t)rootNode;
    if (rootNode == NULL) {
        int64_t v2 = *(int64_t *)((int64_t)deletedNode + 24); // 0x264b
        libmin_free(v2);
        int64_t v3 = *(int64_t *)(v2 + 16); // 0x2658
        FreeElement((int32_t *)v3);
        *(int64_t *)(v3 + 24) = *(int64_t *)(v1 + 24);
        *(int64_t *)(v3 + 16) = *(int64_t *)(v1 + 16);
        libmin_free(v1);
        return (int32_t *)*(int64_t *)(v1 + 8);
    }
    int32_t * v4 = DeleteLeftMost(deletedNode, rootNode, finished); // 0x25f4
    *(int64_t *)rootNode = (int64_t)v4;
    if ((int16_t)(int64_t)finished != 0) {
        // 0x2605
        return rootNode;
    }
    int16_t * v5 = (int16_t *)(v1 + 32); // 0x2620
    *v5 = *v5 + 1;
    if (v4 == NULL) {
        // 0x2605
        return rootNode;
    }
    // 0x262a
    return CheckTreeNodeRotation(rootNode, v4, finished);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avlcore.c
// Address range: 0x2690 - 0x2820
// Line range:    231 - 282
int32_t * DeleteByElementRecursive(int32_t * rootNode, int32_t * Item, int16_t * finished) {
    int64_t v1 = (int64_t)rootNode;
    int32_t * v2 = rootNode; // bp-48, 0x26a2
    int64_t v3 = __readfsqword(40); // 0x26a7
    int16_t v4 = 0; // bp-34, 0x26b9
    int64_t v5 = v1; // 0x26c1
    int64_t v6; // 0x2690
    if (rootNode == NULL) {
        goto lab_0x2720;
    } else {
        // 0x26c3
        int64_t v7; // 0x2690
        int16_t v8 = v7;
        int64_t v9 = *(int64_t *)(v1 + 16); // 0x26c3
        int32_t * v10 = (int32_t *)v9; // 0x26ca
        int16_t v11 = Compare(v10, Item); // 0x26ca
        v4 = v11;
        if (v11 >= 0 == (v11 != 0)) {
            int32_t * v12 = DeleteByElementRecursive((int32_t *)*(int64_t *)(v1 + 8), Item, finished); // 0x274f
            int64_t v13 = (int64_t)v2; // 0x275d
            *(int64_t *)(v13 + 8) = (int64_t)v12;
            v5 = v13;
            if (v8 == 0 && v12 != NULL) {
                int16_t * v14 = (int16_t *)(v13 + 32); // 0x276d
                *v14 = *v14 - 1;
                v5 = (int64_t)CheckTreeNodeRotation(v2, v12, finished);
            }
            goto lab_0x2720;
        } else {
            if (v11 != 0) {
                int32_t * v15 = DeleteByElementRecursive(v10, Item, finished); // 0x27c9
                int64_t v16 = (int64_t)v2; // 0x27d7
                *(int64_t *)v2 = (int64_t)v15;
                v5 = v16;
                if (v8 == 0 && v15 != NULL) {
                    int16_t * v17 = (int16_t *)(v16 + 32); // 0x27ee
                    *v17 = *v17 + 1;
                    v5 = (int64_t)CheckTreeNodeRotation(v2, v15, finished);
                }
                goto lab_0x2720;
            } else {
                int64_t * v18 = (int64_t *)(v1 + 8); // 0x26e4
                int64_t v19 = *v18; // 0x26e4
                v6 = v9;
                if (v19 == 0) {
                    goto lab_0x278e;
                } else {
                    int64_t * v20 = (int64_t *)v19; // 0x26f1
                    if (*v20 == 0) {
                        // 0x2780
                        *(int16_t *)(v19 + 32) = *(int16_t *)(v1 + 32);
                        *v20 = v9;
                        v6 = v19;
                        goto lab_0x278e;
                    } else {
                        int32_t * v21 = DeleteLeftMost(&v2, (int32_t *)v19, &v4); // 0x2708
                        *v18 = (int64_t)v21;
                        v5 = (int64_t)v2;
                        goto lab_0x2720;
                    }
                }
            }
        }
    }
  lab_0x2720:
    // 0x2720
    if (v3 != __readfsqword(40)) {
        // 0x280d
        __stack_chk_fail();
        return &g16;
    }
    // 0x2734
    return (int32_t *)v5;
  lab_0x278e:
    // 0x278e
    libmin_free(*(int64_t *)(v1 + 24));
    FreeElement((int32_t *)*(int64_t *)((int64_t)v2 + 16));
    libmin_free((int64_t)v2);
    v5 = v6;
    goto lab_0x2720;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/avl-tree/avlcore.c
// Address range: 0x2820 - 0x2870
// Line range:    284 - 290
int32_t * DeleteByElement(int32_t * rootNode, int32_t * Item) {
    int64_t v1 = __readfsqword(40); // 0x2828
    int64_t v2 = 0; // bp-18, 0x283f
    int32_t * result = DeleteByElementRecursive(rootNode, Item, (int16_t *)&v2); // 0x2844
    if (v1 == __readfsqword(40)) {
        // 0x2859
        return result;
    }
    // 0x285e
    __stack_chk_fail();
    return &g16;
}

// Address range: 0x2870 - 0x30a3
int64_t Height(int64_t a1) {
    if (a1 == 0) {
        // 0x30a0
        return 0;
    }
    int64_t v1 = Height(a1); // 0x28d0
    int64_t * v2 = (int64_t *)(a1 + 8); // 0x28d5
    int64_t v3 = Height(*v2); // 0x28dc
    int64_t v4 = *v2; // 0x28f1
    int64_t v5 = 0; // 0x28fa
    int64_t v6 = 0; // 0x28fa
    if (v4 != 0) {
        int64_t v7 = Height(*(int64_t *)v4); // 0x2904
        int64_t v8 = Height(*(int64_t *)(v4 + 8)); // 0x2910
        int64_t v9 = v7 - v8; // 0x291a
        v5 = *v2;
        v6 = (v9 < 0 == ((v9 ^ v7) & (v8 ^ v7)) < 0 ? v7 : v8) + 1;
    }
    int64_t v10 = v6;
    int64_t v11 = 0; // 0x2939
    int64_t v12 = 0; // 0x2939
    if (v5 != 0) {
        int64_t v13 = *(int64_t *)v5; // 0x293b
        int64_t v14 = 0; // 0x2944
        if (v13 != 0) {
            int64_t v15 = Height(*(int64_t *)v13); // 0x294e
            int64_t v16 = Height(*(int64_t *)(v13 + 8)); // 0x295a
            int64_t v17 = v15 - v16; // 0x2964
            v14 = (v17 < 0 == ((v17 ^ v15) & (v16 ^ v15)) < 0 ? v15 : v16) + 1;
        }
        int64_t v18 = v14;
        int64_t v19 = *(int64_t *)(v5 + 8); // 0x296f
        int64_t v20 = 0; // 0x2978
        if (v19 != 0) {
            int64_t v21 = Height(*(int64_t *)v19); // 0x2982
            int64_t v22 = Height(*(int64_t *)(v19 + 8)); // 0x2993
            int64_t v23 = v21 - v22; // 0x2998
            v20 = (v23 < 0 == ((v23 ^ v21) & (v22 ^ v21)) < 0 ? v21 : v22) + 1;
        }
        int64_t v24 = v20;
        int64_t v25 = v24 - v18; // 0x29a3
        int64_t v26 = v25 < 0 == ((v25 ^ v24) & (v24 ^ v18)) < 0 ? v24 : v18; // 0x29a6
        v11 = *v2;
        v12 = v26 + 1;
    }
    int64_t v27 = v12;
    int64_t v28 = 0; // 0x29c2
    int64_t v29 = 0; // 0x29c2
    if (v11 != 0) {
        int64_t v30 = *(int64_t *)v11; // 0x29c8
        int64_t v31 = 0; // 0x29d1
        if (v30 != 0) {
            int64_t v32 = *(int64_t *)v30; // 0x29d3
            int64_t v33 = 0; // 0x29d9
            if (v32 != 0) {
                int64_t v34 = Height(*(int64_t *)v32); // 0x29e3
                int64_t v35 = Height(*(int64_t *)(v32 + 8)); // 0x29ef
                int64_t v36 = v34 - v35; // 0x29f9
                v33 = (v36 < 0 == ((v36 ^ v34) & (v35 ^ v34)) < 0 ? v34 : v35) + 1;
            }
            int64_t v37 = v33;
            int64_t v38 = *(int64_t *)(v30 + 8); // 0x2a04
            int64_t v39 = 0; // 0x2a0e
            if (v38 != 0) {
                int64_t v40 = Height(*(int64_t *)v38); // 0x2a18
                int64_t v41 = Height(*(int64_t *)(v38 + 8)); // 0x2a24
                int64_t v42 = v40 - v41; // 0x2a2e
                v39 = (v42 < 0 == ((v42 ^ v40) & (v41 ^ v40)) < 0 ? v40 : v41) + 1;
            }
            int64_t v43 = v39;
            int64_t v44 = v43 - v37; // 0x2a39
            int64_t v45 = v44 < 0 == ((v44 ^ v43) & (v43 ^ v37)) < 0 ? v43 : v37; // 0x2a3c
            v31 = v45 + 1;
        }
        int64_t v46 = v31;
        int64_t v47 = *(int64_t *)(v11 + 8); // 0x2a44
        int64_t v48 = 0; // 0x2a4d
        if (v47 != 0) {
            int64_t v49 = Height(*(int64_t *)v47); // 0x2a52
            int64_t v50 = Height(*(int64_t *)(v47 + 8)); // 0x2a5e
            int64_t v51 = v49 - v50; // 0x2a63
            v48 = (v51 < 0 == ((v51 ^ v49) & (v50 ^ v49)) < 0 ? v49 : v50) + 1;
        }
        int64_t v52 = v48;
        int64_t v53 = v52 - v46; // 0x2a6e
        int64_t v54 = v53 < 0 == ((v53 ^ v52) & (v52 ^ v46)) < 0 ? v52 : v46; // 0x2a71
        v28 = *v2;
        v29 = v54 + 1;
    }
    int64_t v55 = v29;
    int64_t v56 = 0; // 0x2a8d
    int64_t v57 = 0; // 0x2a8d
    if (v28 != 0) {
        int64_t v58 = *(int64_t *)v28; // 0x2a93
        int64_t v59 = 0; // 0x2a9c
        if (v58 != 0) {
            int64_t v60 = *(int64_t *)v58; // 0x2aa2
            int64_t v61 = 0; // 0x2aa8
            if (v60 != 0) {
                int64_t v62 = *(int64_t *)v60; // 0x2aaa
                int64_t v63 = 0; // 0x2ab0
                if (v62 != 0) {
                    int64_t v64 = Height(*(int64_t *)v62); // 0x2aba
                    int64_t v65 = Height(*(int64_t *)(v62 + 8)); // 0x2ac6
                    int64_t v66 = v64 - v65; // 0x2ad0
                    v63 = (v66 < 0 == ((v66 ^ v64) & (v65 ^ v64)) < 0 ? v64 : v65) + 1;
                }
                int64_t v67 = v63;
                int64_t v68 = *(int64_t *)(v60 + 8); // 0x2adb
                int64_t v69 = 0; // 0x2ae4
                if (v68 != 0) {
                    int64_t v70 = Height(*(int64_t *)v68); // 0x2aee
                    int64_t v71 = Height(*(int64_t *)(v68 + 8)); // 0x2afa
                    int64_t v72 = v70 - v71; // 0x2b04
                    v69 = (v72 < 0 == ((v72 ^ v70) & (v71 ^ v70)) < 0 ? v70 : v71) + 1;
                }
                int64_t v73 = v69;
                int64_t v74 = v73 - v67; // 0x2b0f
                int64_t v75 = v74 < 0 == ((v74 ^ v73) & (v73 ^ v67)) < 0 ? v73 : v67; // 0x2b12
                v61 = v75 + 1;
            }
            int64_t v76 = v61;
            int64_t v77 = *(int64_t *)(v58 + 8); // 0x2b1a
            int64_t v78 = 0; // 0x2b24
            if (v77 != 0) {
                int64_t v79 = Height(*(int64_t *)v77); // 0x2b29
                int64_t v80 = Height(*(int64_t *)(v77 + 8)); // 0x2b35
                int64_t v81 = v79 - v80; // 0x2b3a
                v78 = (v81 < 0 == ((v81 ^ v79) & (v80 ^ v79)) < 0 ? v79 : v80) + 1;
            }
            int64_t v82 = v78;
            int64_t v83 = v82 - v76; // 0x2b45
            int64_t v84 = v83 < 0 == ((v83 ^ v82) & (v82 ^ v76)) < 0 ? v82 : v76; // 0x2b48
            v59 = v84 + 1;
        }
        int64_t v85 = v59;
        int64_t v86 = *(int64_t *)(v28 + 8); // 0x2b50
        int64_t v87 = 0; // 0x2b59
        if (v86 != 0) {
            int64_t v88 = *(int64_t *)v86; // 0x2b5f
            int64_t v89 = 0; // 0x2b68
            if (v88 != 0) {
                int64_t v90 = *(int64_t *)v88; // 0x2b6a
                int64_t v91 = 0; // 0x2b70
                if (v90 != 0) {
                    int64_t v92 = Height(*(int64_t *)v90); // 0x2b7a
                    int64_t v93 = Height(*(int64_t *)(v90 + 8)); // 0x2b86
                    int64_t v94 = v92 - v93; // 0x2b90
                    v91 = (v94 < 0 == ((v94 ^ v92) & (v93 ^ v92)) < 0 ? v92 : v93) + 1;
                }
                int64_t v95 = v91;
                int64_t v96 = *(int64_t *)(v88 + 8); // 0x2b9b
                int64_t v97 = 0; // 0x2ba5
                if (v96 != 0) {
                    int64_t v98 = Height(*(int64_t *)v96); // 0x2baf
                    int64_t v99 = Height(*(int64_t *)(v96 + 8)); // 0x2bbb
                    int64_t v100 = v98 - v99; // 0x2bc5
                    v97 = (v100 < 0 == ((v100 ^ v98) & (v99 ^ v98)) < 0 ? v98 : v99) + 1;
                }
                int64_t v101 = v97;
                int64_t v102 = v101 - v95; // 0x2bd0
                int64_t v103 = v102 < 0 == ((v102 ^ v101) & (v101 ^ v95)) < 0 ? v101 : v95; // 0x2bd3
                v89 = v103 + 1;
            }
            int64_t v104 = v89;
            int64_t v105 = *(int64_t *)(v86 + 8); // 0x2bdb
            int64_t v106 = 0; // 0x2be4
            if (v105 != 0) {
                int64_t v107 = Height(*(int64_t *)v105); // 0x2be9
                int64_t v108 = Height(*(int64_t *)(v105 + 8)); // 0x2bf5
                int64_t v109 = v107 - v108; // 0x2bfa
                v106 = (v109 < 0 == ((v109 ^ v107) & (v108 ^ v107)) < 0 ? v107 : v108) + 1;
            }
            int64_t v110 = v106;
            int64_t v111 = v110 - v104; // 0x2c05
            int64_t v112 = v111 < 0 == ((v111 ^ v110) & (v110 ^ v104)) < 0 ? v110 : v104; // 0x2c08
            v87 = v112 + 1;
        }
        int64_t v113 = v87;
        int64_t v114 = v113 - v85; // 0x2c10
        int64_t v115 = v114 < 0 == ((v114 ^ v113) & (v113 ^ v85)) < 0 ? v113 : v85; // 0x2c13
        v56 = *v2;
        v57 = v115 + 1;
    }
    int64_t v116 = v57;
    int64_t v117 = 0; // 0x2c30
    if (v56 != 0) {
        int64_t v118 = *(int64_t *)v56; // 0x2c36
        int64_t v119 = 0; // 0x2c3f
        if (v118 != 0) {
            int64_t v120 = *(int64_t *)v118; // 0x2c45
            int64_t v121 = 0; // 0x2c4e
            if (v120 != 0) {
                int64_t v122 = *(int64_t *)v120; // 0x2c54
                int64_t v123 = 0; // 0x2c5a
                if (v122 != 0) {
                    int64_t v124 = *(int64_t *)v122; // 0x2c5c
                    int64_t v125 = 0; // 0x2c62
                    if (v124 != 0) {
                        int64_t v126 = Height(*(int64_t *)v124); // 0x2c6d
                        int64_t v127 = Height(*(int64_t *)(v124 + 8)); // 0x2c79
                        int64_t v128 = v126 - v127; // 0x2c83
                        v125 = (v128 < 0 == ((v128 ^ v126) & (v127 ^ v126)) < 0 ? v126 : v127) + 1;
                    }
                    int64_t v129 = v125;
                    int64_t v130 = *(int64_t *)(v122 + 8); // 0x2c8e
                    int64_t v131 = 0; // 0x2c97
                    if (v130 != 0) {
                        int64_t v132 = Height(*(int64_t *)v130); // 0x2ca1
                        int64_t v133 = Height(*(int64_t *)(v130 + 8)); // 0x2cad
                        int64_t v134 = v132 - v133; // 0x2cb7
                        v131 = (v134 < 0 == ((v134 ^ v132) & (v133 ^ v132)) < 0 ? v132 : v133) + 1;
                    }
                    int64_t v135 = v131;
                    int64_t v136 = v135 - v129; // 0x2cc2
                    int64_t v137 = v136 < 0 == ((v136 ^ v135) & (v135 ^ v129)) < 0 ? v135 : v129; // 0x2cc5
                    v123 = v137 + 1;
                }
                int64_t v138 = v123;
                int64_t v139 = *(int64_t *)(v120 + 8); // 0x2ccd
                int64_t v140 = 0; // 0x2cd7
                if (v139 != 0) {
                    int64_t v141 = *(int64_t *)v139; // 0x2cd9
                    int64_t v142 = 0; // 0x2ce2
                    if (v141 != 0) {
                        int64_t v143 = Height(*(int64_t *)v141); // 0x2ced
                        int64_t v144 = Height(*(int64_t *)(v141 + 8)); // 0x2cf9
                        int64_t v145 = v143 - v144; // 0x2d03
                        v142 = (v145 < 0 == ((v145 ^ v143) & (v144 ^ v143)) < 0 ? v143 : v144) + 1;
                    }
                    int64_t v146 = v142;
                    int64_t v147 = *(int64_t *)(v139 + 8); // 0x2d0e
                    int64_t v148 = 0; // 0x2d18
                    if (v147 != 0) {
                        int64_t v149 = Height(*(int64_t *)v147); // 0x2d22
                        int64_t v150 = Height(*(int64_t *)(v147 + 8)); // 0x2d33
                        int64_t v151 = v149 - v150; // 0x2d38
                        v148 = (v151 < 0 == ((v151 ^ v149) & (v150 ^ v149)) < 0 ? v149 : v150) + 1;
                    }
                    int64_t v152 = v148;
                    int64_t v153 = v152 - v146; // 0x2d43
                    int64_t v154 = v153 < 0 == ((v153 ^ v152) & (v152 ^ v146)) < 0 ? v152 : v146; // 0x2d46
                    v140 = v154 + 1;
                }
                int64_t v155 = v140;
                int64_t v156 = v155 - v138; // 0x2d4e
                int64_t v157 = v156 < 0 == ((v156 ^ v155) & (v155 ^ v138)) < 0 ? v155 : v138; // 0x2d51
                v121 = v157 + 1;
            }
            int64_t v158 = v121;
            int64_t v159 = *(int64_t *)(v118 + 8); // 0x2d59
            int64_t v160 = 0; // 0x2d62
            if (v159 != 0) {
                int64_t v161 = *(int64_t *)v159; // 0x2d68
                int64_t v162 = 0; // 0x2d71
                if (v161 != 0) {
                    int64_t v163 = *(int64_t *)v161; // 0x2d73
                    int64_t v164 = 0; // 0x2d79
                    if (v163 != 0) {
                        int64_t v165 = Height(*(int64_t *)v163); // 0x2d83
                        int64_t v166 = Height(*(int64_t *)(v163 + 8)); // 0x2d8f
                        int64_t v167 = v165 - v166; // 0x2d99
                        v164 = (v167 < 0 == ((v167 ^ v165) & (v166 ^ v165)) < 0 ? v165 : v166) + 1;
                    }
                    int64_t v168 = v164;
                    int64_t v169 = *(int64_t *)(v161 + 8); // 0x2da4
                    int64_t v170 = 0; // 0x2dae
                    if (v169 != 0) {
                        int64_t v171 = Height(*(int64_t *)v169); // 0x2db8
                        int64_t v172 = Height(*(int64_t *)(v169 + 8)); // 0x2dc4
                        int64_t v173 = v171 - v172; // 0x2dce
                        v170 = (v173 < 0 == ((v173 ^ v171) & (v172 ^ v171)) < 0 ? v171 : v172) + 1;
                    }
                    int64_t v174 = v170;
                    int64_t v175 = v174 - v168; // 0x2dd9
                    int64_t v176 = v175 < 0 == ((v175 ^ v174) & (v174 ^ v168)) < 0 ? v174 : v168; // 0x2ddc
                    v162 = v176 + 1;
                }
                int64_t v177 = v162;
                int64_t v178 = *(int64_t *)(v159 + 8); // 0x2de4
                int64_t v179 = 0; // 0x2ded
                if (v178 != 0) {
                    int64_t v180 = *(int64_t *)v178; // 0x2def
                    int64_t v181 = 0; // 0x2df8
                    if (v180 != 0) {
                        int64_t v182 = Height(*(int64_t *)v180); // 0x2e03
                        int64_t v183 = Height(*(int64_t *)(v180 + 8)); // 0x2e0f
                        int64_t v184 = v182 - v183; // 0x2e19
                        v181 = (v184 < 0 == ((v184 ^ v182) & (v183 ^ v182)) < 0 ? v182 : v183) + 1;
                    }
                    int64_t v185 = v181;
                    int64_t v186 = *(int64_t *)(v178 + 8); // 0x2e24
                    int64_t v187 = 0; // 0x2e2d
                    if (v186 != 0) {
                        int64_t v188 = Height(*(int64_t *)v186); // 0x2e37
                        int64_t v189 = Height(*(int64_t *)(v186 + 8)); // 0x2e48
                        int64_t v190 = v188 - v189; // 0x2e4d
                        v187 = (v190 < 0 == ((v190 ^ v188) & (v189 ^ v188)) < 0 ? v188 : v189) + 1;
                    }
                    int64_t v191 = v187;
                    int64_t v192 = v191 - v185; // 0x2e58
                    int64_t v193 = v192 < 0 == ((v192 ^ v191) & (v191 ^ v185)) < 0 ? v191 : v185; // 0x2e5b
                    v179 = v193 + 1;
                }
                int64_t v194 = v179;
                int64_t v195 = v194 - v177; // 0x2e63
                int64_t v196 = v195 < 0 == ((v195 ^ v194) & (v194 ^ v177)) < 0 ? v194 : v177; // 0x2e66
                v160 = v196 + 1;
            }
            int64_t v197 = v160;
            int64_t v198 = v197 - v158; // 0x2e6e
            int64_t v199 = v198 < 0 == ((v198 ^ v197) & (v197 ^ v158)) < 0 ? v197 : v158; // 0x2e71
            v119 = v199 + 1;
        }
        int64_t v200 = v119;
        int64_t v201 = *(int64_t *)(v56 + 8); // 0x2e79
        int64_t v202 = 0; // 0x2e83
        if (v201 != 0) {
            int64_t v203 = *(int64_t *)v201; // 0x2e89
            int64_t v204 = 0; // 0x2e92
            if (v203 != 0) {
                int64_t v205 = *(int64_t *)v203; // 0x2e98
                int64_t v206 = 0; // 0x2ea1
                if (v205 != 0) {
                    int64_t v207 = *(int64_t *)v205; // 0x2ea3
                    int64_t v208 = 0; // 0x2ea9
                    if (v207 != 0) {
                        int64_t v209 = Height(*(int64_t *)v207); // 0x2eb4
                        int64_t v210 = Height(*(int64_t *)(v207 + 8)); // 0x2ec1
                        int64_t v211 = v209 - v210; // 0x2ecb
                        v208 = (v211 < 0 == ((v211 ^ v209) & (v210 ^ v209)) < 0 ? v209 : v210) + 1;
                    }
                    int64_t v212 = v208;
                    int64_t v213 = *(int64_t *)(v205 + 8); // 0x2ed6
                    int64_t v214 = 0; // 0x2ee0
                    if (v213 != 0) {
                        int64_t v215 = Height(*(int64_t *)v213); // 0x2eea
                        int64_t v216 = Height(*(int64_t *)(v213 + 8)); // 0x2ef6
                        int64_t v217 = v215 - v216; // 0x2f00
                        v214 = (v217 < 0 == ((v217 ^ v215) & (v216 ^ v215)) < 0 ? v215 : v216) + 1;
                    }
                    int64_t v218 = v214;
                    int64_t v219 = v218 - v212; // 0x2f0b
                    int64_t v220 = v219 < 0 == ((v219 ^ v218) & (v218 ^ v212)) < 0 ? v218 : v212; // 0x2f0e
                    v206 = v220 + 1;
                }
                int64_t v221 = v206;
                int64_t v222 = *(int64_t *)(v203 + 8); // 0x2f16
                int64_t v223 = 0; // 0x2f20
                if (v222 != 0) {
                    int64_t v224 = *(int64_t *)v222; // 0x2f22
                    int64_t v225 = 0; // 0x2f2b
                    if (v224 != 0) {
                        int64_t v226 = Height(*(int64_t *)v224); // 0x2f36
                        int64_t v227 = Height(*(int64_t *)(v224 + 8)); // 0x2f42
                        int64_t v228 = v226 - v227; // 0x2f4c
                        v225 = (v228 < 0 == ((v228 ^ v226) & (v227 ^ v226)) < 0 ? v226 : v227) + 1;
                    }
                    int64_t v229 = v225;
                    int64_t v230 = *(int64_t *)(v222 + 8); // 0x2f57
                    int64_t v231 = 0; // 0x2f61
                    if (v230 != 0) {
                        int64_t v232 = Height(*(int64_t *)v230); // 0x2f6b
                        int64_t v233 = Height(*(int64_t *)(v230 + 8)); // 0x2f7c
                        int64_t v234 = v232 - v233; // 0x2f81
                        v231 = (v234 < 0 == ((v234 ^ v232) & (v233 ^ v232)) < 0 ? v232 : v233) + 1;
                    }
                    int64_t v235 = v231;
                    int64_t v236 = v235 - v229; // 0x2f8c
                    int64_t v237 = v236 < 0 == ((v236 ^ v235) & (v235 ^ v229)) < 0 ? v235 : v229; // 0x2f8f
                    v223 = v237 + 1;
                }
                int64_t v238 = v223;
                int64_t v239 = v238 - v221; // 0x2f97
                int64_t v240 = v239 < 0 == ((v239 ^ v238) & (v238 ^ v221)) < 0 ? v238 : v221; // 0x2f9a
                v204 = v240 + 1;
            }
            int64_t v241 = v204;
            int64_t v242 = *(int64_t *)(v201 + 8); // 0x2fa2
            int64_t v243 = 0; // 0x2fab
            if (v242 != 0) {
                int64_t v244 = *(int64_t *)v242; // 0x2fb1
                int64_t v245 = 0; // 0x2fbb
                if (v244 != 0) {
                    int64_t v246 = Height(*(int64_t *)v244); // 0x2fc0
                    int64_t v247 = Height(*(int64_t *)(v244 + 8)); // 0x2fcc
                    int64_t v248 = v246 - v247; // 0x2fd1
                    v245 = (v248 < 0 == ((v248 ^ v246) & (v247 ^ v246)) < 0 ? v246 : v247) + 1;
                }
                int64_t v249 = v245;
                int64_t v250 = *(int64_t *)(v242 + 8); // 0x2fdc
                int64_t v251 = 0; // 0x2fe6
                if (v250 != 0) {
                    int64_t v252 = *(int64_t *)v250; // 0x2fe8
                    int64_t v253 = 0; // 0x2ff2
                    if (v252 != 0) {
                        int64_t v254 = Height(*(int64_t *)v252); // 0x2ffc
                        int64_t v255 = Height(*(int64_t *)(v252 + 8)); // 0x300d
                        int64_t v256 = v254 - v255; // 0x3012
                        v253 = (v256 < 0 == ((v256 ^ v254) & (v255 ^ v254)) < 0 ? v254 : v255) + 1;
                    }
                    int64_t v257 = v253;
                    int64_t v258 = *(int64_t *)(v250 + 8); // 0x301d
                    int64_t v259 = 0; // 0x3027
                    if (v258 != 0) {
                        int64_t v260 = Height(*(int64_t *)v258); // 0x3031
                        int64_t v261 = Height(*(int64_t *)(v258 + 8)); // 0x3042
                        int64_t v262 = v260 - v261; // 0x3047
                        v259 = (v262 < 0 == ((v262 ^ v260) & (v261 ^ v260)) < 0 ? v260 : v261) + 1;
                    }
                    int64_t v263 = v259;
                    int64_t v264 = v263 - v257; // 0x3052
                    int64_t v265 = v264 < 0 == ((v264 ^ v263) & (v263 ^ v257)) < 0 ? v263 : v257; // 0x3055
                    v251 = v265 + 1;
                }
                int64_t v266 = v251;
                int64_t v267 = v266 - v249; // 0x305d
                int64_t v268 = v267 < 0 == ((v267 ^ v266) & (v266 ^ v249)) < 0 ? v266 : v249; // 0x3060
                v243 = v268 + 1;
            }
            int64_t v269 = v243;
            int64_t v270 = v269 - v241; // 0x3068
            int64_t v271 = v270 < 0 == ((v270 ^ v269) & (v269 ^ v241)) < 0 ? v269 : v241; // 0x306b
            v202 = v271 + 1;
        }
        int64_t v272 = v202;
        int64_t v273 = v272 - v200; // 0x3073
        int64_t v274 = v273 < 0 == ((v273 ^ v272) & (v272 ^ v200)) < 0 ? v272 : v200; // 0x3076
        v117 = v274 + 1;
    }
    int64_t v275 = v1 - v3; // 0x28e6
    int64_t v276 = (v275 < 0 == ((v275 ^ v1) & (v3 ^ v1)) < 0 ? v1 : v3) + 1; // 0x28ed
    int64_t v277 = v10 - v276; // 0x2925
    int64_t v278 = (v277 < 0 == ((v277 ^ v10) & (v10 ^ v276)) < 0 ? v10 : v276) + 1; // 0x292c
    int64_t v279 = v27 - v278; // 0x29ae
    int64_t v280 = (v279 < 0 == ((v279 ^ v27) & (v27 ^ v278)) < 0 ? v27 : v278) + 1; // 0x29b5
    int64_t v281 = v55 - v280; // 0x2a79
    int64_t v282 = (v281 < 0 == ((v281 ^ v55) & (v55 ^ v280)) < 0 ? v55 : v280) + 1; // 0x2a80
    int64_t v283 = v116 - v282; // 0x2c1b
    int64_t v284 = (v283 < 0 == ((v283 ^ v116) & (v116 ^ v282)) < 0 ? v116 : v282) + 1; // 0x2c22
    int64_t v285 = v117;
    int64_t v286 = v285 - v284; // 0x307e
    return (v286 < 0 == ((v286 ^ v285) & (v285 ^ v284)) < 0 ? v285 : v284) + 1;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x30b0 - 0x30c1
// Line range:    124 - 127
void libtarg_success(void) {
    // 0x30b0
    exit(0);
    // UNREACHABLE
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x30d0 - 0x30df
// Line range:    162 - 165
void libtarg_fail(int32_t code) {
    // 0x30d0
    exit(code);
    // UNREACHABLE
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x30e0 - 0x30f4
// Line range:    188 - 191
void libtarg_putc(char c) {
    // 0x30e0
    fputc((int32_t)c, g10);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libtarg.c
// Address range: 0x3100 - 0x3109
// Line range:    230 - 236
char * libtarg_sbrk(int64_t inc) {
    // 0x3100
    return (char *)sbrk(inc);
}

// Address range: 0x3110 - 0x3198
int64_t libmin_free_part_0(int64_t a1) {
    char * v1 = libtarg_sbrk(0); // 0x3116
    int64_t v2 = *(int64_t *)(a1 - 24); // 0x311b
    int64_t result = v2 + a1; // 0x3122
    if (result != (int64_t)v1) {
        // 0x312b
        *(int32_t *)(a1 - 16) = 1;
        return result;
    }
    // 0x3138
    if (head == tail) {
        // 0x3180
        *(int64_t *)&tail = 0;
        *(int64_t *)&head = 0;
        // 0x3170
        return (int64_t)libtarg_sbrk(-24 - v2);
    }
    int64_t v3 = (int64_t)head;
    while (v3 != 0) {
        int64_t * v4 = (int64_t *)(v3 + 16);
        int64_t v5 = *v4; // 0x3158
        if (v5 == (int64_t)tail) {
            // 0x3161
            *v4 = 0;
            *(int64_t *)&tail = v3;
            return (int64_t)libtarg_sbrk(-24 - v2);
        }
        v3 = v5;
    }
  lab_0x3170:
    // 0x3170
    return (int64_t)libtarg_sbrk(-24 - v2);
}

// Address range: 0x31a0 - 0x3244
int64_t libmin_malloc(uint64_t a1) {
    if (a1 == 0) {
        // 0x321d
        return 0;
    }
    // 0x31ad
    if (head != NULL) {
        int64_t v1 = (int64_t)head;
        int32_t * v2 = (int32_t *)(v1 + 8);
        if (*v2 != 0) {
            // 0x31c7
            if (*(int64_t *)v1 >= a1) {
                // 0x3228
                *v2 = 0;
                return v1 + 24;
            }
        }
        int64_t v3 = *(int64_t *)(v1 + 16); // 0x31cc
        while (v3 != 0) {
            // 0x31c0
            v1 = v3;
            v2 = (int32_t *)(v1 + 8);
            if (*v2 != 0) {
                // 0x31c7
                if (*(int64_t *)v1 >= a1) {
                    // 0x3228
                    *v2 = 0;
                    return v1 + 24;
                }
            }
            // 0x31cc
            v3 = *(int64_t *)(v1 + 16);
        }
    }
    char * v4 = libtarg_sbrk(a1 + 24); // 0x31d9
    if (v4 == (char *)-1) {
        // 0x321d
        return 0;
    }
    int64_t v5 = (int64_t)v4; // 0x31d9
    *(int64_t *)v4 = a1;
    *(int32_t *)(v5 + 8) = 0;
    *(int64_t *)(v5 + 16) = 0;
    if (head == NULL) {
        // 0x323b
        *(int64_t *)&head = v5;
    }
    // 0x3200
    if (tail != NULL) {
        // 0x320c
        *(int64_t *)&mt = v5;
    }
    // 0x3210
    *(int64_t *)&tail = v5;
    return v5 + 24;
}

// Address range: 0x3250 - 0x3261
int64_t libmin_free(int64_t a1) {
    // 0x3250
    if (a1 == 0) {
        // 0x3260
        int64_t result; // 0x3250
        return result;
    }
    // 0x3259
    return libmin_free_part_0(a1);
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_malloc.c
// Address range: 0x3270 - 0x32cf
// Line range:    102 - 117
char * libmin_calloc(uint64_t num, uint64_t nsize) {
    // 0x3270
    if (num == 0 || nsize == 0) {
        // 0x32ae
        return NULL;
    }
    uint128_t v1 = (int128_t)nsize * (int128_t)num; // 0x3289
    if (v1 > 0xffffffffffffffff) {
        // 0x32ae
        return NULL;
    }
    int64_t v2 = v1; // 0x3289
    int64_t v3 = libmin_malloc(v2); // 0x3294
    char * result = (char *)v3;
    if (v3 != 0) {
        // 0x32a1
        libmin_memset(result, 0, v2);
    }
    // 0x32ae
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_malloc.c
// Address range: 0x32d0 - 0x333c
// Line range:    120 - 123
char * libmin_realloc(char * block, uint64_t size) {
    if (block == NULL || size == 0) {
        // 0x3330
        return (char *)libmin_malloc(size);
    }
    int64_t v1 = (int64_t)block;
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x32ee
    if (*v2 >= size) {
        // 0x32f4
        return (char *)v1;
    }
    int64_t v3 = libmin_malloc(size); // 0x3300
    if (v3 == 0) {
        // 0x32f4
        return (char *)0;
    }
    char * result = (char *)v3; // 0x3317
    libmin_memcpy(result, (int32_t *)block, *v2);
    libmin_free_part_0(v1);
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_memcpy.c
// Address range: 0x3340 - 0x3363
// Line range:    5 - 11
char * libmin_memcpy(char * dest, int32_t * src, int64_t n) {
    // 0x3340
    if (n == 0) {
        // 0x3362
        return dest;
    }
    int64_t v1 = 0; // 0x334a
    char v2 = *(char *)(v1 + (int64_t)src); // 0x3350
    *(char *)(v1 + (int64_t)dest) = v2;
    v1++;
    while (v1 != n) {
        // 0x3350
        v2 = *(char *)(v1 + (int64_t)src);
        *(char *)(v1 + (int64_t)dest) = v2;
        v1++;
    }
    // 0x3362
    return dest;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_memset.c
// Address range: 0x3370 - 0x33d2
// Line range:    5 - 37
char * libmin_memset(char * dest, uint32_t c, uint64_t n) {
    if (n == 0) {
        // 0x33cc
        return dest;
    }
    int64_t v1 = (int64_t)dest;
    char v2 = c; // 0x337e
    int64_t v3 = v1 + n;
    *(char *)(v3 - 1) = v2;
    *dest = v2;
    if (n < 3) {
        // 0x33cc
        return dest;
    }
    // 0x338c
    *(char *)(v3 - 2) = v2;
    *(char *)(v1 + 1) = v2;
    *(char *)(v3 - 3) = v2;
    *(char *)(v1 + 2) = v2;
    if (n < 7) {
        // 0x33cc
        return dest;
    }
    // 0x33a4
    *(char *)(v3 - 4) = v2;
    *(char *)(v1 + 3) = v2;
    if (n >= 9) {
        uint64_t v4 = -v1 % 4; // 0x33ba
        memset((int64_t *)(v4 + v1), c % 256, (int32_t)(n - v4) & -4);
    }
    // 0x33cc
    return dest;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x33e0 - 0x3628
// Line range:    426 - 483
void fmtint(char * buffer, int64_t * currlen, uint64_t maxlen, int64_t value, int32_t base, int32_t min, int32_t max, uint32_t flags) {
    int64_t v1 = flags; // 0x33ef
    int64_t v2 = value; // 0x340f
    int64_t v3 = 0; // 0x340f
    int32_t v4 = 0; // 0x340f
    if ((flags & 64) == 0) {
        if (value < 0) {
            // 0x35f0
            v2 = -value;
            v3 = 45;
            v4 = -1;
        } else {
            // 0x341a
            v2 = value;
            v3 = 43;
            v4 = -1;
            if ((v1 & 2) == 0) {
                uint32_t v5 = 8 * flags & 32; // 0x3613
                v2 = value;
                v3 = v5;
                v4 = v5 != 0;
            }
        }
    }
    int64_t v6 = (int64_t)currlen;
    int64_t v7 = (int64_t)buffer;
    uint32_t v8 = max > 0 ? max : 0; // 0x3407
    uint64_t v9 = (int64_t)base; // 0x3442
    int64_t v10; // bp-89, 0x33e0
    int64_t v11 = &v10; // 0x3445
    int64_t v12 = (v1 & 32) == 0 ? (int64_t)"0123456789abcdef" : (int64_t)"0123456789ABCDEF"; // 0x345d
    uint64_t v13 = v2; // 0x3461
    int64_t v14 = 1;
    *(char *)(v14 + v11) = *(char *)(v13 % v9 + v12);
    int32_t v15 = v14;
    int32_t v16 = v15 - 19; // 0x3488
    int64_t v17 = v14 + 1; // 0x3494
    while (v13 >= v9 == (v16 == 0 || v16 < 0 != (18 - v15 & v15) < 0)) {
        // 0x3468
        v13 /= v9;
        v14 = v17;
        *(char *)(v14 + v11) = *(char *)(v13 % v9 + v12);
        v15 = v14;
        v16 = v15 - 19;
        v17 = v14 + 1;
    }
    int64_t v18 = v15 == 20 ? 19 : v14 & 0xffffffff; // 0x34a6
    int32_t v19 = v18; // 0x34aa
    int32_t v20 = v8 - v19; // 0x34aa
    int64_t v21 = 0x100000000 * v18 >> 32; // 0x34b0
    int64_t v22; // bp-48, 0x33e0
    int64_t v23 = (int64_t)&v22 - 40 + v21; // 0x34b7
    *(char *)v23 = 0;
    uint32_t v24 = min - (int32_t)(v20 < 0 == (v20 & v19) < 0 ? (int64_t)v8 : v18) + v4; // 0x34c3
    uint32_t v25 = v20 > 0 ? v20 : 0; // 0x34c9
    int64_t v26 = v25; // 0x34c9
    int64_t v27 = v24 >= 0 ? (int64_t)v24 : 0; // 0x34d5
    int64_t v28; // 0x33e0
    int64_t v29; // 0x33e0
    int64_t v30; // 0x33e0
    if ((v1 & 16) == 0) {
        if (flags % 2 != 0) {
            // 0x35d0
            v29 = v6;
            v30 = -v27 & 0xffffffff;
            v28 = v26;
        } else {
            // 0x3594
            v29 = v6;
            v30 = v27;
            v28 = v26;
            if (v24 >= 1) {
                if (v6 < maxlen) {
                    // 0x35a5
                    *(char *)(v6 + v7) = 32;
                }
                int64_t v31 = v6 + 1; // 0x35ac
                *currlen = v31;
                uint32_t v32 = (int32_t)v27 - 1; // 0x35b3
                int64_t v33 = v32; // 0x35b6
                while (v32 != 0) {
                    int64_t v34 = v31;
                    int64_t v35 = v34; // 0x35a3
                    if (v34 < maxlen) {
                        // 0x35a5
                        *(char *)(v34 + v7) = 32;
                        v35 = v6;
                    }
                    // 0x35ac
                    v31 = v35 + 1;
                    *currlen = v31;
                    v32 = (int32_t)v33 - 1;
                    v33 = v32;
                }
                int32_t v36 = v27; // 0x35b8
                v29 = v31;
                v30 = v27 - (v36 >= 0 == (v36 != 0) ? v27 : 1) & 0xffffffff;
                v28 = v26;
            }
        }
    } else {
        int32_t v37 = v27; // 0x34e6
        int32_t v38 = v25 - v37; // 0x34e6
        v29 = v6;
        v30 = 0;
        v28 = v38 < 0 == (v38 & v37) < 0 ? v26 : v27;
    }
    int64_t v39 = v29; // 0x34f2
    if (v3 != 0) {
        int64_t v40 = v29; // 0x34f7
        if (v29 < maxlen) {
            // 0x35e0
            *(char *)(v29 + v7) = (char)v3;
            v40 = v6;
        }
        // 0x34fd
        v39 = v40 + 1;
        *currlen = v39;
    }
    int64_t v41 = v39; // 0x3507
    uint32_t v42 = v28; // 0x3507
    if ((int32_t)v28 != 0) {
        int64_t v43 = v39; // 0x3573
        if (v39 < maxlen) {
            // 0x3575
            *(char *)(v39 + v7) = 48;
            v43 = v6;
        }
        int64_t v44 = v43 + 1; // 0x357c
        *currlen = v44;
        v41 = v44;
        while (v42 != 0) {
            // 0x3570
            v42 = (int64_t)v42;
            int64_t v45 = v44;
            v43 = v45;
            if (v45 < maxlen) {
                // 0x3575
                *(char *)(v45 + v7) = 48;
                v43 = v6;
            }
            // 0x357c
            v44 = v43 + 1;
            *currlen = v44;
            v41 = v44;
        }
    }
    int64_t v46 = v23; // 0x3518
    v46--;
    int64_t v47 = v41; // 0x3523
    if (v41 < maxlen) {
        // 0x3525
        *(char *)(v41 + v7) = *(char *)v46;
        v47 = v6;
    }
    int64_t v48 = v47 + 1; // 0x3530
    *currlen = v48;
    while (v21 + v11 - (v18 + 0xffffffff & 0xffffffff) != v46) {
        int64_t v49 = v48;
        v46--;
        v47 = v49;
        if (v49 < maxlen) {
            // 0x3525
            *(char *)(v49 + v7) = *(char *)v46;
            v47 = v6;
        }
        // 0x3530
        v48 = v47 + 1;
        *currlen = v48;
    }
    // 0x3540
    if (v30 == 0) {
        // 0x3560
        return;
    }
    uint32_t v50 = v30; // 0x3542
    int64_t v51 = v48; // 0x354b
    if (v48 < maxlen) {
        // 0x354d
        *(char *)(v48 + v7) = 32;
        v51 = v6;
    }
    int64_t v52 = v51 + 1; // 0x3554
    *currlen = v52;
    while (v50 != 0) {
        // 0x3548
        v50 = (int64_t)v50;
        int64_t v53 = v52;
        v51 = v53;
        if (v53 < maxlen) {
            // 0x354d
            *(char *)(v53 + v7) = 32;
            v51 = v6;
        }
        // 0x3554
        v52 = v51 + 1;
        *currlen = v52;
    }
}

// Address range: 0x3630 - 0x36e3
int64_t my_modf_isra_0(int64_t a1) {
    // 0x3630
    int128_t v1; // 0x3630
    int128_t v2 = __asm_movapd(v1); // 0x3631
    int128_t v3 = __asm_movsd(0x3ff0000000000000); // 0x363e
    int128_t v4 = __asm_movsd(0x3fb999999999999a); // 0x3646
    int128_t v5 = __asm_movsd(0x4024000000000000); // 0x364e
    int128_t v6 = __asm_movapd(v3); // 0x3656
    int64_t v7; // bp-8, 0x3630
    bool v8 = &v7 < (int64_t *)32; // 0x365a
    int64_t result2 = 0;
    int128_t v9 = v6;
    int128_t v10; // 0x3630
    int128_t v11 = v10;
    int128_t v12 = v2;
    int64_t v13 = __asm_cvttsd2si_4(v12); // 0x3670
    __asm_pxor(v11, v11);
    int128_t v14 = __asm_addsd(__asm_movapd(v12), v3); // 0x367d
    int128_t v15 = __asm_cvtsi2sd(v13); // 0x3681
    __asm_comisd(v14, v15);
    while (v8) {
        int64_t v16 = result2 + 1; // 0x3664
        int64_t result = v16 & 0xffffffff; // 0x3664
        uint32_t v17 = (int32_t)v16; // 0x366b
        v8 = v17 < 100;
        int128_t v18 = __asm_mulsd_2(v12, v4); // 0x366e
        int128_t v19 = __asm_mulsd_2(v9, v5); // 0x366e
        if (v17 == 100) {
            // 0x36a8
            *(int64_t *)a1 = 0;
            return result;
        }
        result2 = result;
        v9 = v19;
        v11 = v15;
        v12 = v18;
        v13 = __asm_cvttsd2si_4(v12);
        __asm_pxor(v11, v11);
        v14 = __asm_addsd(__asm_movapd(v12), v3);
        v15 = __asm_cvtsi2sd(v13);
        __asm_comisd(v14, v15);
    }
    // 0x368c
    __asm_comisd(v15, __asm_subsd(__asm_movapd(v12), v3));
    if (result2 == 0) {
        // 0x369e
        *(int64_t *)a1 = __asm_movsd_1(v15);
        return result2;
    }
    int128_t v20 = __asm_mulsd_2(v15, v9); // 0x36b5
    __asm_subsd(v1, v20);
    int64_t v21 = __asm_movsd_1(v20); // 0x36c2
    int64_t v22; // bp-16, 0x3630
    int64_t result3 = my_modf_isra_0((int64_t)&v22); // 0x36c8
    *(int64_t *)a1 = __asm_movsd_1(__asm_addsd_3(__asm_movsd(v21), v22));
    return result3;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x36f0 - 0x3c70
// Line range:    586 - 525
void fmtfp(char * buffer, int64_t * currlen, uint64_t maxlen, float128_t fvalue, int32_t min, uint32_t max, int32_t flags) {
    char iconvert[311]; // bp-704, 0x36f0
    char v1[311]; // 0x36f0
    char v2[311]; // 0x3c58
    char v3[311]; // 0x3b92
    char v4[311]; // 0x37f3
    char v5[311]; // 0x3b6c
    // 0x36f0
    int128_t v6; // 0x36f0
    int128_t v7 = v6;
    int128_t v8 = v6;
    int128_t v9 = v6;
    int3_t v10; // 0x36f0
    int3_t v11 = v10 - 1;
    float80_t v12; // 0x36f0
    __frontend_reg_store_fpr(v11, v12);
    int32_t v13 = 6; // 0x3715
    int64_t v14 = 6; // 0x3715
    if (max >= 0) {
        int32_t v15 = max - 16; // 0x3721
        v14 = v15 == 0 | v15 < 0 != (15 - max & max) < 0 ? (int64_t)max : 16;
        v13 = max;
    }
    uint64_t v16 = (int64_t)flags;
    int3_t v17 = v10 - 2; // 0x3728
    __frontend_reg_store_fpr(v17, 0.0L);
    float80_t v18 = __frontend_reg_load_fpr(v17); // 0x372a
    float80_t v19 = __frontend_reg_load_fpr(v11); // 0x372a
    float80_t v20 = __frontend_reg_load_fpr(v11);
    int32_t v21; // 0x36f0
    int32_t v22; // 0x36f0
    float64_t v23; // bp-744, 0x36f0
    int128_t v24; // 0x36f0
    if (v18 > v19) {
        // 0x3ba0
        __frontend_reg_store_fpr(v11, -v20);
        float64_t v25 = __frontend_reg_load_fpr(v11); // 0x3baa
        v23 = v25;
        v22 = 45;
        v21 = 1;
        v24 = __asm_movsd((int64_t)v25);
    } else {
        float64_t v26 = v20; // 0x3732
        v23 = v26;
        int128_t v27 = __asm_movsd((int64_t)v26); // 0x3735
        v22 = 43;
        v21 = 1;
        v24 = v27;
        if ((v16 & 2) == 0) {
            int32_t v28 = 8 * flags & 32; // 0x374d
            v22 = v28;
            v21 = v28 != 0;
            v24 = v27;
        }
    }
    // 0x375e
    __asm_movapd(v24);
    float64_t fracpart; // bp-712, 0x36f0
    int64_t v29 = &fracpart; // 0x3768
    my_modf_isra_0(v29);
    bool v30; // 0x36f0
    bool v31; // 0x36f0
    int128_t v32; // 0x36f0
    int128_t v33; // 0x36f0
    int128_t v34; // 0x36f0
    bool v35; // 0x36f0
    bool v36; // 0x36f0
    if (v13 == 0) {
        int128_t v37 = __asm_movsd((int64_t)fracpart); // 0x3c04
        int128_t v38 = __asm_subsd(v24, v37); // 0x3c0a
        int64_t v39 = __asm_cvttsd2si_4(v38); // 0x3c0f
        v23 = __asm_movsd_1(v38);
        __frontend_reg_store_fpr(v11, (float80_t)v39);
        __frontend_reg_store_fpr(v11, (float80_t)v23 - __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v17, 0.5L);
        float80_t v40 = __frontend_reg_load_fpr(v17); // 0x3c2c
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v11, v40);
        float80_t v41 = __frontend_reg_load_fpr(v17); // 0x3c2e
        float80_t v42 = __frontend_reg_load_fpr(v11); // 0x3c2e
        bool v43 = false; // 0x3c2e
        bool v44 = false; // 0x3c2e
        bool v45 = false; // 0x3c2e
        if (v41 <= v42) {
            v43 = true;
            v44 = false;
            v45 = false;
            if (v41 >= v42) {
                v43 = v41 != v42;
                v44 = v41 != v42;
                v45 = true;
            }
        }
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
        bool v46 = true; // 0x3c32
        bool v47 = v44; // 0x3c32
        bool v48 = v45; // 0x3c32
        int64_t v49 = v39; // 0x3c32
        if (!v43) {
            // 0x3c34
            v49 = v39 + 1;
            v46 = v39 == -1;
            v47 = llvm_ctpop_i8((char)v49) % 2 == 0;
            v48 = v49 == 0;
        }
        // 0x3c38
        __asm_pxor(v7, v7);
        int128_t v50 = __asm_movsd(0x3ff0000000000000); // 0x3c3d
        int128_t v51 = __asm_cvtsi2sd(v49); // 0x3c45
        v23 = __asm_movsd_1(v51);
        __asm_comisd(v51, v50);
        __frontend_reg_store_fpr(v11, (float80_t)v23);
        int64_t v52 = __asm_movsd_1(v51); // 0x3c58
        v2[0] = v52;
        iconvert = v2;
        if (v46) {
            // 0x3820
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
            v30 = v47;
            v35 = v48;
            v32 = v37;
            v34 = v51;
            goto lab_0x3828;
        } else {
            int128_t v53 = __asm_addsd(v37, v50); // 0x3c65
            __frontend_reg_store_fpr(v17, 1.0L);
            v31 = v47;
            v36 = v48;
            v33 = v53;
            goto lab_0x3b5b;
        }
    } else {
        // 0x3779
        __frontend_reg_store_fpr(v11, 1.0L);
        __frontend_reg_store_fpr(v17, 10.0L);
        int64_t v54 = v14 & 0xffffffff; // 0x3781
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v17));
        uint32_t v55 = (int32_t)v54 - 1; // 0x378a
        int64_t v56 = v55; // 0x378d
        while (v55 != 0) {
            // 0x3788
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v17));
            v55 = (int32_t)v56 - 1;
            v56 = v55;
        }
        float80_t v57 = __frontend_reg_load_fpr(v17); // 0x378f
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v11, v57);
        int128_t v58 = __asm_movsd((int64_t)fracpart); // 0x3795
        v23 = __asm_movsd_1(__asm_subsd(v24, v58));
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17) * (float80_t)v23);
        int3_t v59 = v10 - 3;
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        float80_t v60 = __frontend_reg_load_fpr(v59); // 0x37bc
        v23 = v60;
        __frontend_reg_store_fpr(v59, v60);
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17) - __frontend_reg_load_fpr(v59));
        __frontend_reg_store_fpr(v59, 0.5L);
        float80_t v61 = __frontend_reg_load_fpr(v59); // 0x37ce
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        __frontend_reg_store_fpr(v17, v61);
        float80_t v62 = __frontend_reg_load_fpr(v59); // 0x37d0
        float80_t v63 = __frontend_reg_load_fpr(v17); // 0x37d0
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17));
        if (v62 < v63) {
            // 0x3b80
            __asm_pxor(v9, v9);
            int128_t v64 = __asm_cvtsi2sd((int64_t)v23); // 0x3b84
            int64_t v65 = __asm_movsd_1(v64); // 0x3b8a
            v23 = v65;
            __frontend_reg_store_fpr(v17, (float80_t)(float64_t)v65);
            int64_t v66 = __asm_movsd_1(v64); // 0x3b92
            v3[0] = v66;
            v1 = v3;
        } else {
            // 0x37da
            __asm_pxor(v9, v9);
            int128_t v67 = __asm_cvtsi2sd((int64_t)v23 + 1); // 0x37e6
            int64_t v68 = __asm_movsd_1(v67); // 0x37eb
            v23 = v68;
            __frontend_reg_store_fpr(v17, (float80_t)(float64_t)v68);
            int64_t v69 = __asm_movsd_1(v67); // 0x37f3
            v4[0] = v69;
            v1 = v4;
        }
        // 0x37f9
        iconvert = v1;
        __frontend_reg_store_fpr(v59, 1.0L);
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
        uint32_t v70 = (int32_t)v54 - 1; // 0x3802
        int64_t v71 = v70; // 0x3805
        while (v70 != 0) {
            // 0x3800
            __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
            v70 = (int32_t)v71 - 1;
            v71 = v70;
        }
        float80_t v72 = __frontend_reg_load_fpr(v59); // 0x3807
        __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v17));
        __frontend_reg_store_fpr(v17, v72);
        float80_t v73 = __frontend_reg_load_fpr(v59); // 0x3809
        float80_t v74 = __frontend_reg_load_fpr(v17); // 0x3809
        bool v75 = false; // 0x3809
        bool v76 = false; // 0x3809
        bool v77 = false; // 0x3809
        if (v73 <= v74) {
            v75 = true;
            v76 = false;
            v77 = false;
            if (v73 >= v74) {
                v75 = v73 != v74;
                v76 = v73 != v74;
                v77 = true;
            }
        }
        __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v59));
        if (!v75) {
            int128_t v78 = __asm_addsd_3(v58, 0x3ff0000000000000); // 0x3b40
            __frontend_reg_store_fpr(v59, 1.0L);
            __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
            uint32_t v79 = (int32_t)v54 - 1; // 0x3b52
            int64_t v80 = v79; // 0x3b55
            while (v79 != 0) {
                // 0x3b50
                __frontend_reg_store_fpr(v59, __frontend_reg_load_fpr(v59) * __frontend_reg_load_fpr(v11));
                v79 = (int32_t)v80 - 1;
                v80 = v79;
            }
            unsigned char v81 = llvm_ctpop_i8((char)v79); // 0x3b52
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v59));
            float80_t v82 = __frontend_reg_load_fpr(v17); // 0x3b59
            __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v11));
            __frontend_reg_store_fpr(v11, v82);
            v31 = v81 % 2 == 0;
            v36 = true;
            v33 = v78;
            goto lab_0x3b5b;
        } else {
            // 0x3813
            __frontend_reg_store_fpr(v17, __frontend_reg_load_fpr(v17));
            __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11));
            v30 = v76;
            v35 = v77;
            v32 = v58;
            v34 = __asm_movsd(*(int64_t *)&iconvert);
            goto lab_0x3828;
        }
    }
  lab_0x3828:;
    int64_t v83 = (int64_t)currlen;
    int64_t v84 = (int64_t)buffer;
    int64_t v85 = &v23; // 0x3700
    int64_t v86; // bp-697, 0x36f0
    int64_t v87 = &v86; // 0x382d
    int128_t v88 = __asm_pxor(v8, v8); // 0x3832
    int128_t v89 = __asm_movsd(0x3fb999999999999a); // 0x3837
    int128_t v90 = __asm_movsd(0x3fa999999999999a); // 0x3840
    int128_t v91 = __asm_movsd(0x4024000000000000); // 0x3850
    bool v92 = v30; // 0x3859
    bool v93 = v35; // 0x3859
    int64_t v94 = 1;
    int128_t v95 = __asm_movapd(__asm_mulsd_2(v32, v89)); // 0x387c
    my_modf_isra_0(v29);
    int128_t v96 = __asm_movsd((int64_t)fracpart); // 0x3886
    int128_t v97 = __asm_subsd(v95, v96); // 0x388c
    __asm_ucomisd(v96, v88);
    int32_t v98 = __asm_cvttsd2si(__asm_mulsd_2(__asm_addsd(v97, v90), v91)); // 0x38a0
    char v99 = *(char *)((int64_t)v98 + (int64_t)"0123456789abcdef"); // 0x38a7
    *(char *)(v94 + v87) = v99;
    bool v100; // 0x36f0
    int64_t v101; // 0x36f0
    bool v102; // 0x36f0
    while (v92 || !v93) {
        int64_t v103 = v94 - 311; // 0x3864
        unsigned char v104 = llvm_ctpop_i8((char)v103); // 0x3864
        v92 = v104 % 2 == 0;
        v93 = false;
        v100 = v104 % 2 == 0;
        v102 = true;
        v101 = 310;
        if (v103 == 0) {
            goto lab_0x38c3;
        }
        v94++;
        v95 = __asm_movapd(__asm_mulsd_2(v96, v89));
        my_modf_isra_0(v29);
        v96 = __asm_movsd((int64_t)fracpart);
        v97 = __asm_subsd(v95, v96);
        __asm_ucomisd(v96, v88);
        v98 = __asm_cvttsd2si(__asm_mulsd_2(__asm_addsd(v97, v90), v91));
        v99 = *(char *)((int64_t)v98 + (int64_t)"0123456789abcdef");
        *(char *)(v94 + v87) = v99;
    }
    int32_t v105 = (int32_t)v94 - 311; // 0x38b4
    v100 = llvm_ctpop_i8((char)v105) % 2 == 0;
    v102 = v105 == 0;
    v101 = v105 == 0 ? 310 : v94 & 0xffffffff;
  lab_0x38c3:
    // 0x38c3
    __asm_ucomisd(v34, v88);
    int64_t v106 = 0x100000000 * v101 >> 32; // 0x38c8
    v23 = v106;
    int64_t v107 = v85 + 48; // 0x38cf
    *(char *)(v106 + v107) = 0;
    int64_t v108 = v14; // 0x38d4
    int64_t v109 = 0; // 0x38d4
    if (v100 || !v102) {
        bool v110 = v100; // 0x38ee
        bool v111 = v102; // 0x38ee
        int64_t v112 = 1;
        int128_t v113 = __asm_mulsd_2(v34, v89); // 0x3901
        __asm_movapd(v113);
        int128_t v114 = __asm_movapd(v113); // 0x390e
        my_modf_isra_0((int64_t)&iconvert);
        int128_t v115 = __asm_movsd(*(int64_t *)&iconvert); // 0x3918
        int128_t v116 = __asm_subsd(v114, v115); // 0x3921
        __asm_ucomisd(v115, v88);
        int32_t v117 = __asm_cvttsd2si(__asm_mulsd_2(__asm_addsd(v116, v90), v91)); // 0x3935
        char v118 = *(char *)((int64_t)v117 + (int64_t)"0123456789abcdef"); // 0x393c
        int64_t v119; // bp-377, 0x36f0
        *(char *)(v112 + (int64_t)&v119) = v118;
        while (v110 || !v111) {
            int64_t v120 = v112 - 311; // 0x38f4
            v110 = llvm_ctpop_i8((char)v120) % 2 == 0;
            v111 = false;
            if (v120 == 0) {
                goto lab_0x3be8;
            }
            v112++;
            v113 = __asm_mulsd_2(v115, v89);
            __asm_movapd(v113);
            v114 = __asm_movapd(v113);
            my_modf_isra_0((int64_t)&iconvert);
            v115 = __asm_movsd(*(int64_t *)&iconvert);
            v116 = __asm_subsd(v114, v115);
            __asm_ucomisd(v115, v88);
            v117 = __asm_cvttsd2si(__asm_mulsd_2(__asm_addsd(v116, v90), v91));
            v118 = *(char *)((int64_t)v117 + (int64_t)"0123456789abcdef");
            *(char *)(v112 + (int64_t)&v119) = v118;
        }
        if ((int32_t)v112 == 311) {
          lab_0x3be8:
            // 0x3be8
            v108 = v14 + 0xfffffeca;
            v109 = 310;
        } else {
            // 0x3955
            v108 = v14 - v112;
            v109 = v112 & 0xffffffff;
        }
    }
    int64_t v121 = (0x100000000 * v109 >> 32) + v85;
    int64_t v122 = v121 + 368; // 0x3965
    *(char *)v122 = 0;
    int32_t v123 = -1 - (int32_t)v14 + (int32_t)(float32_t)(float64_t)(int64_t)min - v21 - (int32_t)v101; // 0x397d
    int64_t v124 = v123 >= 0 ? (int64_t)v123 : 0; // 0x3982
    int64_t v125; // 0x36f0
    int64_t v126; // 0x36f0
    int64_t v127; // 0x36f0
    int64_t v128; // 0x36f0
    int64_t v129; // 0x36f0
    int64_t v130; // 0x36f0
    if (v16 % 2 == 0) {
        if ((v16 & 16) == 0) {
            // 0x3b00
            v129 = v83;
            v125 = v124;
            if (v123 >= 1) {
                if (v83 < maxlen) {
                    // 0x3b15
                    *(char *)(v83 + v84) = 32;
                }
                int64_t v131 = v83 + 1; // 0x3b1c
                *currlen = v131;
                uint32_t v132 = (int32_t)v124 - 1; // 0x3b23
                int64_t v133 = v132; // 0x3b27
                while (v132 != 0) {
                    int64_t v134 = v131;
                    int64_t v135 = v134; // 0x3b13
                    if (v134 < maxlen) {
                        // 0x3b15
                        *(char *)(v134 + v84) = 32;
                        v135 = v83;
                    }
                    // 0x3b1c
                    v131 = v135 + 1;
                    *currlen = v131;
                    v132 = (int32_t)v133 - 1;
                    v133 = v132;
                }
                int32_t v136 = v124; // 0x3b29
                v129 = v131;
                v125 = v124 - (v136 >= 0 == (v136 != 0) ? v124 : 1) & 0xffffffff;
            }
            goto lab_0x3993;
        } else {
            // 0x3abe
            v129 = v83;
            v125 = v124;
            if (v123 < 1) {
                goto lab_0x3993;
            } else {
                // 0x3ac7
                v130 = v83;
                v126 = v124;
                if (v22 != 0) {
                    // 0x3bd1
                    v128 = v83;
                    v127 = v124;
                    if (v83 < maxlen) {
                        // 0x3bda
                        *(char *)(v83 + v84) = (char)v22;
                        v128 = v83;
                        v127 = v124;
                    }
                    goto lab_0x3ae4;
                } else {
                    goto lab_0x3ad8;
                }
            }
        }
    } else {
        // 0x3990
        v129 = v83;
        v125 = -v124 & 0xffffffff;
        goto lab_0x3993;
    }
  lab_0x3b5b:
    // 0x3b5b
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v11) - __frontend_reg_load_fpr(v17));
    fracpart = __asm_movsd_1(v33);
    float64_t v137 = __frontend_reg_load_fpr(v11); // 0x3b63
    v23 = v137;
    int128_t v138 = __asm_movsd((int64_t)v137); // 0x3b66
    int64_t v139 = __asm_movsd_1(v138); // 0x3b6c
    v5[0] = v139;
    iconvert = v5;
    v30 = v31;
    v35 = v36;
    v32 = v33;
    v34 = v138;
    goto lab_0x3828;
  lab_0x3993:;
    int64_t v140 = v129; // 0x3999
    int64_t v141 = v125; // 0x3999
    if (v22 != 0) {
        int64_t v142 = v129; // 0x399e
        if (v129 < maxlen) {
            // 0x39a0
            *(char *)(v129 + v84) = (char)v22;
            v142 = v83;
        }
        int64_t v143 = v142 + 1; // 0x39a6
        *currlen = v143;
        v140 = v143;
        v141 = v125;
    }
    goto lab_0x39ad;
  lab_0x39ad:;
    int64_t v144 = v107 + (int64_t)v23 - 1;
    int64_t v145; // 0x36f0
    if (v140 < maxlen) {
        // 0x39c5
        *(char *)(v145 + v84) = *(char *)v144;
    }
    int64_t v146 = v140 + 1; // 0x39d0
    *currlen = v146;
    int64_t v147 = v146; // 0x39de
    int64_t v148 = v144; // 0x39de
    while (v87 - (v101 + 0xffffffff & 0xffffffff) + (int64_t)v23 != v144) {
        // 0x39c0
        v144 = v148 - 1;
        if (v147 < maxlen) {
            // 0x39c5
            *(char *)(v145 + v84) = *(char *)v144;
        }
        // 0x39d0
        v146 = v147 + 1;
        *currlen = v146;
        v147 = v146;
        v148 = v144;
    }
    if (v13 != 0) {
        int64_t v149 = v146; // 0x39e8
        if (v146 < maxlen) {
            // 0x39ea
            *(char *)(v146 + v84) = 46;
            v149 = v83;
        }
        int64_t v150 = v149 + 1; // 0x39f1
        *currlen = v150;
        int64_t v151 = v150; // 0x39fa
        if ((int32_t)v108 >= 1) {
            int64_t v152 = v151;
            int64_t v153 = v152; // 0x3a03
            if (v152 < maxlen) {
                // 0x3a05
                *(char *)(v152 + v84) = 48;
                v153 = v83;
            }
            int64_t v154 = v153 + 1; // 0x3a0c
            *currlen = v154;
            uint32_t v155 = (int32_t)(v108 & 0xffffffff) - 1; // 0x3a13
            int64_t v156 = v155; // 0x3a16
            while (v155 != 0) {
                // 0x3a00
                v152 = v154;
                v153 = v152;
                if (v152 < maxlen) {
                    // 0x3a05
                    *(char *)(v152 + v84) = 48;
                    v153 = v83;
                }
                // 0x3a0c
                v154 = v153 + 1;
                *currlen = v154;
                v155 = (int32_t)v156 - 1;
                v156 = v155;
            }
        }
        if (v109 != 0) {
            int64_t v157 = v122 - 1;
            if (v83 < maxlen) {
                // 0x3a3d
                *(char *)(v83 + v84) = *(char *)v157;
            }
            int64_t v158 = v83 + 1; // 0x3a48
            *currlen = v158;
            int64_t v159 = v157; // 0x3a56
            while (367 - (v109 + 0xffffffff & 0xffffffff) + v121 != v157) {
                int64_t v160 = v158;
                v157 = v159 - 1;
                int64_t v161 = v160; // 0x3a3b
                if (v160 < maxlen) {
                    // 0x3a3d
                    *(char *)(v160 + v84) = *(char *)v157;
                    v161 = v83;
                }
                // 0x3a48
                v158 = v161 + 1;
                *currlen = v158;
                v159 = v157;
            }
        }
    }
    // 0x3a58
    if ((int32_t)v141 == 0) {
        // 0x3a79
        return;
    }
    if (v83 < maxlen) {
        // 0x3a65
        *(char *)(v83 + v84) = 32;
    }
    int64_t v162 = v83 + 1; // 0x3a6c
    *currlen = v162;
    uint32_t v163 = (int32_t)v141 + 1; // 0x3a73
    int64_t v164 = v163; // 0x3a77
    while (v163 != 0) {
        int64_t v165 = v162;
        int64_t v166 = v165; // 0x3a63
        if (v165 < maxlen) {
            // 0x3a65
            *(char *)(v165 + v84) = 32;
            v166 = v83;
        }
        // 0x3a6c
        v162 = v166 + 1;
        *currlen = v162;
        v163 = (int32_t)v164 + 1;
        v164 = v163;
    }
  lab_0x3ad8:;
    int64_t v167 = v126;
    int64_t v168 = v130;
    v128 = v168;
    v127 = v167;
    if (v168 < maxlen) {
        // 0x3add
        *(char *)(v168 + v84) = 48;
        v128 = v83;
        v127 = v167;
    }
    goto lab_0x3ae4;
  lab_0x3ae4:;
    int64_t v169 = v128 + 1; // 0x3ae4
    *currlen = v169;
    uint32_t v170 = (int32_t)v127 - 1; // 0x3aeb
    int64_t v171 = v170; // 0x3aeb
    v140 = v169;
    v141 = v171;
    v130 = v169;
    v126 = v171;
    if (v170 != 0) {
        goto lab_0x3ad8;
    } else {
        goto lab_0x39ad;
    }
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x3c70 - 0x458d
// Line range:    130 - 290
int64_t dopr(char * buffer, uint64_t maxlen, char * format, int32_t * args) {
    // 0x3c70
    int64_t v1; // 0x3c70
    uint64_t v2 = v1;
    int64_t v3 = (int64_t)buffer;
    int64_t v4 = (int64_t)format + 1; // 0x3c83
    int64_t v5 = v4; // 0x3c83
    int64_t result2 = 0; // 0x3c99
    int64_t v6; // 0x3c70
    int64_t v7; // 0x3c70
    int64_t v8; // 0x3c70
    int64_t v9; // 0x3c70
    char v10; // 0x3c70
    int64_t v11; // 0x3c70
    int64_t v12; // 0x3c70
    if ((char)v2 != 0) {
        int64_t v13 = (int64_t)args;
        int64_t * v14 = (int64_t *)(v13 + 8);
        v6 = v4;
        v7 = v2 % 256;
        v12 = 0;
        while (true) {
          lab_0x3cee:;
            char v15 = v7; // 0x3cf5
            int64_t v16 = v6; // 0x3cf8
            char v17 = v15; // 0x3cf8
            int64_t v18 = v12; // 0x3cf8
            int64_t v19 = v6; // 0x3cf8
            int64_t v20 = v12; // 0x3cf8
            if (v15 != 37) {
                while (true) {
                  lab_0x3cfa:;
                    uint64_t v21 = v18;
                    int64_t v22 = v16; // 0x3cfd
                    if (v21 < maxlen) {
                        // 0x3cff
                        *(char *)(v21 + v3) = v17;
                        v22 = v5;
                    }
                    char v23 = *(char *)v22; // 0x3d03
                    int64_t v24 = v22 + 1; // 0x3d06
                    v5 = v24;
                    int64_t v25 = v21 + 1; // 0x3d0a
                    result2 = v25;
                    v16 = v24;
                    v17 = v23;
                    v18 = v25;
                    v19 = v24;
                    v20 = v25;
                    switch (v23) {
                        case 0: {
                            goto lab_0x3ca0_3;
                        }
                        case 37: {
                            goto lab_0x3d19;
                        }
                        default: {
                            goto lab_0x3cfa;
                        }
                    }
                }
            }
          lab_0x3d19:
            // 0x3d19
            v11 = v20;
            unsigned char v26 = *(char *)v19; // 0x3d23
            result2 = v11;
            if (v26 == 0) {
                // break -> 0x3ca0
                break;
            }
            int64_t v27 = v26; // 0x3d23
            int64_t result = v27; // 0x3d3b
            if (v26 < 49) {
                // 0x3cb3
                return result;
            }
            int64_t v28 = v19 + 1; // 0x3d2e
            int64_t v29 = (int64_t)g9; // 0x3d4a
            v5 = 0;
            int64_t v30 = v27; // 0x3d5a
            int64_t v31 = v28; // 0x3d5a
            int32_t v32 = 0; // 0x3d5a
            int64_t v33 = v27; // 0x3d5a
            int64_t v34 = v28; // 0x3d5a
            if ((*(char *)(2 * v27 + v29) & 4) != 0) {
                int64_t v35 = 0xffffffd0 + (0x100000000000000 * v30 >> 56); // 0x3d66
                int64_t v36 = v35 & 0xffffffff; // 0x3d66
                v5 = v36;
                unsigned char v37 = *(char *)v31; // 0x3d6a
                result2 = v11;
                if (v37 == 0) {
                    // break (via goto) -> 0x3ca0
                    goto lab_0x3ca0_3;
                }
                int64_t v38 = v31 + 1; // 0x3d62
                int64_t v39 = v37; // 0x3d6a
                v31 = v38;
                while ((*(char *)(2 * v39 + v29) & 4) != 0) {
                    // 0x3d5c
                    v35 = 10 * v36 + 0xffffffd0 + (0x100000000000000 * v39 >> 56);
                    v36 = v35 & 0xffffffff;
                    v5 = v36;
                    v37 = *(char *)v31;
                    result2 = v11;
                    if (v37 == 0) {
                        // break (via goto) -> 0x3ca0
                        goto lab_0x3ca0_3;
                    }
                    // 0x3d76
                    v38 = v31 + 1;
                    v39 = v37;
                    v31 = v38;
                }
                // 0x3d82
                v32 = v35;
                v33 = v39;
                v34 = v38;
            }
            int64_t v40 = v34;
            int64_t v41 = v33; // 0x3d84
            int64_t v42 = v40; // 0x3d84
            if (v33 == 42) {
                uint32_t v43 = v32; // 0x42b8
                if (v43 < 48) {
                    // 0x42bf
                    v5 = *(int64_t *)(v13 + 16) + (int64_t)v43;
                    *args = v43 + 8;
                } else {
                    int64_t v44 = *v14; // 0x4313
                    v5 = v44;
                    *v14 = v44 + 8;
                }
                unsigned char v45 = *(char *)v40; // 0x42ca
                result2 = v11;
                if (v45 == 0) {
                    // break -> 0x3ca0
                    break;
                }
                // 0x42dc
                v41 = v45;
                v42 = v40 + 1;
            }
            int64_t v46 = v42;
            int64_t v47 = v41; // 0x3d92
            int64_t v48 = v46; // 0x3d92
            if ((char)v41 == 46) {
                char v49 = *(char *)v46; // 0x3e48
                result2 = v11;
                if (v49 == 0) {
                    // break -> 0x3ca0
                    break;
                }
                int64_t v50 = v46;
                unsigned char v51 = v49;
                int64_t v52 = v50 + 1;
                int64_t v53 = v51;
                while ((*(char *)(2 * v53 + v29) & 4) != 0) {
                    char v54 = *(char *)v52; // 0x3e7c
                    result2 = v11;
                    if (v54 == 0) {
                        // break (via goto) -> 0x3ca0
                        goto lab_0x3ca0_3;
                    }
                    v50 = v52;
                    v51 = v54;
                    v52 = v50 + 1;
                    v53 = v51;
                }
                // 0x4200
                v47 = v53;
                v48 = v52;
                if (v51 == 42) {
                    uint32_t v55 = *(int32_t *)&v5; // 0x4208
                    if (v55 < 48) {
                        // 0x4213
                        *args = v55 + 8;
                    } else {
                        // 0x42e4
                        *v14 = *v14 + 8;
                    }
                    unsigned char v56 = *(char *)v52; // 0x421e
                    result2 = v11;
                    if (v56 == 0) {
                        // break -> 0x3ca0
                        break;
                    }
                    // 0x4231
                    v47 = v56;
                    v48 = v50 + 2;
                }
            }
            int64_t v57 = v48;
            int64_t v58 = v47;
            switch ((char)v58) {
                case 104: {
                    char v59 = *(char *)v57; // 0x429e
                    v10 = v59;
                    v9 = v57 + 1;
                    if (v59 == 0) {
                        // break -> 0x3ca0
                        break;
                    }
                    goto lab_0x4256;
                }
                case 108: {
                    char v60 = *(char *)v57; // 0x4239
                    int64_t v61 = v57 + 1;
                    result2 = v11;
                    v10 = v60;
                    v9 = v61;
                    switch (v60) {
                        case 108: {
                            char v62 = *(char *)v61; // 0x42f5
                            v10 = v62;
                            v9 = v57 + 2;
                            if (v62 == 0) {
                                // break -> 0x3ca0
                                break;
                            }
                            goto lab_0x4256;
                        }
                        case 0: {
                            goto lab_0x3ca0_3;
                        }
                        default: {
                            goto lab_0x4256;
                        }
                    }
                }
                case 76: {
                    unsigned char v63 = *(char *)v57; // 0x426f
                    if (v63 == 0) {
                        // break -> 0x3ca0
                        break;
                    }
                    int64_t v64 = (int64_t)v63 + 0xffffffdb; // 0x427b
                    v8 = v57 + 1;
                    if ((char)v64 < 84) {
                        int32_t v65 = *(int32_t *)((4 * v64 & 1020) + (int64_t)&g6); // 0x4294
                        return (int64_t)v65 + (int64_t)&g6;
                    }
                    goto lab_0x3ee3;
                }
                default: {
                    // 0x3db0
                    v8 = v57;
                    if ((char)(v58 + 0xffffffdb) < 84) {
                        // 0x3dbb
                        int64_t v66; // 0x3db0
                        int32_t v67 = *(int32_t *)((4 * v66 & 1020) + (int64_t)&g4); // 0x3dc5
                        return (int64_t)v67 + (int64_t)&g4;
                    }
                    goto lab_0x3ee3;
                }
            }
        }
    }
  lab_0x3ca0_3:
    // 0x3ca0
    if (maxlen == 0) {
        // 0x3cb3
        return result2;
    }
    uint64_t v68 = maxlen - 1;
    if (v68 > result2) {
        // 0x3cae
        *(char *)(result2 + v3) = 0;
        // 0x3cb3
        return result2;
    }
    // 0x3cc8
    *(char *)(v68 + v3) = 0;
    return result2;
  lab_0x3ee3:;
    unsigned char v69 = *(char *)v8; // 0x3ee3
    int64_t v70 = v8 + 1; // 0x3ee7
    v5 = v70;
    result2 = v11;
    v6 = v70;
    v7 = v69;
    v12 = v11;
    if (v69 == 0) {
        // break -> 0x3ca0
        goto lab_0x3ca0_3;
    }
    goto lab_0x3cee;
  lab_0x4256:;
    int64_t v71 = (int64_t)v10 + 0xffffffdb; // 0x4256
    v8 = v9;
    if ((char)v71 < 84) {
        int32_t v72 = *(int32_t *)((4 * v71 & 1020) + (int64_t)&g5); // 0x4264
        return (int64_t)v72 + (int64_t)&g5;
    }
    goto lab_0x3ee3;
}

// Address range: 0x458d - 0x4598
int64_t function_458d(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x458d
    int64_t v1; // 0x458d
    return v1 & 0xffffffff;
}

// Address range: 0x4598 - 0x45a3
int64_t function_4598(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x4598
    int64_t v1; // 0x4598
    return v1 & 0xffffffff;
}

// Address range: 0x45a3 - 0x45ae
int64_t function_45a3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x45a3
    int64_t v1; // 0x45a3
    return v1 & 0xffffffff;
}

// Address range: 0x45ae - 0x45b5
int64_t function_45ae(void) {
    // 0x45ae
    int64_t v1; // 0x45ae
    return v1 & 0xffffffff;
}

// Address range: 0x45b5 - 0x45c0
int64_t function_45b5(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x45b5
    int64_t v1; // 0x45b5
    return v1 & 0xffffffff;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x45c0 - 0x46cc
// Line range:    751 - 769
int32_t libmin_printf(char * fmt, ...) {
    // 0x45c0
    int64_t v1; // 0x45c0
    if ((char)v1 != 0) {
        // 0x45fc
        int128_t v2; // 0x45c0
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
    }
    int64_t v3 = 8; // bp-1248, 0x4666
    char v4; // bp-1224, 0x45c0
    dopr(&v4, (int64_t)&g3, fmt, (int32_t *)&v3);
    if (v4 == 0) {
        // 0x46c0
        return 0;
    }
    int64_t v5 = &v4;
    libtarg_putc(v4);
    int64_t v6 = v5 + 1; // 0x46a9
    char v7 = *(char *)v6; // 0x46a9
    while (v7 != 0) {
        // 0x46a0
        v5 = v6;
        libtarg_putc(v7);
        v6 = v5 + 1;
        v7 = *(char *)v6;
    }
    // 0x46b6
    int64_t v8; // bp+1225, 0x45c0
    return v5 + (int64_t)&v8;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_printf.c
// Address range: 0x46d0 - 0x477b
// Line range:    772 - 782
int32_t libmin_snprintf(char * s, int64_t size, char * fmt, ...) {
    // 0x46d0
    int64_t v1; // 0x46d0
    if ((char)v1 != 0) {
        // 0x46f6
        int128_t v2; // 0x46d0
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
        __asm_movaps(v2);
    }
    int64_t v3 = 24; // bp-224, 0x474a
    dopr(s, size, fmt, (int32_t *)&v3);
    *(char *)((int64_t)s - 1 + size) = 0;
    return libmin_strlen(s);
}

// Address range: 0x4780 - 0x47d3
int64_t libmin_srand(void) {
    // 0x4780
    mt_initialized = 1;
    int64_t v1 = (int64_t)&mt;
    int64_t v2 = v1 + 4; // 0x47a9
    int64_t v3; // 0x4780
    int64_t v4 = 0x10dcd * v3 + 1; // 0x47ad
    int64_t v5 = 0x10dcd * v4; // 0x47b2
    *(int32_t *)v1 = (int32_t)v4 / 0x10000 | (int32_t)v3 & -0x10000;
    v3 = v5 + 1 & 0xffffffff;
    while (v2 != (int64_t)&g15) {
        // 0x47a0
        v1 = v2;
        v2 = v1 + 4;
        v4 = 0x10dcd * v3 + 1;
        v5 = 0x10dcd * v4;
        *(int32_t *)v1 = (int32_t)v4 / 0x10000 | (int32_t)v3 & -0x10000;
        v3 = v5 + 1 & 0xffffffff;
    }
    // 0x47c8
    mti = 624;
    return v5 & 0xffffffff;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_rand.c
// Address range: 0x47e0 - 0x4985
// Line range:    42 - 30
int32_t libmin_rand(void) {
    // 0x47e0
    if (mt_initialized == 0) {
        // 0x4918
        libmin_printf("ERROR: rng is not initialized, call mysrand()!\n");
        libmin_fail(1);
        // UNREACHABLE
    }
    int32_t v1 = mti; // 0x47f6
    int32_t v2; // 0x47e0
    int32_t v3; // 0x47e0
    if (v1 > 623) {
        if (v1 == 625) {
            // 0x4935
            mt_initialized = 1;
            int64_t v4 = 0x1105; // 0x4952
            int64_t v5 = (int64_t)&mt;
            int64_t v6 = v5 + 4; // 0x4961
            int64_t v7 = 0x10dcd * v4 + 1; // 0x4965
            *(int32_t *)v5 = (int32_t)v7 / 0x10000 | (int32_t)v4 & -0x10000;
            v4 = 0x10dcd * v7 + 1 & 0xffffffff;
            while (v6 != (int64_t)&g15) {
                // 0x4958
                v5 = v6;
                v6 = v5 + 4;
                v7 = 0x10dcd * v4 + 1;
                *(int32_t *)v5 = (int32_t)v7 / 0x10000 | (int32_t)v4 & -0x10000;
                v4 = 0x10dcd * v7 + 1 & 0xffffffff;
            }
        }
        int64_t v8 = (int64_t)&mt;
        int32_t * v9 = (int32_t *)v8; // 0x4870
        int64_t v10 = v8 + 4; // 0x4872
        int32_t v11 = *(int32_t *)v10; // 0x4872
        int32_t v12 = *(int32_t *)(v8 + 1588); // 0x488d
        int32_t v13 = *(int32_t *)((int64_t)(4 * v11 & 4) | (int64_t)&g7); // 0x4893
        *v9 = v13 ^ v12 ^ (v11 & 0x7ffffffe | *v9 & -0x80000000) / 2;
        int64_t v14 = (int64_t)&mt; // 0x489c
        while (v10 != (int64_t)&g12) {
            // 0x4870
            v8 = v10;
            v9 = (int32_t *)v8;
            v10 = v8 + 4;
            v11 = *(int32_t *)v10;
            v12 = *(int32_t *)(v8 + 1588);
            v13 = *(int32_t *)((int64_t)(4 * v11 & 4) | (int64_t)&g7);
            *v9 = v13 ^ v12 ^ (v11 & 0x7ffffffe | *v9 & -0x80000000) / 2;
            v14 = (int64_t)&mt;
        }
        int32_t v15 = *(int32_t *)(v14 + (int64_t)&g1); // 0x48a8
        int32_t v16 = *(int32_t *)(v14 + (int64_t)&g2); // 0x48ae
        int64_t v17 = v14 + 4; // 0x48b4
        int32_t v18 = *(int32_t *)v14; // 0x48cc
        int32_t v19 = *(int32_t *)((int64_t)(4 * v16 & 4) | (int64_t)&g7); // 0x48cf
        *(int32_t *)(v14 + 908) = v19 ^ v18 ^ (v16 & 0x7ffffffe | v15 & -0x80000000) / 2;
        v14 = v17;
        while (v17 != (int64_t)&g13) {
            // 0x48a8
            v15 = *(int32_t *)(v14 + (int64_t)&g1);
            v16 = *(int32_t *)(v14 + (int64_t)&g2);
            v17 = v14 + 4;
            v18 = *(int32_t *)v14;
            v19 = *(int32_t *)((int64_t)(4 * v16 & 4) | (int64_t)&g7);
            *(int32_t *)(v14 + 908) = v19 ^ v18 ^ (v16 & 0x7ffffffe | v15 & -0x80000000) / 2;
            v14 = v17;
        }
        int32_t v20 = mt[0]; // 0x48dd
        int32_t v21 = *(int32_t *)((int64_t)(4 * v20 & 4) | (int64_t)&g7); // 0x4905
        g14 = v21 ^ g13 ^ (g14 & -0x80000000 | v20 & 0x7ffffffe) / 2;
        v2 = v20;
        v3 = 1;
    } else {
        // 0x4804
        v2 = *(int32_t *)(4 * (int64_t)v1 + (int64_t)&mt);
        v3 = v1 + 1;
    }
    uint32_t v22 = v2;
    mti = v3;
    int32_t v23 = v22 / 2048 ^ v22; // 0x4820
    int32_t v24 = 128 * v23 & -0x62d3a980 ^ v23; // 0x482c
    uint32_t v25 = 0x8000 * v24 & -0x103a0000 ^ v24; // 0x4839
    return v25 / 0x40000 ^ v25 % 0x80000000;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_strlen.c
// Address range: 0x4990 - 0x49bb
// Line range:    5 - 15
int64_t libmin_strlen(char * str) {
    int64_t v1 = (int64_t)str;
    if (str == NULL || (char)v1 == 0) {
        // 0x49b8
        return 0;
    }
    int64_t v2 = v1; // 0x4997
    v2++;
    while (*(char *)v2 != 0) {
        // 0x49a8
        v2++;
    }
    // 0x49b1
    return v2 - v1;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_success.c
// Address range: 0x49c0 - 0x49c9
// Line range:    5 - 7
void libmin_success(void) {
    // 0x49c0
    libtarg_success();
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_ctype.c
// Address range: 0x49d0 - 0x49f2
// Line range:    140 - 146
int32_t _isctype(uint32_t c, int32_t mask) {
    int32_t result = 0; // 0x49df
    if (c < 256) {
        uint16_t v1 = *(int16_t *)((0x100000000 * (int64_t)c >> 31) + (int64_t)g9); // 0x49eb
        result = (int32_t)v1 & mask;
    }
    // 0x49f1
    return result;
}

// From module:   /home/jad/asm-to-asm/bringup-bench/ackermann/libmin_fail.c
// Address range: 0x4a00 - 0x4a1f
// Line range:    5 - 8
void libmin_fail(uint32_t code) {
    // 0x4a00
    libmin_printf("ERROR: failure with termination code `%d'\n", (int64_t)code);
    libtarg_fail(code);
}

// Address range: 0x4a20 - 0x4a2d
int64_t _fini(void) {
    // 0x4a20
    int64_t result; // 0x4a20
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 61

