#!/usr/bin/env python3
import os
import re
import json
import shutil
import subprocess
import argparse

"""
================================================================================
Usage: run_successful.py
================================================================================

This script reads a JSON results file generated by the step3 script, identifies
all problems that were marked as "success", and runs their corresponding ARM
executables using QEMU to display their output.

--------------------------------------------------------------------------------
** IMPORTANT: PREREQUISITES **
--------------------------------------------------------------------------------

1.  QEMU USER-MODE EMULATION: The script uses `qemu-aarch64` to run the
    compiled ARM executables. If it's not installed, run:
    `sudo apt install qemu-user-static`
    Verify with: `which qemu-aarch64`

2.  PIPELINE ARTIFACTS: This script depends on the output of the step3 script.
    You must have the JSON results file and the compiled ARM executables
    available in the 'results' and 'artifacts/step3' directories.

--------------------------------------------------------------------------------
** USAGE EXAMPLES **
--------------------------------------------------------------------------------

The script requires one argument: the path to the JSON results file you want
to process.

1.  Run the successful executables from the O2 mctollClang run:
    `python3 run_successful.py ../results/O2_mctollClang_results.json`

2.  Run the successful executables from a clang 18, O3 run:
    `python3 run_successful.py ../results/O3_clang18.1.8_results.json`

3.  See all available options:
    `python3 run_successful.py --help`

================================================================================
"""

# ========================= SETUP ==========================
script_dir = os.path.abspath(os.path.dirname(__file__))
project_root = os.path.dirname(script_dir)
artifacts_dir = os.path.join(project_root, "artifacts")
exe_base_dir = os.path.join(artifacts_dir, "step3")
# ===========================================================

def main():
    parser = argparse.ArgumentParser(
        description="Run QEMU on executables marked as 'success' in a results JSON file."
    )
    parser.add_argument(
        'json_file',
        help="Path to the results JSON file to process."
    )
    args = parser.parse_args()

    # --- Prerequisite Checks ---
    if not os.path.exists(args.json_file):
        print(f"ERROR: Results file not found at '{args.json_file}'")
        return
    qemu_path = shutil.which("qemu-aarch64")
    if not qemu_path:
        print("ERROR: 'qemu-aarch64' executable not found. Please ensure QEMU is installed.")
        return

    # --- Parse filename to determine the executables directory ---
    json_filename = os.path.basename(args.json_file)
    match = re.match(r'^(O\d)_(.+?)_results\.json$', json_filename)
    if not match:
        print(f"ERROR: Could not parse optimization and toolchain from filename '{json_filename}'")
        print("Expected format: O#_<toolchain>_results.json (e.g., O2_mctollClang_results.json)")
        return

    opt_str = match.group(1)
    toolchain_name = match.group(2)
    exe_dir = os.path.join(exe_base_dir, opt_str, f"{toolchain_name}_armv8")

    if not os.path.isdir(exe_dir):
        print(f"ERROR: Corresponding executable directory not found at '{exe_dir}'")
        return

    print("\n" + "="*60)
    print(f"Processing results from: {args.json_file}")
    print(f"Looking for executables in: {exe_dir}")
    print("="*60 + "\n")

    # --- Read JSON and Filter Successful Problems ---
    try:
        with open(args.json_file, 'r') as f:
            results_data = json.load(f)
    except json.JSONDecodeError:
        print(f"ERROR: Invalid JSON in file '{args.json_file}'")
        return

    successful_problems = [r for r in results_data if r.get('status') == 'success']

    if not successful_problems:
        print("No successful problems found in the specified results file.")
        return

    print(f"Found {len(successful_problems)} successful problems. Running them with QEMU...")

    # --- Main Loop ---
    run_success_count = 0
    unexpected_failures = []

    for result in successful_problems:
        problem_name = result['problem']
        print(f"\n--- Running: {problem_name} ---")

        exe_path = os.path.join(exe_dir, f"{problem_name}_arm_exe")

        if not os.path.exists(exe_path):
            print(f"  - WARNING: Executable not found at '{exe_path}'. Skipping.")
            unexpected_failures.append(problem_name)
            continue

        try:
            qemu_cmd = ["qemu-aarch64", exe_path]
            run_result = subprocess.run(qemu_cmd, check=True, capture_output=True, text=True, timeout=30)
            
            print("  - Status: SUCCESS")
            if run_result.stdout:
                print("  - Output:")
                # Indent the output for readability
                for line in run_result.stdout.strip().splitlines():
                    print(f"    {line}")
            
            run_success_count += 1

        except subprocess.CalledProcessError as e:
            print(f"  - Status: UNEXPECTED FAILURE (QEMU returned non-zero exit code)")
            if e.stderr:
                print(f"  - QEMU Error:\n{e.stderr.strip()}")
            unexpected_failures.append(problem_name)
        except Exception as e:
            print(f"  - Status: UNEXPECTED FAILURE (An error occurred)")
            print(f"    - Reason: {e}")
            unexpected_failures.append(problem_name)

    # --- Final Summary ---
    print("\n" + "="*60)
    print("--- Final Summary ---")
    print(f"Total successful problems from JSON: {len(successful_problems)}")
    print(f"  - ✅ Ran successfully via QEMU: {run_success_count}")
    print(f"  - ❌ Unexpected Failures: {len(unexpected_failures)}")
    if unexpected_failures:
        print(f"    - Failed problems: {', '.join(unexpected_failures)}")
    print("="*60)

if __name__ == "__main__":
    main()